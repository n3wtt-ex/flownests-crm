"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   isSupabaseConfigured: function() { return /* binding */ isSupabaseConfigured; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// Supabase-backed CRM API helpers (SSR/RLS friendly)\n// Falls back to mock when env is missing. Types from supabase.types.ts\n\n// Exported\nconst SUPABASE_URL = \"https://jkrxflynplzczpkzhygs.supabase.co\";\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImprcnhmbHlucGx6Y3pwa3poeWdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzNDczOTksImV4cCI6MjA2OTkyMzM5OX0.QYOOVOK4cI44IsSQz1MGdSQbUKJwI4frO-YdNv8hvpU\";\nfunction getClient() {\n    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) return null;\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            persistSession: false\n        }\n    });\n}\n// Mock fallback for dev without env configured\nconst mock = {\n    stages: [\n        {\n            id: \"s1\",\n            name: \"New\",\n            order_index: 10,\n            probability: 10\n        },\n        {\n            id: \"s2\",\n            name: \"Contacted\",\n            order_index: 20,\n            probability: 25\n        },\n        {\n            id: \"s3\",\n            name: \"Qualified\",\n            order_index: 30,\n            probability: 45\n        }\n    ],\n    dealsByStage: {\n        s1: [\n            {\n                id: \"d1\",\n                title: \"Acme - Pilot\",\n                stage_id: \"s1\",\n                amount: 2500,\n                currency: \"USD\"\n            }\n        ],\n        s2: [],\n        s3: []\n    },\n    activities: [\n        {\n            id: \"a1\",\n            type: \"system\",\n            related_type: \"deal\",\n            related_id: \"d1\",\n            content: \"Seed: deal created\",\n            meta_json: null,\n            created_by: null,\n            created_at: new Date().toISOString()\n        }\n    ],\n    contact: {\n        id: \"c1\",\n        email: \"john@acme.com\",\n        full_name: \"John Doe\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/johndoe\",\n        website: \"https://acme.com\",\n        phone: null,\n        company_id: null,\n        owner_id: null,\n        lifecycle_stage: \"lead\",\n        reply_status: null,\n        reply_summary: null,\n        generated_body_step1: null,\n        generated_body_step2: null,\n        generated_body_step3: null,\n        latest_email_sent_at: null,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    }\n};\nasync function getPipelineStages(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.stages;\n    // default pipeline resolve\n    const pipeline = pipelineId && pipelineId !== \"p_default\" ? {\n        id: pipelineId\n    } : await (async ()=>{\n        const { data, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        return data;\n    })();\n    if (!(pipeline === null || pipeline === void 0 ? void 0 : pipeline.id)) return [];\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"id,name,order_index,probability\").eq(\"pipeline_id\", pipeline.id).order(\"order_index\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getDealsByPipeline(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.dealsByStage;\n    // resolve pipeline id\n    let pid = pipelineId;\n    if (!pid) {\n        const { data, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        pid = data === null || data === void 0 ? void 0 : data.id;\n    }\n    if (!pid) return {};\n    // fetch deals + join names\n    const { data: deals, error } = await supabase.from(\"deals\").select(\"id,title,amount,currency,stage_id,company_id,contact_id\").eq(\"pipeline_id\", pid);\n    if (error) throw error;\n    // fetch related names in one go\n    const companyIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.company_id).filter(Boolean)));\n    const contactIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.contact_id).filter(Boolean)));\n    const [companiesRes, contactsRes] = await Promise.all([\n        companyIds.length ? supabase.from(\"companies\").select(\"id,name\").in(\"id\", companyIds) : Promise.resolve({\n            data: [],\n            error: null\n        }),\n        contactIds.length ? supabase.from(\"contacts\").select(\"id,full_name\").in(\"id\", contactIds) : Promise.resolve({\n            data: [],\n            error: null\n        })\n    ]);\n    if (companiesRes.error) throw companiesRes.error;\n    if (contactsRes.error) throw contactsRes.error;\n    var _companiesRes_data;\n    const companyMap = new Map(((_companiesRes_data = companiesRes.data) !== null && _companiesRes_data !== void 0 ? _companiesRes_data : []).map((c)=>[\n            c.id,\n            c.name\n        ]));\n    var _contactsRes_data;\n    const contactMap = new Map(((_contactsRes_data = contactsRes.data) !== null && _contactsRes_data !== void 0 ? _contactsRes_data : []).map((c)=>[\n            c.id,\n            c.full_name\n        ]));\n    const grouped = {};\n    for (const d of deals !== null && deals !== void 0 ? deals : []){\n        var _d_amount, _d_currency, _companyMap_get, _contactMap_get;\n        const card = {\n            id: d.id,\n            title: d.title,\n            amount: (_d_amount = d.amount) !== null && _d_amount !== void 0 ? _d_amount : null,\n            currency: (_d_currency = d.currency) !== null && _d_currency !== void 0 ? _d_currency : null,\n            stage_id: d.stage_id,\n            company: d.company_id ? (_companyMap_get = companyMap.get(d.company_id)) !== null && _companyMap_get !== void 0 ? _companyMap_get : null : null,\n            contact: d.contact_id ? (_contactMap_get = contactMap.get(d.contact_id)) !== null && _contactMap_get !== void 0 ? _contactMap_get : null : null\n        };\n        if (!grouped[d.stage_id]) grouped[d.stage_id] = [];\n        grouped[d.stage_id].push(card);\n    }\n    return grouped;\n}\nasync function getDealDetail(id) {\n    const supabase = getClient();\n    if (!supabase) {\n        const anyDeal = Object.values(mock.dealsByStage).flat()[0];\n        if (!anyDeal) return null;\n        var _anyDeal_amount, _anyDeal_currency;\n        // minimal mock cast\n        return {\n            id: anyDeal.id,\n            title: anyDeal.title,\n            amount: (_anyDeal_amount = anyDeal.amount) !== null && _anyDeal_amount !== void 0 ? _anyDeal_amount : null,\n            currency: (_anyDeal_currency = anyDeal.currency) !== null && _anyDeal_currency !== void 0 ? _anyDeal_currency : null,\n            company_id: null,\n            contact_id: null,\n            pipeline_id: \"default\",\n            stage_id: anyDeal.stage_id,\n            status: \"open\",\n            source: \"inbound\",\n            notes: \"Mock\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n            close_date: null\n        };\n    }\n    const { data, error } = await supabase.from(\"deals\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    const supabase = getClient();\n    if (!supabase) return mock.activities;\n    const { data, error } = await supabase.from(\"activities\").select(\"*\").eq(\"related_type\", relatedType).eq(\"related_id\", relatedId).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getContact(id) {\n    const supabase = getClient();\n    if (!supabase) return mock.contact;\n    const { data, error } = await supabase.from(\"contacts\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\n// Added to resolve a build error where 'getContactForDeal' was reported as missing,\n// even though it's not explicitly imported in the relevant files.\n// It simply delegates to getContact, as that's the intended logic.\nasync function getContactForDeal(contactId) {\n    return getContact(contactId);\n}\n// Added to resolve a build error where 'getStageName' was reported as missing.\nasync function getStageName(stageId) {\n    var _mock_stages_find;\n    const supabase = getClient();\n    if (!supabase) return (_mock_stages_find = mock.stages.find((s)=>s.id === stageId)) === null || _mock_stages_find === void 0 ? void 0 : _mock_stages_find.name;\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"name\").eq(\"id\", stageId).maybeSingle();\n    if (error) throw error;\n    return data === null || data === void 0 ? void 0 : data.name;\n}\n// Actions (write) â€” protected by RLS; expect JWT in frontend context.\n// For SSR/Edge secure writes, prefer server-only key or edge function proxy.\nasync function updateDealStage(dealId, nextStageId) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"deals\").update({\n        stage_id: nextStageId\n    }).eq(\"id\", dealId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function updateContactStatus(contactId, status) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"contacts\").update({\n        reply_status: status\n    }).eq(\"id\", contactId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function getCalendarLink(contactId) {\n    // This is a mock implementation. In a real app, you'd generate a unique link\n    // or fetch it from a calendar service.\n    return {\n        ok: true,\n        url: \"https://cal.com/your-username/\".concat(contactId)\n    };\n}\n// Helper to detect env presence\nfunction isSupabaseConfigured() {\n    return Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);\n}\nasync function getOpenDealsCount(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return 42; // Mock data\n    let query = supabase.from(\"deals\").select(\"id\", {\n        count: \"exact\"\n    }).eq(\"status\", \"open\");\n    if (pipelineId) {\n        query = query.eq(\"pipeline_id\", pipelineId);\n    }\n    const { count, error } = await query;\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getLast7DaysReplyCount() {\n    const supabase = getClient();\n    if (!supabase) return 15; // Mock data\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    const { count, error } = await supabase.from(\"contacts\").select(\"id\", {\n        count: \"exact\"\n    }).not(\"reply_status\", \"is\", null).gte(\"updated_at\", sevenDaysAgo.toISOString()); // Assuming updated_at reflects reply status changes\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getPipelineConversion(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) {\n        return [\n            {\n                stage_id: \"s1\",\n                stage_name: \"New\",\n                count: 10,\n                conversion_to_next: 50\n            },\n            {\n                stage_id: \"s2\",\n                stage_name: \"Contacted\",\n                count: 5,\n                conversion_to_next: 80\n            },\n            {\n                stage_id: \"s3\",\n                stage_name: \"Qualified\",\n                count: 4,\n                conversion_to_next: undefined\n            }\n        ];\n    }\n    // This is a simplified mock for conversion. A real implementation would involve\n    // more complex SQL queries or a materialized view to calculate conversions between stages.\n    const stages = await getPipelineStages(pipelineId);\n    const dealsByStage = await getDealsByPipeline(pipelineId);\n    const stageCounts = {};\n    for (const stage of stages){\n        var _dealsByStage_stage_id;\n        stageCounts[stage.id] = ((_dealsByStage_stage_id = dealsByStage[stage.id]) === null || _dealsByStage_stage_id === void 0 ? void 0 : _dealsByStage_stage_id.length) || 0;\n    }\n    const conversionData = [];\n    for(let i = 0; i < stages.length; i++){\n        const currentStage = stages[i];\n        const currentCount = stageCounts[currentStage.id];\n        let conversionToNext = undefined;\n        if (i < stages.length - 1) {\n            const nextStage = stages[i + 1];\n            const nextCount = stageCounts[nextStage.id];\n            if (currentCount > 0) {\n                conversionToNext = Math.round(nextCount / currentCount * 100);\n            }\n        }\n        conversionData.push({\n            stage_id: currentStage.id,\n            stage_name: currentStage.name,\n            count: currentCount,\n            conversion_to_next: conversionToNext\n        });\n    }\n    return conversionData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEO0FBQ3JELHVFQUF1RTtBQUVuQjtBQXNCWCxXQUFXO0FBRXBELE1BQU1DLGVBQWVDLDBDQUFvQztBQUN6RCxNQUFNRyxvQkFBb0JILGtOQUF5QztBQUVuRSxTQUFTSztJQUNQLElBQUksQ0FBQ04sZ0JBQWdCLENBQUNJLG1CQUFtQixPQUFPO0lBQ2hELE9BQU9MLG1FQUFZQSxDQUFXQyxjQUFjSSxtQkFBbUI7UUFDN0RHLE1BQU07WUFDSkMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBLCtDQUErQztBQUMvQyxNQUFNQyxPQUFPO0lBQ1hDLFFBQVE7UUFDTjtZQUFFQyxJQUFJO1lBQU1DLE1BQU07WUFBT0MsYUFBYTtZQUFJQyxhQUFhO1FBQUc7UUFDMUQ7WUFBRUgsSUFBSTtZQUFNQyxNQUFNO1lBQWFDLGFBQWE7WUFBSUMsYUFBYTtRQUFHO1FBQ2hFO1lBQUVILElBQUk7WUFBTUMsTUFBTTtZQUFhQyxhQUFhO1lBQUlDLGFBQWE7UUFBRztLQUNqRTtJQUNEQyxjQUFjO1FBQ1pDLElBQUk7WUFBQztnQkFBRUwsSUFBSTtnQkFBTU0sT0FBTztnQkFBZ0JDLFVBQVU7Z0JBQU1DLFFBQVE7Z0JBQU1DLFVBQVU7WUFBTTtTQUFFO1FBQ3hGQyxJQUFJLEVBQUU7UUFDTkMsSUFBSSxFQUFFO0lBQ1I7SUFDQUMsWUFBWTtRQUNWO1lBQUVaLElBQUk7WUFBTWEsTUFBTTtZQUFVQyxjQUFjO1lBQVFDLFlBQVk7WUFBTUMsU0FBUztZQUFzQkMsV0FBVztZQUFNQyxZQUFZO1lBQU1DLFlBQVksSUFBSUMsT0FBT0MsV0FBVztRQUFHO0tBQzVLO0lBQ0RDLFNBQVM7UUFDUHRCLElBQUk7UUFBTXVCLE9BQU87UUFBaUJDLFdBQVc7UUFBWWxCLE9BQU87UUFDaEVtQixjQUFjO1FBQW1DQyxTQUFTO1FBQzFEQyxPQUFPO1FB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Q3pCLE1BQU04RCxZQUFZbEksTUFBTSxDQUFDOEgsSUFBSSxFQUFFO1lBQy9CLE1BQU1LLFlBQVlSLFdBQVcsQ0FBQ08sVUFBVWpJLEVBQUUsQ0FBQztZQUMzQyxJQUFJK0gsZUFBZSxHQUFHO2dCQUNwQkMsbUJBQW1CRyxLQUFLQyxLQUFLLENBQUMsWUFBYUwsZUFBZ0I7WUFDN0Q7UUFDRjtRQUVBSCxlQUFlOUMsSUFBSSxDQUFDO1lBQ2xCdkUsVUFBVXVILGFBQWE5SCxFQUFFO1lBQ3pCdUgsWUFBWU8sYUFBYTdILElBQUk7WUFDN0I4RyxPQUFPZ0I7WUFDUFAsb0JBQW9CUTtRQUN0QjtJQUNGO0lBRUEsT0FBT0o7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc2VydmljZXMvY3JtQXBpLnRzPzgxZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3VwYWJhc2UtYmFja2VkIENSTSBBUEkgaGVscGVycyAoU1NSL1JMUyBmcmllbmRseSlcclxuLy8gRmFsbHMgYmFjayB0byBtb2NrIHdoZW4gZW52IGlzIG1pc3NpbmcuIFR5cGVzIGZyb20gc3VwYWJhc2UudHlwZXMudHNcclxuXHJcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcclxuaW1wb3J0IHR5cGUgeyBEYXRhYmFzZSwgVGFibGVzIH0gZnJvbSAnLi9zdXBhYmFzZS50eXBlcydcclxuXHJcbmV4cG9ydCB0eXBlIERlYWxDYXJkID0geyAvLyBFeHBvcnRlZFxyXG4gIGlkOiBzdHJpbmdcclxuICB0aXRsZTogc3RyaW5nXHJcbiAgY29tcGFueT86IHN0cmluZyB8IG51bGxcclxuICBjb250YWN0Pzogc3RyaW5nIHwgbnVsbFxyXG4gIGFtb3VudD86IG51bWJlciB8IG51bGxcclxuICBjdXJyZW5jeT86IHN0cmluZyB8IG51bGxcclxuICBzdGFnZV9pZDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFN0YWdlID0geyAvLyBFeHBvcnRlZFxyXG4gIGlkOiBzdHJpbmdcclxuICBuYW1lOiBzdHJpbmdcclxuICBvcmRlcl9pbmRleDogbnVtYmVyXHJcbiAgcHJvYmFiaWxpdHk6IG51bWJlciB8IG51bGxcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQWN0aXZpdHkgPSBUYWJsZXM8J2FjdGl2aXRpZXMnPiAvLyBFeHBvcnRlZFxyXG5leHBvcnQgdHlwZSBEZWFsID0gVGFibGVzPCdkZWFscyc+IC8vIEV4cG9ydGVkXHJcbmV4cG9ydCB0eXBlIENvbnRhY3QgPSBUYWJsZXM8J2NvbnRhY3RzJz4gLy8gRXhwb3J0ZWRcclxuXHJcbmNvbnN0IFNVUEFCQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTFxyXG5jb25zdCBTVVBBQkFTRV9BTk9OX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZXHJcblxyXG5mdW5jdGlvbiBnZXRDbGllbnQoKSB7XHJcbiAgaWYgKCFTVVBBQkFTRV9VUkwgfHwgIVNVUEFCQVNFX0FOT05fS0VZKSByZXR1cm4gbnVsbFxyXG4gIHJldHVybiBjcmVhdGVDbGllbnQ8RGF0YWJhc2U+KFNVUEFCQVNFX1VSTCwgU1VQQUJBU0VfQU5PTl9LRVksIHtcclxuICAgIGF1dGg6IHtcclxuICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuLy8gTW9jayBmYWxsYmFjayBmb3IgZGV2IHdpdGhvdXQgZW52IGNvbmZpZ3VyZWRcclxuY29uc3QgbW9jayA9IHtcclxuICBzdGFnZXM6IFtcclxuICAgIHsgaWQ6ICdzMScsIG5hbWU6ICdOZXcnLCBvcmRlcl9pbmRleDogMTAsIHByb2JhYmlsaXR5OiAxMCB9LFxyXG4gICAgeyBpZDogJ3MyJywgbmFtZTogJ0NvbnRhY3RlZCcsIG9yZGVyX2luZGV4OiAyMCwgcHJvYmFiaWxpdHk6IDI1IH0sXHJcbiAgICB7IGlkOiAnczMnLCBuYW1lOiAnUXVhbGlmaWVkJywgb3JkZXJfaW5kZXg6IDMwLCBwcm9iYWJpbGl0eTogNDUgfVxyXG4gIF0gYXMgU3RhZ2VbXSxcclxuICBkZWFsc0J5U3RhZ2U6IHtcclxuICAgIHMxOiBbeyBpZDogJ2QxJywgdGl0bGU6ICdBY21lIC0gUGlsb3QnLCBzdGFnZV9pZDogJ3MxJywgYW1vdW50OiAyNTAwLCBjdXJyZW5jeTogJ1VTRCcgfV0sXHJcbiAgICBzMjogW10sXHJcbiAgICBzMzogW11cclxuICB9IGFzIFJlY29yZDxzdHJpbmcsIERlYWxDYXJkW10+LFxyXG4gIGFjdGl2aXRpZXM6IFtcclxuICAgIHsgaWQ6ICdhMScsIHR5cGU6ICdzeXN0ZW0nLCByZWxhdGVkX3R5cGU6ICdkZWFsJywgcmVsYXRlZF9pZDogJ2QxJywgY29udGVudDogJ1NlZWQ6IGRlYWwgY3JlYXRlZCcsIG1ldGFfanNvbjogbnVsbCwgY3JlYXRlZF9ieTogbnVsbCwgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cclxuICBdIGFzIEFjdGl2aXR5W10sXHJcbiAgY29udGFjdDoge1xyXG4gICAgaWQ6ICdjMScsIGVtYWlsOiAnam9obkBhY21lLmNvbScsIGZ1bGxfbmFtZTogJ0pvaG4gRG9lJywgdGl0bGU6ICdWUCBTYWxlcycsXHJcbiAgICBsaW5rZWRpbl91cmw6ICdodHRwczovL2xpbmtlZGluLmNvbS9pbi9qb2huZG9lJywgd2Vic2l0ZTogJ2h0dHBzOi8vYWNtZS5jb20nLFxyXG4gICAgcGhvbmU6IG51bGwsIGNvbXBhbnlfaWQ6IG51bGwsIG93bmVyX2lkOiBudWxsLCBsaWZlY3ljbGVfc3RhZ2U6ICdsZWFkJyxcclxuICAgIHJlcGx5X3N0YXR1czogbnVsbCwgcmVwbHlfc3VtbWFyeTogbnVsbCwgZ2VuZXJhdGVkX2JvZHlfc3RlcDE6IG51bGwsIGdlbmVyYXRlZF9ib2R5X3N0ZXAyOiBudWxsLCBnZW5lcmF0ZWRfYm9keV9zdGVwMzogbnVsbCxcclxuICAgIGxhdGVzdF9lbWFpbF9zZW50X2F0OiBudWxsLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gIH0gYXMgQ29udGFjdFxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGlwZWxpbmVTdGFnZXMocGlwZWxpbmVJZD86IHN0cmluZyk6IFByb21pc2U8U3RhZ2VbXT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gbW9jay5zdGFnZXNcclxuXHJcbiAgLy8gZGVmYXVsdCBwaXBlbGluZSByZXNvbHZlXHJcbiAgY29uc3QgcGlwZWxpbmUgPSAocGlwZWxpbmVJZCAmJiBwaXBlbGluZUlkICE9PSAncF9kZWZhdWx0JylcclxuICAgID8geyBpZDogcGlwZWxpbmVJZCB9XHJcbiAgICA6IGF3YWl0IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncGlwZWxpbmVzJykuc2VsZWN0KCdpZCcpLmVxKCdpc19kZWZhdWx0JywgdHJ1ZSkub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KS5saW1pdCgxKS5tYXliZVNpbmdsZSgpXHJcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICAgIHJldHVybiBkYXRhXHJcbiAgICAgIH0pKClcclxuXHJcbiAgaWYgKCFwaXBlbGluZT8uaWQpIHJldHVybiBbXVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oJ3BpcGVsaW5lX3N0YWdlcycpXHJcbiAgICAuc2VsZWN0KCdpZCxuYW1lLG9yZGVyX2luZGV4LHByb2JhYmlsaXR5JylcclxuICAgIC5lcSgncGlwZWxpbmVfaWQnLCBwaXBlbGluZS5pZClcclxuICAgIC5vcmRlcignb3JkZXJfaW5kZXgnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG5cclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhID8/IFtdKSBhcyBTdGFnZVtdXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsc0J5UGlwZWxpbmUocGlwZWxpbmVJZD86IHN0cmluZyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgRGVhbENhcmRbXT4+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpXHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suZGVhbHNCeVN0YWdlXHJcblxyXG4gIC8vIHJlc29sdmUgcGlwZWxpbmUgaWRcclxuICBsZXQgcGlkID0gcGlwZWxpbmVJZFxyXG4gIGlmICghcGlkKSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwaXBlbGluZXMnKS5zZWxlY3QoJ2lkJykuZXEoJ2lzX2RlZmF1bHQnLCB0cnVlKS5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pLmxpbWl0KDEpLm1heWJlU2luZ2xlKClcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICAgIHBpZCA9IChkYXRhIGFzIHsgaWQ6IHN0cmluZyB9IHwgbnVsbCk/LmlkXHJcbiAgfVxyXG4gIGlmICghcGlkKSByZXR1cm4ge31cclxuXHJcbiAgLy8gZmV0Y2ggZGVhbHMgKyBqb2luIG5hbWVzXHJcbiAgY29uc3QgeyBkYXRhOiBkZWFscywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgnZGVhbHMnKVxyXG4gICAgLnNlbGVjdCgnaWQsdGl0bGUsYW1vdW50LGN1cnJlbmN5LHN0YWdlX2lkLGNvbXBhbnlfaWQsY29udGFjdF9pZCcpXHJcbiAgICAuZXEoJ3BpcGVsaW5lX2lkJywgcGlkKVxyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgLy8gZmV0Y2ggcmVsYXRlZCBuYW1lcyBpbiBvbmUgZ29cclxuICBjb25zdCBjb21wYW55SWRzID0gQXJyYXkuZnJvbShuZXcgU2V0KChkZWFscyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGQuY29tcGFueV9pZCkuZmlsdGVyKEJvb2xlYW4pKSkgYXMgc3RyaW5nW11cclxuICBjb25zdCBjb250YWN0SWRzID0gQXJyYXkuZnJvbShuZXcgU2V0KChkZWFscyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGQuY29udGFjdF9pZCkuZmlsdGVyKEJvb2xlYW4pKSkgYXMgc3RyaW5nW11cclxuXHJcbiAgY29uc3QgW2NvbXBhbmllc1JlcywgY29udGFjdHNSZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgY29tcGFueUlkcy5sZW5ndGggPyBzdXBhYmFzZS5mcm9tKCdjb21wYW5pZXMnKS5zZWxlY3QoJ2lkLG5hbWUnKS5pbignaWQnLCBjb21wYW55SWRzKSA6IFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IFtdIGFzIHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1bXSwgZXJyb3I6IG51bGwgfSksXHJcbiAgICBjb250YWN0SWRzLmxlbmd0aCA/IHN1cGFiYXNlLmZyb20oJ2NvbnRhY3RzJykuc2VsZWN0KCdpZCxmdWxsX25hbWUnKS5pbignaWQnLCBjb250YWN0SWRzKSA6IFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IFtdIGFzIHsgaWQ6IHN0cmluZzsgZnVsbF9uYW1lOiBzdHJpbmcgfCBudWxsIH1bXSwgZXJyb3I6IG51bGwgfSlcclxuICBdKVxyXG5cclxuICBpZiAoY29tcGFuaWVzUmVzLmVycm9yKSB0aHJvdyBjb21wYW5pZXNSZXMuZXJyb3JcclxuICBpZiAoY29udGFjdHNSZXMuZXJyb3IpIHRocm93IGNvbnRhY3RzUmVzLmVycm9yXHJcblxyXG4gIGNvbnN0IGNvbXBhbnlNYXAgPSBuZXcgTWFwKChjb21wYW5pZXNSZXMuZGF0YSA/PyBbXSkubWFwKChjOiB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9KSA9PiBbYy5pZCwgYy5uYW1lXSkpXHJcbiAgY29uc3QgY29udGFjdE1hcCA9IG5ldyBNYXAoKGNvbnRhY3RzUmVzLmRhdGEgPz8gW10pLm1hcCgoYzogeyBpZDogc3RyaW5nOyBmdWxsX25hbWU6IHN0cmluZyB8IG51bGwgfSkgPT4gW2MuaWQsIGMuZnVsbF9uYW1lXSkpXHJcblxyXG4gIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxzdHJpbmcsIERlYWxDYXJkW10+ID0ge31cclxuICBmb3IgKGNvbnN0IGQgb2YgKGRlYWxzID8/IFtdKSBhcyBBcnJheTx7XHJcbiAgICBpZDogc3RyaW5nOyB0aXRsZTogc3RyaW5nOyBhbW91bnQ6IG51bWJlciB8IG51bGw7IGN1cnJlbmN5OiBzdHJpbmcgfCBudWxsOyBzdGFnZV9pZDogc3RyaW5nOyBjb21wYW55X2lkOiBzdHJpbmcgfCBudWxsOyBjb250YWN0X2lkOiBzdHJpbmcgfCBudWxsO1xyXG4gIH0+KSB7XHJcbiAgICBjb25zdCBjYXJkOiBEZWFsQ2FyZCA9IHtcclxuICAgICAgaWQ6IGQuaWQsXHJcbiAgICAgIHRpdGxlOiBkLnRpdGxlLFxyXG4gICAgICBhbW91bnQ6IGQuYW1vdW50ID8/IG51bGwsXHJcbiAgICAgIGN1cnJlbmN5OiBkLmN1cnJlbmN5ID8/IG51bGwsXHJcbiAgICAgIHN0YWdlX2lkOiBkLnN0YWdlX2lkLFxyXG4gICAgICBjb21wYW55OiBkLmNvbXBhbnlfaWQgPyAoY29tcGFueU1hcC5nZXQoZC5jb21wYW55X2lkKSA/PyBudWxsKSA6IG51bGwsXHJcbiAgICAgIGNvbnRhY3Q6IGQuY29udGFjdF9pZCA/IChjb250YWN0TWFwLmdldChkLmNvbnRhY3RfaWQpID8/IG51bGwpIDogbnVsbFxyXG4gICAgfVxyXG4gICAgaWYgKCFncm91cGVkW2Quc3RhZ2VfaWRdKSBncm91cGVkW2Quc3RhZ2VfaWRdID0gW11cclxuICAgIGdyb3VwZWRbZC5zdGFnZV9pZF0ucHVzaChjYXJkKVxyXG4gIH1cclxuICByZXR1cm4gZ3JvdXBlZFxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbERldGFpbChpZDogc3RyaW5nKTogUHJvbWlzZTxEZWFsIHwgbnVsbD4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSB7XHJcbiAgICBjb25zdCBhbnlEZWFsID0gKE9iamVjdC52YWx1ZXMobW9jay5kZWFsc0J5U3RhZ2UpLmZsYXQoKVswXSBhcyBEZWFsQ2FyZCB8IHVuZGVmaW5lZClcclxuICAgIGlmICghYW55RGVhbCkgcmV0dXJuIG51bGxcclxuICAgIC8vIG1pbmltYWwgbW9jayBjYXN0XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogYW55RGVhbC5pZCxcclxuICAgICAgdGl0bGU6IGFueURlYWwudGl0bGUsXHJcbiAgICAgIGFtb3VudDogYW55RGVhbC5hbW91bnQgPz8gbnVsbCxcclxuICAgICAgY3VycmVuY3k6IGFueURlYWwuY3VycmVuY3kgPz8gbnVsbCxcclxuICAgICAgY29tcGFueV9pZDogbnVsbCxcclxuICAgICAgY29udGFjdF9pZDogbnVsbCxcclxuICAgICAgcGlwZWxpbmVfaWQ6ICdkZWZhdWx0JyxcclxuICAgICAgc3RhZ2VfaWQ6IGFueURlYWwuc3RhZ2VfaWQsXHJcbiAgICAgIHN0YXR1czogJ29wZW4nLFxyXG4gICAgICBzb3VyY2U6ICdpbmJvdW5kJyxcclxuICAgICAgbm90ZXM6ICdNb2NrJyxcclxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIGNsb3NlX2RhdGU6IG51bGxcclxuICAgIH0gYXMgdW5rbm93biBhcyBEZWFsXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdkZWFscycpLnNlbGVjdCgnKicpLmVxKCdpZCcsIGlkKS5tYXliZVNpbmdsZSgpXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gIHJldHVybiAoZGF0YSBhcyBEZWFsIHwgbnVsbClcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2aXRpZXNGb3IocmVsYXRlZFR5cGU6ICdkZWFsJ3wnY29udGFjdCd8J2NvbXBhbnknLCByZWxhdGVkSWQ6IHN0cmluZyk6IFByb21pc2U8QWN0aXZpdHlbXT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gbW9jay5hY3Rpdml0aWVzXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgnYWN0aXZpdGllcycpXHJcbiAgICAuc2VsZWN0KCcqJylcclxuICAgIC5lcSgncmVsYXRlZF90eXBlJywgcmVsYXRlZFR5cGUpXHJcbiAgICAuZXEoJ3JlbGF0ZWRfaWQnLCByZWxhdGVkSWQpXHJcbiAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhID8/IFtdKSBhcyBBY3Rpdml0eVtdXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3QgfCBudWxsPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLmNvbnRhY3RcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdjb250YWN0cycpLnNlbGVjdCgnKicpLmVxKCdpZCcsIGlkKS5tYXliZVNpbmdsZSgpXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gIHJldHVybiAoZGF0YSBhcyBDb250YWN0IHwgbnVsbClcclxufVxyXG5cclxuLy8gQWRkZWQgdG8gcmVzb2x2ZSBhIGJ1aWxkIGVycm9yIHdoZXJlICdnZXRDb250YWN0Rm9yRGVhbCcgd2FzIHJlcG9ydGVkIGFzIG1pc3NpbmcsXHJcbi8vIGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGV4cGxpY2l0bHkgaW1wb3J0ZWQgaW4gdGhlIHJlbGV2YW50IGZpbGVzLlxyXG4vLyBJdCBzaW1wbHkgZGVsZWdhdGVzIHRvIGdldENvbnRhY3QsIGFzIHRoYXQncyB0aGUgaW50ZW5kZWQgbG9naWMuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0Rm9yRGVhbChjb250YWN0SWQ6IHN0cmluZyk6IFByb21pc2U8Q29udGFjdCB8IG51bGw+IHtcclxuICByZXR1cm4gZ2V0Q29udGFjdChjb250YWN0SWQpO1xyXG59XHJcblxyXG4vLyBBZGRlZCB0byByZXNvbHZlIGEgYnVpbGQgZXJyb3Igd2hlcmUgJ2dldFN0YWdlTmFtZScgd2FzIHJlcG9ydGVkIGFzIG1pc3NpbmcuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZU5hbWUoc3RhZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpO1xyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLnN0YWdlcy5maW5kKHMgPT4gcy5pZCA9PT0gc3RhZ2VJZCk/Lm5hbWU7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncGlwZWxpbmVfc3RhZ2VzJykuc2VsZWN0KCduYW1lJykuZXEoJ2lkJywgc3RhZ2VJZCkubWF5YmVTaW5nbGUoKTtcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIHJldHVybiBkYXRhPy5uYW1lO1xyXG59XHJcblxyXG4vLyBBY3Rpb25zICh3cml0ZSkg4oCUIHByb3RlY3RlZCBieSBSTFM7IGV4cGVjdCBKV1QgaW4gZnJvbnRlbmQgY29udGV4dC5cclxuLy8gRm9yIFNTUi9FZGdlIHNlY3VyZSB3cml0ZXMsIHByZWZlciBzZXJ2ZXItb25seSBrZXkgb3IgZWRnZSBmdW5jdGlvbiBwcm94eS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURlYWxTdGFnZShkZWFsSWQ6IHN0cmluZywgbmV4dFN0YWdlSWQ6IHN0cmluZyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4geyBvazogdHJ1ZSB9XHJcblxyXG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2RlYWxzJykudXBkYXRlKHsgc3RhZ2VfaWQ6IG5leHRTdGFnZUlkIH0pLmVxKCdpZCcsIGRlYWxJZClcclxuICBpZiAoZXJyb3IpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxyXG4gIHJldHVybiB7IG9rOiB0cnVlIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhY3RTdGF0dXMoY29udGFjdElkOiBzdHJpbmcsIHN0YXR1czogJ2ludGVyZXN0ZWQnIHwgJ25vdF9pbnRlcmVzdGVkJyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxuXHJcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgnY29udGFjdHMnKS51cGRhdGUoeyByZXBseV9zdGF0dXM6IHN0YXR1cyB9KS5lcSgnaWQnLCBjb250YWN0SWQpO1xyXG4gIGlmIChlcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xyXG4gIHJldHVybiB7IG9rOiB0cnVlIH07XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxlbmRhckxpbmsoY29udGFjdElkOiBzdHJpbmcpOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IHVybD86IHN0cmluZzsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIC8vIFRoaXMgaXMgYSBtb2NrIGltcGxlbWVudGF0aW9uLiBJbiBhIHJlYWwgYXBwLCB5b3UnZCBnZW5lcmF0ZSBhIHVuaXF1ZSBsaW5rXHJcbiAgLy8gb3IgZmV0Y2ggaXQgZnJvbSBhIGNhbGVuZGFyIHNlcnZpY2UuXHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIHVybDogYGh0dHBzOi8vY2FsLmNvbS95b3VyLXVzZXJuYW1lLyR7Y29udGFjdElkfWAgfTtcclxufVxyXG5cclxuLy8gSGVscGVyIHRvIGRldGVjdCBlbnYgcHJlc2VuY2VcclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwYWJhc2VDb25maWd1cmVkKCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBCb29sZWFuKFNVUEFCQVNFX1VSTCAmJiBTVVBBQkFTRV9BTk9OX0tFWSlcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9wZW5EZWFsc0NvdW50KHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIDQyOyAvLyBNb2NrIGRhdGFcclxuXHJcbiAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UuZnJvbSgnZGVhbHMnKS5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JyB9KS5lcSgnc3RhdHVzJywgJ29wZW4nKTtcclxuICBpZiAocGlwZWxpbmVJZCkge1xyXG4gICAgcXVlcnkgPSBxdWVyeS5lcSgncGlwZWxpbmVfaWQnLCBwaXBlbGluZUlkKTtcclxuICB9XHJcbiAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgcmV0dXJuIGNvdW50ID8/IDA7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMYXN0N0RheXNSZXBseUNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKTtcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gMTU7IC8vIE1vY2sgZGF0YVxyXG5cclxuICBjb25zdCBzZXZlbkRheXNBZ28gPSBuZXcgRGF0ZSgpO1xyXG4gIHNldmVuRGF5c0Fnby5zZXREYXRlKHNldmVuRGF5c0Fnby5nZXREYXRlKCkgLSA3KTtcclxuXHJcbiAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgnY29udGFjdHMnKVxyXG4gICAgLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnIH0pXHJcbiAgICAubm90KCdyZXBseV9zdGF0dXMnLCAnaXMnLCBudWxsKVxyXG4gICAgLmd0ZSgndXBkYXRlZF9hdCcsIHNldmVuRGF5c0Fnby50b0lTT1N0cmluZygpKTsgLy8gQXNzdW1pbmcgdXBkYXRlZF9hdCByZWZsZWN0cyByZXBseSBzdGF0dXMgY2hhbmdlc1xyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgcmV0dXJuIGNvdW50ID8/IDA7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQaXBlbGluZUNvbnZlcnNpb24ocGlwZWxpbmVJZD86IHN0cmluZyk6IFByb21pc2U8UGlwZWxpbmVDb252ZXJzaW9uW10+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpO1xyXG4gIGlmICghc3VwYWJhc2UpIHtcclxuICAgIHJldHVybiBbIC8vIE1vY2sgZGF0YVxyXG4gICAgICB7IHN0YWdlX2lkOiAnczEnLCBzdGFnZV9uYW1lOiAnTmV3JywgY291bnQ6IDEwLCBjb252ZXJzaW9uX3RvX25leHQ6IDUwIH0sXHJcbiAgICAgIHsgc3RhZ2VfaWQ6ICdzMicsIHN0YWdlX25hbWU6ICdDb250YWN0ZWQnLCBjb3VudDogNSwgY29udmVyc2lvbl90b19uZXh0OiA4MCB9LFxyXG4gICAgICB7IHN0YWdlX2lkOiAnczMnLCBzdGFnZV9uYW1lOiAnUXVhbGlmaWVkJywgY291bnQ6IDQsIGNvbnZlcnNpb25fdG9fbmV4dDogdW5kZWZpbmVkIH0sXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgbW9jayBmb3IgY29udmVyc2lvbi4gQSByZWFsIGltcGxlbWVudGF0aW9uIHdvdWxkIGludm9sdmVcclxuICAvLyBtb3JlIGNvbXBsZXggU1FMIHF1ZXJpZXMgb3IgYSBtYXRlcmlhbGl6ZWQgdmlldyB0byBjYWxjdWxhdGUgY29udmVyc2lvbnMgYmV0d2VlbiBzdGFnZXMuXHJcbiAgY29uc3Qgc3RhZ2VzID0gYXdhaXQgZ2V0UGlwZWxpbmVTdGFnZXMocGlwZWxpbmVJZCk7XHJcbiAgY29uc3QgZGVhbHNCeVN0YWdlID0gYXdhaXQgZ2V0RGVhbHNCeVBpcGVsaW5lKHBpcGVsaW5lSWQpO1xyXG5cclxuICBjb25zdCBzdGFnZUNvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gIGZvciAoY29uc3Qgc3RhZ2Ugb2Ygc3RhZ2VzKSB7XHJcbiAgICBzdGFnZUNvdW50c1tzdGFnZS5pZF0gPSBkZWFsc0J5U3RhZ2Vbc3RhZ2UuaWRdPy5sZW5ndGggfHwgMDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbnZlcnNpb25EYXRhOiBQaXBlbGluZUNvbnZlcnNpb25bXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjdXJyZW50U3RhZ2UgPSBzdGFnZXNbaV07XHJcbiAgICBjb25zdCBjdXJyZW50Q291bnQgPSBzdGFnZUNvdW50c1tjdXJyZW50U3RhZ2UuaWRdO1xyXG4gICAgbGV0IGNvbnZlcnNpb25Ub05leHQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoaSA8IHN0YWdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGNvbnN0IG5leHRTdGFnZSA9IHN0YWdlc1tpICsgMV07XHJcbiAgICAgIGNvbnN0IG5leHRDb3VudCA9IHN0YWdlQ291bnRzW25leHRTdGFnZS5pZF07XHJcbiAgICAgIGlmIChjdXJyZW50Q291bnQgPiAwKSB7XHJcbiAgICAgICAgY29udmVyc2lvblRvTmV4dCA9IE1hdGgucm91bmQoKG5leHRDb3VudCAvIGN1cnJlbnRDb3VudCkgKiAxMDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29udmVyc2lvbkRhdGEucHVzaCh7XHJcbiAgICAgIHN0YWdlX2lkOiBjdXJyZW50U3RhZ2UuaWQsXHJcbiAgICAgIHN0YWdlX25hbWU6IGN1cnJlbnRTdGFnZS5uYW1lLFxyXG4gICAgICBjb3VudDogY3VycmVudENvdW50LFxyXG4gICAgICBjb252ZXJzaW9uX3RvX25leHQ6IGNvbnZlcnNpb25Ub05leHQsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb252ZXJzaW9uRGF0YTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUGlwZWxpbmVDb252ZXJzaW9uID0ge1xyXG4gIHN0YWdlX2lkOiBzdHJpbmc7XHJcbiAgc3RhZ2VfbmFtZTogc3RyaW5nO1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgY29udmVyc2lvbl90b19uZXh0PzogbnVtYmVyO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiU1VQQUJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIlNVUEFCQVNFX0FOT05fS0VZIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRDbGllbnQiLCJhdXRoIiwicGVyc2lzdFNlc3Npb24iLCJtb2NrIiwic3RhZ2VzIiwiaWQiLCJuYW1lIiwib3JkZXJfaW5kZXgiLCJwcm9iYWJpbGl0eSIsImRlYWxzQnlTdGFnZSIsInMxIiwidGl0bGUiLCJzdGFnZV9pZCIsImFtb3VudCIsImN1cnJlbmN5IiwiczIiLCJzMyIsImFjdGl2aXRpZXMiLCJ0eXBlIiwicmVsYXRlZF90eXBlIiwicmVsYXRlZF9pZCIsImNvbnRlbnQiLCJtZXRhX2pzb24iLCJjcmVhdGVkX2J5IiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbnRhY3QiLCJlbWFpbCIsImZ1bGxfbmFtZSIsImxpbmtlZGluX3VybCIsIndlYnNpdGUiLCJwaG9uZSIsImNvbXBhbnlfaWQiLCJvd25lcl9pZCIsImxpZmVjeWNsZV9zdGFnZSIsInJlcGx5X3N0YXR1cyIsInJlcGx5X3N1bW1hcnkiLCJnZW5lcmF0ZWRfYm9keV9zdGVwMSIsImdlbmVyYXRlZF9ib2R5X3N0ZXAyIiwiZ2VuZXJhdGVkX2JvZHlfc3RlcDMiLCJsYXRlc3RfZW1haWxfc2VudF9hdCIsInVwZGF0ZWRfYXQiLCJnZXRQaXBlbGluZVN0YWdlcyIsInBpcGVsaW5lSWQiLCJzdXBhYmFzZSIsInBpcGVsaW5lIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJsaW1pdCIsIm1heWJlU2luZ2xlIiwiZ2V0RGVhbHNCeVBpcGVsaW5lIiwicGlkIiwiZGVhbHMiLCJjb21wYW55SWRzIiwiQXJyYXkiLCJTZXQiLCJtYXAiLCJkIiwiZmlsdGVyIiwiQm9vbGVhbiIsImNvbnRhY3RJZHMiLCJjb250YWN0X2lkIiwiY29tcGFuaWVzUmVzIiwiY29udGFjdHNSZXMiLCJQcm9taXNlIiwiYWxsIiwibGVuZ3RoIiwiaW4iLCJyZXNvbHZlIiwiY29tcGFueU1hcCIsIk1hcCIsImMiLCJjb250YWN0TWFwIiwiZ3JvdXBlZCIsImNhcmQiLCJjb21wYW55IiwiZ2V0IiwicHVzaCIsImdldERlYWxEZXRhaWwiLCJhbnlEZWFsIiwiT2JqZWN0IiwidmFsdWVzIiwiZmxhdCIsInBpcGVsaW5lX2lkIiwic3RhdHVzIiwic291cmNlIiwibm90ZXMiLCJjbG9zZV9kYXRlIiwiZ2V0QWN0aXZpdGllc0ZvciIsInJlbGF0ZWRUeXBlIiwicmVsYXRlZElkIiwiZ2V0Q29udGFjdCIsImdldENvbnRhY3RGb3JEZWFsIiwiY29udGFjdElkIiwiZ2V0U3RhZ2VOYW1lIiwic3RhZ2VJZCIsImZpbmQiLCJzIiwidXBkYXRlRGVhbFN0YWdlIiwiZGVhbElkIiwibmV4dFN0YWdlSWQiLCJvayIsInVwZGF0ZSIsIm1lc3NhZ2UiLCJ1cGRhdGVDb250YWN0U3RhdHVzIiwiZ2V0Q2FsZW5kYXJMaW5rIiwidXJsIiwiaXNTdXBhYmFzZUNvbmZpZ3VyZWQiLCJnZXRPcGVuRGVhbHNDb3VudCIsInF1ZXJ5IiwiY291bnQiLCJnZXRMYXN0N0RheXNSZXBseUNvdW50Iiwic2V2ZW5EYXlzQWdvIiwic2V0RGF0ZSIsImdldERhdGUiLCJub3QiLCJndGUiLCJnZXRQaXBlbGluZUNvbnZlcnNpb24iLCJzdGFnZV9uYW1lIiwiY29udmVyc2lvbl90b19uZXh0IiwidW5kZWZpbmVkIiwic3RhZ2VDb3VudHMiLCJzdGFnZSIsImNvbnZlcnNpb25EYXRhIiwiaSIsImN1cnJlbnRTdGFnZSIsImN1cnJlbnRDb3VudCIsImNvbnZlcnNpb25Ub05leHQiLCJuZXh0U3RhZ2UiLCJuZXh0Q291bnQiLCJNYXRoIiwicm91bmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});