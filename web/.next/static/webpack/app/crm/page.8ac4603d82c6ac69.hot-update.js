"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   isSupabaseConfigured: function() { return /* binding */ isSupabaseConfigured; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// Supabase-backed CRM API helpers (SSR/RLS friendly)\n// Falls back to mock when env is missing. Types from supabase.types.ts\n\n// Exported\nconst SUPABASE_URL = \"https://jkrxflynplzczpkzhygs.supabase.co\";\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImprcnhmbHlucGx6Y3pwa3poeWdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzNDczOTksImV4cCI6MjA2OTkyMzM5OX0.QYOOVOK4cI44IsSQz1MGdSQbUKJwI4frO-YdNv8hvpU\";\nfunction getClient() {\n    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) return null;\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            persistSession: false\n        }\n    });\n}\n// Mock fallback for dev without env configured\nconst mock = {\n    stages: [\n        {\n            id: \"s1\",\n            name: \"New\",\n            order_index: 10,\n            probability: 10\n        },\n        {\n            id: \"s2\",\n            name: \"Contacted\",\n            order_index: 20,\n            probability: 25\n        },\n        {\n            id: \"s3\",\n            name: \"Qualified\",\n            order_index: 30,\n            probability: 45\n        }\n    ],\n    dealsByStage: {\n        s1: [\n            {\n                id: \"d1\",\n                title: \"Acme - Pilot\",\n                stage_id: \"s1\",\n                amount: 2500,\n                currency: \"USD\"\n            }\n        ],\n        s2: [],\n        s3: []\n    },\n    activities: [\n        {\n            id: \"a1\",\n            type: \"system\",\n            related_type: \"deal\",\n            related_id: \"d1\",\n            content: \"Seed: deal created\",\n            meta_json: null,\n            created_by: null,\n            created_at: new Date().toISOString()\n        }\n    ],\n    contact: {\n        id: \"c1\",\n        email: \"john@acme.com\",\n        full_name: \"John Doe\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/johndoe\",\n        website: \"https://acme.com\",\n        phone: null,\n        company_id: null,\n        owner_id: null,\n        lifecycle_stage: \"lead\",\n        reply_status: null,\n        reply_summary: null,\n        generated_body_step1: null,\n        generated_body_step2: null,\n        generated_body_step3: null,\n        latest_email_sent_at: null,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    }\n};\nasync function getPipelineStages(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.stages;\n    // default pipeline resolve\n    const pipeline = pipelineId ? {\n        id: pipelineId\n    } : await (async ()=>{\n        const { data, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        return data;\n    })();\n    if (!(pipeline === null || pipeline === void 0 ? void 0 : pipeline.id)) return [];\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"id,name,order_index,probability\").eq(\"pipeline_id\", pipeline.id).order(\"order_index\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getDealsByPipeline(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.dealsByStage;\n    // resolve pipeline id\n    let pid = pipelineId;\n    if (!pid) {\n        const { data, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        pid = data === null || data === void 0 ? void 0 : data.id;\n    }\n    if (!pid) return {};\n    // fetch deals + join names\n    const { data: deals, error } = await supabase.from(\"deals\").select(\"id,title,amount,currency,stage_id,company_id,contact_id\").eq(\"pipeline_id\", pid);\n    if (error) throw error;\n    // fetch related names in one go\n    const companyIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.company_id).filter(Boolean)));\n    const contactIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.contact_id).filter(Boolean)));\n    const [companiesRes, contactsRes] = await Promise.all([\n        companyIds.length ? supabase.from(\"companies\").select(\"id,name\").in(\"id\", companyIds) : Promise.resolve({\n            data: [],\n            error: null\n        }),\n        contactIds.length ? supabase.from(\"contacts\").select(\"id,full_name\").in(\"id\", contactIds) : Promise.resolve({\n            data: [],\n            error: null\n        })\n    ]);\n    if (companiesRes.error) throw companiesRes.error;\n    if (contactsRes.error) throw contactsRes.error;\n    var _companiesRes_data;\n    const companyMap = new Map(((_companiesRes_data = companiesRes.data) !== null && _companiesRes_data !== void 0 ? _companiesRes_data : []).map((c)=>[\n            c.id,\n            c.name\n        ]));\n    var _contactsRes_data;\n    const contactMap = new Map(((_contactsRes_data = contactsRes.data) !== null && _contactsRes_data !== void 0 ? _contactsRes_data : []).map((c)=>[\n            c.id,\n            c.full_name\n        ]));\n    const grouped = {};\n    for (const d of deals !== null && deals !== void 0 ? deals : []){\n        var _d_amount, _d_currency, _companyMap_get, _contactMap_get;\n        const card = {\n            id: d.id,\n            title: d.title,\n            amount: (_d_amount = d.amount) !== null && _d_amount !== void 0 ? _d_amount : null,\n            currency: (_d_currency = d.currency) !== null && _d_currency !== void 0 ? _d_currency : null,\n            stage_id: d.stage_id,\n            company: d.company_id ? (_companyMap_get = companyMap.get(d.company_id)) !== null && _companyMap_get !== void 0 ? _companyMap_get : null : null,\n            contact: d.contact_id ? (_contactMap_get = contactMap.get(d.contact_id)) !== null && _contactMap_get !== void 0 ? _contactMap_get : null : null\n        };\n        if (!grouped[d.stage_id]) grouped[d.stage_id] = [];\n        grouped[d.stage_id].push(card);\n    }\n    return grouped;\n}\nasync function getDealDetail(id) {\n    const supabase = getClient();\n    if (!supabase) {\n        const anyDeal = Object.values(mock.dealsByStage).flat()[0];\n        if (!anyDeal) return null;\n        var _anyDeal_amount, _anyDeal_currency;\n        // minimal mock cast\n        return {\n            id: anyDeal.id,\n            title: anyDeal.title,\n            amount: (_anyDeal_amount = anyDeal.amount) !== null && _anyDeal_amount !== void 0 ? _anyDeal_amount : null,\n            currency: (_anyDeal_currency = anyDeal.currency) !== null && _anyDeal_currency !== void 0 ? _anyDeal_currency : null,\n            company_id: null,\n            contact_id: null,\n            pipeline_id: \"default\",\n            stage_id: anyDeal.stage_id,\n            status: \"open\",\n            source: \"inbound\",\n            notes: \"Mock\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n            close_date: null\n        };\n    }\n    const { data, error } = await supabase.from(\"deals\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    const supabase = getClient();\n    if (!supabase) return mock.activities;\n    const { data, error } = await supabase.from(\"activities\").select(\"*\").eq(\"related_type\", relatedType).eq(\"related_id\", relatedId).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getContact(id) {\n    const supabase = getClient();\n    if (!supabase) return mock.contact;\n    const { data, error } = await supabase.from(\"contacts\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\n// Added to resolve a build error where 'getContactForDeal' was reported as missing,\n// even though it's not explicitly imported in the relevant files.\n// It simply delegates to getContact, as that's the intended logic.\nasync function getContactForDeal(contactId) {\n    return getContact(contactId);\n}\n// Added to resolve a build error where 'getStageName' was reported as missing.\nasync function getStageName(stageId) {\n    var _mock_stages_find;\n    const supabase = getClient();\n    if (!supabase) return (_mock_stages_find = mock.stages.find((s)=>s.id === stageId)) === null || _mock_stages_find === void 0 ? void 0 : _mock_stages_find.name;\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"name\").eq(\"id\", stageId).maybeSingle();\n    if (error) throw error;\n    return data === null || data === void 0 ? void 0 : data.name;\n}\n// Actions (write) â€” protected by RLS; expect JWT in frontend context.\n// For SSR/Edge secure writes, prefer server-only key or edge function proxy.\nasync function updateDealStage(dealId, nextStageId) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"deals\").update({\n        stage_id: nextStageId\n    }).eq(\"id\", dealId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function updateContactStatus(contactId, status) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"contacts\").update({\n        reply_status: status\n    }).eq(\"id\", contactId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function getCalendarLink(contactId) {\n    // This is a mock implementation. In a real app, you'd generate a unique link\n    // or fetch it from a calendar service.\n    return {\n        ok: true,\n        url: \"https://cal.com/your-username/\".concat(contactId)\n    };\n}\n// Helper to detect env presence\nfunction isSupabaseConfigured() {\n    return Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);\n}\nasync function getOpenDealsCount(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return 42; // Mock data\n    let query = supabase.from(\"deals\").select(\"id\", {\n        count: \"exact\"\n    }).eq(\"status\", \"open\");\n    if (pipelineId) {\n        query = query.eq(\"pipeline_id\", pipelineId);\n    }\n    const { count, error } = await query;\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getLast7DaysReplyCount() {\n    const supabase = getClient();\n    if (!supabase) return 15; // Mock data\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    const { count, error } = await supabase.from(\"contacts\").select(\"id\", {\n        count: \"exact\"\n    }).not(\"reply_status\", \"is\", null).gte(\"updated_at\", sevenDaysAgo.toISOString()); // Assuming updated_at reflects reply status changes\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getPipelineConversion(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) {\n        return [\n            {\n                stage_id: \"s1\",\n                stage_name: \"New\",\n                count: 10,\n                conversion_to_next: 50\n            },\n            {\n                stage_id: \"s2\",\n                stage_name: \"Contacted\",\n                count: 5,\n                conversion_to_next: 80\n            },\n            {\n                stage_id: \"s3\",\n                stage_name: \"Qualified\",\n                count: 4,\n                conversion_to_next: undefined\n            }\n        ];\n    }\n    // This is a simplified mock for conversion. A real implementation would involve\n    // more complex SQL queries or a materialized view to calculate conversions between stages.\n    const stages = await getPipelineStages(pipelineId);\n    const dealsByStage = await getDealsByPipeline(pipelineId);\n    const stageCounts = {};\n    for (const stage of stages){\n        var _dealsByStage_stage_id;\n        stageCounts[stage.id] = ((_dealsByStage_stage_id = dealsByStage[stage.id]) === null || _dealsByStage_stage_id === void 0 ? void 0 : _dealsByStage_stage_id.length) || 0;\n    }\n    const conversionData = [];\n    for(let i = 0; i < stages.length; i++){\n        const currentStage = stages[i];\n        const currentCount = stageCounts[currentStage.id];\n        let conversionToNext = undefined;\n        if (i < stages.length - 1) {\n            const nextStage = stages[i + 1];\n            const nextCount = stageCounts[nextStage.id];\n            if (currentCount > 0) {\n                conversionToNext = Math.round(nextCount / currentCount * 100);\n            }\n        }\n        conversionData.push({\n            stage_id: currentStage.id,\n            stage_name: currentStage.name,\n            count: currentCount,\n            conversion_to_next: conversionToNext\n        });\n    }\n    return conversionData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEO0FBQ3JELHVFQUF1RTtBQUVuQjtBQXNCWCxXQUFXO0FBRXBELE1BQU1DLGVBQWVDLDBDQUFvQztBQUN6RCxNQUFNRyxvQkFBb0JILGtOQUF5QztBQUVuRSxTQUFTSztJQUNQLElBQUksQ0FBQ04sZ0JBQWdCLENBQUNJLG1CQUFtQixPQUFPO0lBQ2hELE9BQU9MLG1FQUFZQSxDQUFXQyxjQUFjSSxtQkFBbUI7UUFDN0RHLE1BQU07WUFDSkMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBLCtDQUErQztBQUMvQyxNQUFNQyxPQUFPO0lBQ1hDLFFBQVE7UUFDTjtZQUFFQyxJQUFJO1lBQU1DLE1BQU07WUFBT0MsYUFBYTtZQUFJQyxhQUFhO1FBQUc7UUFDMUQ7WUFBRUgsSUFBSTtZQUFNQyxNQUFNO1lBQWFDLGFBQWE7WUFBSUMsYUFBYTtRQUFHO1FBQ2hFO1lBQUVILElBQUk7WUFBTUMsTUFBTTtZQUFhQyxhQUFhO1lBQUlDLGFBQWE7UUFBRztLQUNqRTtJQUNEQyxjQUFjO1FBQ1pDLElBQUk7WUFBQztnQkFBRUwsSUFBSTtnQkFBTU0sT0FBTztnQkFBZ0JDLFVBQVU7Z0JBQU1DLFFBQVE7Z0JBQU1DLFVBQVU7WUFBTTtTQUFFO1FBQ3hGQyxJQUFJLEVBQUU7UUFDTkMsSUFBSSxFQUFFO0lBQ1I7SUFDQUMsWUFBWTtRQUNWO1lBQUVaLElBQUk7WUFBTWEsTUFBTTtZQUFVQyxjQUFjO1lBQVFDLFlBQVk7WUFBTUMsU0FBUztZQUFzQkMsV0FBVztZQUFNQyxZQUFZO1lBQU1DLFlBQVksSUFBSUMsT0FBT0MsV0FBVztRQUFHO0tBQzVLO0lBQ0RDLFNBQVM7UUFDUHRCLElBQUk7UUFBTXVCLE9BQU87UUFBaUJDLFdBQVc7UUFBWWxCLE9BQU87UUFDaEVtQixjQUFjO1FBQW1DQyxTQUFTO1FBQzFEQyxPQUFPO1FB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WUFBWWxJLE1BQU0sQ0FBQzhILElBQUksRUFBRTtZQUMvQixNQUFNSyxZQUFZUixXQUFXLENBQUNPLFVBQVVqSSxFQUFFLENBQUM7WUFDM0MsSUFBSStILGVBQWUsR0FBRztnQkFDcEJDLG1CQUFtQkcsS0FBS0MsS0FBSyxDQUFDLFlBQWFMLGVBQWdCO1lBQzdEO1FBQ0Y7UUFFQUgsZUFBZTlDLElBQUksQ0FBQztZQUNsQnZFLFVBQVV1SCxhQUFhOUgsRUFBRTtZQUN6QnVILFlBQVlPLGFBQWE3SCxJQUFJO1lBQzdCOEcsT0FBT2dCO1lBQ1BQLG9CQUFvQlE7UUFDdEI7SUFDRjtJQUVBLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3NlcnZpY2VzL2NybUFwaS50cz84MWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFN1cGFiYXNlLWJhY2tlZCBDUk0gQVBJIGhlbHBlcnMgKFNTUi9STFMgZnJpZW5kbHkpXHJcbi8vIEZhbGxzIGJhY2sgdG8gbW9jayB3aGVuIGVudiBpcyBtaXNzaW5nLiBUeXBlcyBmcm9tIHN1cGFiYXNlLnR5cGVzLnRzXHJcblxyXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXHJcbmltcG9ydCB0eXBlIHsgRGF0YWJhc2UsIFRhYmxlcyB9IGZyb20gJy4vc3VwYWJhc2UudHlwZXMnXHJcblxyXG5leHBvcnQgdHlwZSBEZWFsQ2FyZCA9IHsgLy8gRXhwb3J0ZWRcclxuICBpZDogc3RyaW5nXHJcbiAgdGl0bGU6IHN0cmluZ1xyXG4gIGNvbXBhbnk/OiBzdHJpbmcgfCBudWxsXHJcbiAgY29udGFjdD86IHN0cmluZyB8IG51bGxcclxuICBhbW91bnQ/OiBudW1iZXIgfCBudWxsXHJcbiAgY3VycmVuY3k/OiBzdHJpbmcgfCBudWxsXHJcbiAgc3RhZ2VfaWQ6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGFnZSA9IHsgLy8gRXhwb3J0ZWRcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgb3JkZXJfaW5kZXg6IG51bWJlclxyXG4gIHByb2JhYmlsaXR5OiBudW1iZXIgfCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEFjdGl2aXR5ID0gVGFibGVzPCdhY3Rpdml0aWVzJz4gLy8gRXhwb3J0ZWRcclxuZXhwb3J0IHR5cGUgRGVhbCA9IFRhYmxlczwnZGVhbHMnPiAvLyBFeHBvcnRlZFxyXG5leHBvcnQgdHlwZSBDb250YWN0ID0gVGFibGVzPCdjb250YWN0cyc+IC8vIEV4cG9ydGVkXHJcblxyXG5jb25zdCBTVVBBQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkxcclxuY29uc3QgU1VQQUJBU0VfQU5PTl9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxyXG5cclxuZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xyXG4gIGlmICghU1VQQUJBU0VfVVJMIHx8ICFTVVBBQkFTRV9BTk9OX0tFWSkgcmV0dXJuIG51bGxcclxuICByZXR1cm4gY3JlYXRlQ2xpZW50PERhdGFiYXNlPihTVVBBQkFTRV9VUkwsIFNVUEFCQVNFX0FOT05fS0VZLCB7XHJcbiAgICBhdXRoOiB7XHJcbiAgICAgIHBlcnNpc3RTZXNzaW9uOiBmYWxzZVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbi8vIE1vY2sgZmFsbGJhY2sgZm9yIGRldiB3aXRob3V0IGVudiBjb25maWd1cmVkXHJcbmNvbnN0IG1vY2sgPSB7XHJcbiAgc3RhZ2VzOiBbXHJcbiAgICB7IGlkOiAnczEnLCBuYW1lOiAnTmV3Jywgb3JkZXJfaW5kZXg6IDEwLCBwcm9iYWJpbGl0eTogMTAgfSxcclxuICAgIHsgaWQ6ICdzMicsIG5hbWU6ICdDb250YWN0ZWQnLCBvcmRlcl9pbmRleDogMjAsIHByb2JhYmlsaXR5OiAyNSB9LFxyXG4gICAgeyBpZDogJ3MzJywgbmFtZTogJ1F1YWxpZmllZCcsIG9yZGVyX2luZGV4OiAzMCwgcHJvYmFiaWxpdHk6IDQ1IH1cclxuICBdIGFzIFN0YWdlW10sXHJcbiAgZGVhbHNCeVN0YWdlOiB7XHJcbiAgICBzMTogW3sgaWQ6ICdkMScsIHRpdGxlOiAnQWNtZSAtIFBpbG90Jywgc3RhZ2VfaWQ6ICdzMScsIGFtb3VudDogMjUwMCwgY3VycmVuY3k6ICdVU0QnIH1dLFxyXG4gICAgczI6IFtdLFxyXG4gICAgczM6IFtdXHJcbiAgfSBhcyBSZWNvcmQ8c3RyaW5nLCBEZWFsQ2FyZFtdPixcclxuICBhY3Rpdml0aWVzOiBbXHJcbiAgICB7IGlkOiAnYTEnLCB0eXBlOiAnc3lzdGVtJywgcmVsYXRlZF90eXBlOiAnZGVhbCcsIHJlbGF0ZWRfaWQ6ICdkMScsIGNvbnRlbnQ6ICdTZWVkOiBkZWFsIGNyZWF0ZWQnLCBtZXRhX2pzb246IG51bGwsIGNyZWF0ZWRfYnk6IG51bGwsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgXSBhcyBBY3Rpdml0eVtdLFxyXG4gIGNvbnRhY3Q6IHtcclxuICAgIGlkOiAnYzEnLCBlbWFpbDogJ2pvaG5AYWNtZS5jb20nLCBmdWxsX25hbWU6ICdKb2huIERvZScsIHRpdGxlOiAnVlAgU2FsZXMnLFxyXG4gICAgbGlua2VkaW5fdXJsOiAnaHR0cHM6Ly9saW5rZWRpbi5jb20vaW4vam9obmRvZScsIHdlYnNpdGU6ICdodHRwczovL2FjbWUuY29tJyxcclxuICAgIHBob25lOiBudWxsLCBjb21wYW55X2lkOiBudWxsLCBvd25lcl9pZDogbnVsbCwgbGlmZWN5Y2xlX3N0YWdlOiAnbGVhZCcsXHJcbiAgICByZXBseV9zdGF0dXM6IG51bGwsIHJlcGx5X3N1bW1hcnk6IG51bGwsIGdlbmVyYXRlZF9ib2R5X3N0ZXAxOiBudWxsLCBnZW5lcmF0ZWRfYm9keV9zdGVwMjogbnVsbCwgZ2VuZXJhdGVkX2JvZHlfc3RlcDM6IG51bGwsXHJcbiAgICBsYXRlc3RfZW1haWxfc2VudF9hdDogbnVsbCwgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICB9IGFzIENvbnRhY3RcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBpcGVsaW5lU3RhZ2VzKHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPFN0YWdlW10+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpXHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suc3RhZ2VzXHJcblxyXG4gIC8vIGRlZmF1bHQgcGlwZWxpbmUgcmVzb2x2ZVxyXG4gIGNvbnN0IHBpcGVsaW5lID0gcGlwZWxpbmVJZFxyXG4gICAgPyB7IGlkOiBwaXBlbGluZUlkIH1cclxuICAgIDogYXdhaXQgKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwaXBlbGluZXMnKS5zZWxlY3QoJ2lkJykuZXEoJ2lzX2RlZmF1bHQnLCB0cnVlKS5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pLmxpbWl0KDEpLm1heWJlU2luZ2xlKClcclxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICAgICAgcmV0dXJuIGRhdGFcclxuICAgICAgfSkoKVxyXG5cclxuICBpZiAoIXBpcGVsaW5lPy5pZCkgcmV0dXJuIFtdXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgncGlwZWxpbmVfc3RhZ2VzJylcclxuICAgIC5zZWxlY3QoJ2lkLG5hbWUsb3JkZXJfaW5kZXgscHJvYmFiaWxpdHknKVxyXG4gICAgLmVxKCdwaXBlbGluZV9pZCcsIHBpcGVsaW5lLmlkKVxyXG4gICAgLm9yZGVyKCdvcmRlcl9pbmRleCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXHJcblxyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICByZXR1cm4gKGRhdGEgPz8gW10pIGFzIFN0YWdlW11cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlYWxzQnlQaXBlbGluZShwaXBlbGluZUlkPzogc3RyaW5nKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBEZWFsQ2FyZFtdPj4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gbW9jay5kZWFsc0J5U3RhZ2VcclxuXHJcbiAgLy8gcmVzb2x2ZSBwaXBlbGluZSBpZFxyXG4gIGxldCBwaWQgPSBwaXBlbGluZUlkXHJcbiAgaWYgKCFwaWQpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3BpcGVsaW5lcycpLnNlbGVjdCgnaWQnKS5lcSgnaXNfZGVmYXVsdCcsIHRydWUpLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSkubGltaXQoMSkubWF5YmVTaW5nbGUoKVxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcGlkID0gKGRhdGEgYXMgeyBpZDogc3RyaW5nIH0gfCBudWxsKT8uaWRcclxuICB9XHJcbiAgaWYgKCFwaWQpIHJldHVybiB7fVxyXG5cclxuICAvLyBmZXRjaCBkZWFscyArIGpvaW4gbmFtZXNcclxuICBjb25zdCB7IGRhdGE6IGRlYWxzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdkZWFscycpXHJcbiAgICAuc2VsZWN0KCdpZCx0aXRsZSxhbW91bnQsY3VycmVuY3ksc3RhZ2VfaWQsY29tcGFueV9pZCxjb250YWN0X2lkJylcclxuICAgIC5lcSgncGlwZWxpbmVfaWQnLCBwaWQpXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG5cclxuICAvLyBmZXRjaCByZWxhdGVkIG5hbWVzIGluIG9uZSBnb1xyXG4gIGNvbnN0IGNvbXBhbnlJZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoKGRlYWxzID8/IFtdKS5tYXAoKGQ6IGFueSkgPT4gZC5jb21wYW55X2lkKS5maWx0ZXIoQm9vbGVhbikpKSBhcyBzdHJpbmdbXVxyXG4gIGNvbnN0IGNvbnRhY3RJZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoKGRlYWxzID8/IFtdKS5tYXAoKGQ6IGFueSkgPT4gZC5jb250YWN0X2lkKS5maWx0ZXIoQm9vbGVhbikpKSBhcyBzdHJpbmdbXVxyXG5cclxuICBjb25zdCBbY29tcGFuaWVzUmVzLCBjb250YWN0c1Jlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICBjb21wYW55SWRzLmxlbmd0aCA/IHN1cGFiYXNlLmZyb20oJ2NvbXBhbmllcycpLnNlbGVjdCgnaWQsbmFtZScpLmluKCdpZCcsIGNvbXBhbnlJZHMpIDogUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogW10gYXMgeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVtdLCBlcnJvcjogbnVsbCB9KSxcclxuICAgIGNvbnRhY3RJZHMubGVuZ3RoID8gc3VwYWJhc2UuZnJvbSgnY29udGFjdHMnKS5zZWxlY3QoJ2lkLGZ1bGxfbmFtZScpLmluKCdpZCcsIGNvbnRhY3RJZHMpIDogUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogW10gYXMgeyBpZDogc3RyaW5nOyBmdWxsX25hbWU6IHN0cmluZyB8IG51bGwgfVtdLCBlcnJvcjogbnVsbCB9KVxyXG4gIF0pXHJcblxyXG4gIGlmIChjb21wYW5pZXNSZXMuZXJyb3IpIHRocm93IGNvbXBhbmllc1Jlcy5lcnJvclxyXG4gIGlmIChjb250YWN0c1Jlcy5lcnJvcikgdGhyb3cgY29udGFjdHNSZXMuZXJyb3JcclxuXHJcbiAgY29uc3QgY29tcGFueU1hcCA9IG5ldyBNYXAoKGNvbXBhbmllc1Jlcy5kYXRhID8/IFtdKS5tYXAoKGM6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0pID0+IFtjLmlkLCBjLm5hbWVdKSlcclxuICBjb25zdCBjb250YWN0TWFwID0gbmV3IE1hcCgoY29udGFjdHNSZXMuZGF0YSA/PyBbXSkubWFwKChjOiB7IGlkOiBzdHJpbmc7IGZ1bGxfbmFtZTogc3RyaW5nIHwgbnVsbCB9KSA9PiBbYy5pZCwgYy5mdWxsX25hbWVdKSlcclxuXHJcbiAgY29uc3QgZ3JvdXBlZDogUmVjb3JkPHN0cmluZywgRGVhbENhcmRbXT4gPSB7fVxyXG4gIGZvciAoY29uc3QgZCBvZiAoZGVhbHMgPz8gW10pIGFzIEFycmF5PHtcclxuICAgIGlkOiBzdHJpbmc7IHRpdGxlOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyIHwgbnVsbDsgY3VycmVuY3k6IHN0cmluZyB8IG51bGw7IHN0YWdlX2lkOiBzdHJpbmc7IGNvbXBhbnlfaWQ6IHN0cmluZyB8IG51bGw7IGNvbnRhY3RfaWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgfT4pIHtcclxuICAgIGNvbnN0IGNhcmQ6IERlYWxDYXJkID0ge1xyXG4gICAgICBpZDogZC5pZCxcclxuICAgICAgdGl0bGU6IGQudGl0bGUsXHJcbiAgICAgIGFtb3VudDogZC5hbW91bnQgPz8gbnVsbCxcclxuICAgICAgY3VycmVuY3k6IGQuY3VycmVuY3kgPz8gbnVsbCxcclxuICAgICAgc3RhZ2VfaWQ6IGQuc3RhZ2VfaWQsXHJcbiAgICAgIGNvbXBhbnk6IGQuY29tcGFueV9pZCA/IChjb21wYW55TWFwLmdldChkLmNvbXBhbnlfaWQpID8/IG51bGwpIDogbnVsbCxcclxuICAgICAgY29udGFjdDogZC5jb250YWN0X2lkID8gKGNvbnRhY3RNYXAuZ2V0KGQuY29udGFjdF9pZCkgPz8gbnVsbCkgOiBudWxsXHJcbiAgICB9XHJcbiAgICBpZiAoIWdyb3VwZWRbZC5zdGFnZV9pZF0pIGdyb3VwZWRbZC5zdGFnZV9pZF0gPSBbXVxyXG4gICAgZ3JvdXBlZFtkLnN0YWdlX2lkXS5wdXNoKGNhcmQpXHJcbiAgfVxyXG4gIHJldHVybiBncm91cGVkXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsRGV0YWlsKGlkOiBzdHJpbmcpOiBQcm9taXNlPERlYWwgfCBudWxsPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHtcclxuICAgIGNvbnN0IGFueURlYWwgPSAoT2JqZWN0LnZhbHVlcyhtb2NrLmRlYWxzQnlTdGFnZSkuZmxhdCgpWzBdIGFzIERlYWxDYXJkIHwgdW5kZWZpbmVkKVxyXG4gICAgaWYgKCFhbnlEZWFsKSByZXR1cm4gbnVsbFxyXG4gICAgLy8gbWluaW1hbCBtb2NrIGNhc3RcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBhbnlEZWFsLmlkLFxyXG4gICAgICB0aXRsZTogYW55RGVhbC50aXRsZSxcclxuICAgICAgYW1vdW50OiBhbnlEZWFsLmFtb3VudCA/PyBudWxsLFxyXG4gICAgICBjdXJyZW5jeTogYW55RGVhbC5jdXJyZW5jeSA/PyBudWxsLFxyXG4gICAgICBjb21wYW55X2lkOiBudWxsLFxyXG4gICAgICBjb250YWN0X2lkOiBudWxsLFxyXG4gICAgICBwaXBlbGluZV9pZDogJ2RlZmF1bHQnLFxyXG4gICAgICBzdGFnZV9pZDogYW55RGVhbC5zdGFnZV9pZCxcclxuICAgICAgc3RhdHVzOiAnb3BlbicsXHJcbiAgICAgIHNvdXJjZTogJ2luYm91bmQnLFxyXG4gICAgICBub3RlczogJ01vY2snLFxyXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgY2xvc2VfZGF0ZTogbnVsbFxyXG4gICAgfSBhcyB1bmtub3duIGFzIERlYWxcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2RlYWxzJykuc2VsZWN0KCcqJykuZXEoJ2lkJywgaWQpLm1heWJlU2luZ2xlKClcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhIGFzIERlYWwgfCBudWxsKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWN0aXZpdGllc0ZvcihyZWxhdGVkVHlwZTogJ2RlYWwnfCdjb250YWN0J3wnY29tcGFueScsIHJlbGF0ZWRJZDogc3RyaW5nKTogUHJvbWlzZTxBY3Rpdml0eVtdPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLmFjdGl2aXRpZXNcclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdhY3Rpdml0aWVzJylcclxuICAgIC5zZWxlY3QoJyonKVxyXG4gICAgLmVxKCdyZWxhdGVkX3R5cGUnLCByZWxhdGVkVHlwZSlcclxuICAgIC5lcSgncmVsYXRlZF9pZCcsIHJlbGF0ZWRJZClcclxuICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICByZXR1cm4gKGRhdGEgPz8gW10pIGFzIEFjdGl2aXR5W11cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnRhY3QoaWQ6IHN0cmluZyk6IFByb21pc2U8Q29udGFjdCB8IG51bGw+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpXHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suY29udGFjdFxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2NvbnRhY3RzJykuc2VsZWN0KCcqJykuZXEoJ2lkJywgaWQpLm1heWJlU2luZ2xlKClcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhIGFzIENvbnRhY3QgfCBudWxsKVxyXG59XHJcblxyXG4vLyBBZGRlZCB0byByZXNvbHZlIGEgYnVpbGQgZXJyb3Igd2hlcmUgJ2dldENvbnRhY3RGb3JEZWFsJyB3YXMgcmVwb3J0ZWQgYXMgbWlzc2luZyxcclxuLy8gZXZlbiB0aG91Z2ggaXQncyBub3QgZXhwbGljaXRseSBpbXBvcnRlZCBpbiB0aGUgcmVsZXZhbnQgZmlsZXMuXHJcbi8vIEl0IHNpbXBseSBkZWxlZ2F0ZXMgdG8gZ2V0Q29udGFjdCwgYXMgdGhhdCdzIHRoZSBpbnRlbmRlZCBsb2dpYy5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnRhY3RGb3JEZWFsKGNvbnRhY3RJZDogc3RyaW5nKTogUHJvbWlzZTxDb250YWN0IHwgbnVsbD4ge1xyXG4gIHJldHVybiBnZXRDb250YWN0KGNvbnRhY3RJZCk7XHJcbn1cclxuXHJcbi8vIEFkZGVkIHRvIHJlc29sdmUgYSBidWlsZCBlcnJvciB3aGVyZSAnZ2V0U3RhZ2VOYW1lJyB3YXMgcmVwb3J0ZWQgYXMgbWlzc2luZy5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0YWdlTmFtZShzdGFnZUlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suc3RhZ2VzLmZpbmQocyA9PiBzLmlkID09PSBzdGFnZUlkKT8ubmFtZTtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwaXBlbGluZV9zdGFnZXMnKS5zZWxlY3QoJ25hbWUnKS5lcSgnaWQnLCBzdGFnZUlkKS5tYXliZVNpbmdsZSgpO1xyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgcmV0dXJuIGRhdGE/Lm5hbWU7XHJcbn1cclxuXHJcbi8vIEFjdGlvbnMgKHdyaXRlKSDigJQgcHJvdGVjdGVkIGJ5IFJMUzsgZXhwZWN0IEpXVCBpbiBmcm9udGVuZCBjb250ZXh0LlxyXG4vLyBGb3IgU1NSL0VkZ2Ugc2VjdXJlIHdyaXRlcywgcHJlZmVyIHNlcnZlci1vbmx5IGtleSBvciBlZGdlIGZ1bmN0aW9uIHByb3h5LlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVhbFN0YWdlKGRlYWxJZDogc3RyaW5nLCBuZXh0U3RhZ2VJZDogc3RyaW5nKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiB7IG9rOiB0cnVlIH1cclxuXHJcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgnZGVhbHMnKS51cGRhdGUoeyBzdGFnZV9pZDogbmV4dFN0YWdlSWQgfSkuZXEoJ2lkJywgZGVhbElkKVxyXG4gIGlmIChlcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29udGFjdFN0YXR1cyhjb250YWN0SWQ6IHN0cmluZywgc3RhdHVzOiAnaW50ZXJlc3RlZCcgfCAnbm90X2ludGVyZXN0ZWQnKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKTtcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG5cclxuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdjb250YWN0cycpLnVwZGF0ZSh7IHJlcGx5X3N0YXR1czogc3RhdHVzIH0pLmVxKCdpZCcsIGNvbnRhY3RJZCk7XHJcbiAgaWYgKGVycm9yKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGVuZGFyTGluayhjb250YWN0SWQ6IHN0cmluZyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgdXJsPzogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgLy8gVGhpcyBpcyBhIG1vY2sgaW1wbGVtZW50YXRpb24uIEluIGEgcmVhbCBhcHAsIHlvdSdkIGdlbmVyYXRlIGEgdW5pcXVlIGxpbmtcclxuICAvLyBvciBmZXRjaCBpdCBmcm9tIGEgY2FsZW5kYXIgc2VydmljZS5cclxuICByZXR1cm4geyBvazogdHJ1ZSwgdXJsOiBgaHR0cHM6Ly9jYWwuY29tL3lvdXItdXNlcm5hbWUvJHtjb250YWN0SWR9YCB9O1xyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gZGV0ZWN0IGVudiBwcmVzZW5jZVxyXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBhYmFzZUNvbmZpZ3VyZWQoKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIEJvb2xlYW4oU1VQQUJBU0VfVVJMICYmIFNVUEFCQVNFX0FOT05fS0VZKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0T3BlbkRlYWxzQ291bnQocGlwZWxpbmVJZD86IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKTtcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gNDI7IC8vIE1vY2sgZGF0YVxyXG5cclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKCdkZWFscycpLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnIH0pLmVxKCdzdGF0dXMnLCAnb3BlbicpO1xyXG4gIGlmIChwaXBlbGluZUlkKSB7XHJcbiAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwaXBlbGluZV9pZCcsIHBpcGVsaW5lSWQpO1xyXG4gIH1cclxuICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICByZXR1cm4gY291bnQgPz8gMDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExhc3Q3RGF5c1JlcGx5Q291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpO1xyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiAxNTsgLy8gTW9jayBkYXRhXHJcblxyXG4gIGNvbnN0IHNldmVuRGF5c0FnbyA9IG5ldyBEYXRlKCk7XHJcbiAgc2V2ZW5EYXlzQWdvLnNldERhdGUoc2V2ZW5EYXlzQWdvLmdldERhdGUoKSAtIDcpO1xyXG5cclxuICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdjb250YWN0cycpXHJcbiAgICAuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcgfSlcclxuICAgIC5ub3QoJ3JlcGx5X3N0YXR1cycsICdpcycsIG51bGwpXHJcbiAgICAuZ3RlKCd1cGRhdGVkX2F0Jywgc2V2ZW5EYXlzQWdvLnRvSVNPU3RyaW5nKCkpOyAvLyBBc3N1bWluZyB1cGRhdGVkX2F0IHJlZmxlY3RzIHJlcGx5IHN0YXR1cyBjaGFuZ2VzXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICByZXR1cm4gY291bnQgPz8gMDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBpcGVsaW5lQ29udmVyc2lvbihwaXBlbGluZUlkPzogc3RyaW5nKTogUHJvbWlzZTxQaXBlbGluZUNvbnZlcnNpb25bXT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkge1xyXG4gICAgcmV0dXJuIFsgLy8gTW9jayBkYXRhXHJcbiAgICAgIHsgc3RhZ2VfaWQ6ICdzMScsIHN0YWdlX25hbWU6ICdOZXcnLCBjb3VudDogMTAsIGNvbnZlcnNpb25fdG9fbmV4dDogNTAgfSxcclxuICAgICAgeyBzdGFnZV9pZDogJ3MyJywgc3RhZ2VfbmFtZTogJ0NvbnRhY3RlZCcsIGNvdW50OiA1LCBjb252ZXJzaW9uX3RvX25leHQ6IDgwIH0sXHJcbiAgICAgIHsgc3RhZ2VfaWQ6ICdzMycsIHN0YWdlX25hbWU6ICdRdWFsaWZpZWQnLCBjb3VudDogNCwgY29udmVyc2lvbl90b19uZXh0OiB1bmRlZmluZWQgfSxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBtb2NrIGZvciBjb252ZXJzaW9uLiBBIHJlYWwgaW1wbGVtZW50YXRpb24gd291bGQgaW52b2x2ZVxyXG4gIC8vIG1vcmUgY29tcGxleCBTUUwgcXVlcmllcyBvciBhIG1hdGVyaWFsaXplZCB2aWV3IHRvIGNhbGN1bGF0ZSBjb252ZXJzaW9ucyBiZXR3ZWVuIHN0YWdlcy5cclxuICBjb25zdCBzdGFnZXMgPSBhd2FpdCBnZXRQaXBlbGluZVN0YWdlcyhwaXBlbGluZUlkKTtcclxuICBjb25zdCBkZWFsc0J5U3RhZ2UgPSBhd2FpdCBnZXREZWFsc0J5UGlwZWxpbmUocGlwZWxpbmVJZCk7XHJcblxyXG4gIGNvbnN0IHN0YWdlQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgZm9yIChjb25zdCBzdGFnZSBvZiBzdGFnZXMpIHtcclxuICAgIHN0YWdlQ291bnRzW3N0YWdlLmlkXSA9IGRlYWxzQnlTdGFnZVtzdGFnZS5pZF0/Lmxlbmd0aCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY29udmVyc2lvbkRhdGE6IFBpcGVsaW5lQ29udmVyc2lvbltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGN1cnJlbnRTdGFnZSA9IHN0YWdlc1tpXTtcclxuICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IHN0YWdlQ291bnRzW2N1cnJlbnRTdGFnZS5pZF07XHJcbiAgICBsZXQgY29udmVyc2lvblRvTmV4dDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmIChpIDwgc3RhZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgY29uc3QgbmV4dFN0YWdlID0gc3RhZ2VzW2kgKyAxXTtcclxuICAgICAgY29uc3QgbmV4dENvdW50ID0gc3RhZ2VDb3VudHNbbmV4dFN0YWdlLmlkXTtcclxuICAgICAgaWYgKGN1cnJlbnRDb3VudCA+IDApIHtcclxuICAgICAgICBjb252ZXJzaW9uVG9OZXh0ID0gTWF0aC5yb3VuZCgobmV4dENvdW50IC8gY3VycmVudENvdW50KSAqIDEwMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb252ZXJzaW9uRGF0YS5wdXNoKHtcclxuICAgICAgc3RhZ2VfaWQ6IGN1cnJlbnRTdGFnZS5pZCxcclxuICAgICAgc3RhZ2VfbmFtZTogY3VycmVudFN0YWdlLm5hbWUsXHJcbiAgICAgIGNvdW50OiBjdXJyZW50Q291bnQsXHJcbiAgICAgIGNvbnZlcnNpb25fdG9fbmV4dDogY29udmVyc2lvblRvTmV4dCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnZlcnNpb25EYXRhO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQaXBlbGluZUNvbnZlcnNpb24gPSB7XHJcbiAgc3RhZ2VfaWQ6IHN0cmluZztcclxuICBzdGFnZV9uYW1lOiBzdHJpbmc7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICBjb252ZXJzaW9uX3RvX25leHQ/OiBudW1iZXI7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJTVVBBQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiU1VQQUJBU0VfQU5PTl9LRVkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImdldENsaWVudCIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsIm1vY2siLCJzdGFnZXMiLCJpZCIsIm5hbWUiLCJvcmRlcl9pbmRleCIsInByb2JhYmlsaXR5IiwiZGVhbHNCeVN0YWdlIiwiczEiLCJ0aXRsZSIsInN0YWdlX2lkIiwiYW1vdW50IiwiY3VycmVuY3kiLCJzMiIsInMzIiwiYWN0aXZpdGllcyIsInR5cGUiLCJyZWxhdGVkX3R5cGUiLCJyZWxhdGVkX2lkIiwiY29udGVudCIsIm1ldGFfanNvbiIsImNyZWF0ZWRfYnkiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29udGFjdCIsImVtYWlsIiwiZnVsbF9uYW1lIiwibGlua2VkaW5fdXJsIiwid2Vic2l0ZSIsInBob25lIiwiY29tcGFueV9pZCIsIm93bmVyX2lkIiwibGlmZWN5Y2xlX3N0YWdlIiwicmVwbHlfc3RhdHVzIiwicmVwbHlfc3VtbWFyeSIsImdlbmVyYXRlZF9ib2R5X3N0ZXAxIiwiZ2VuZXJhdGVkX2JvZHlfc3RlcDIiLCJnZW5lcmF0ZWRfYm9keV9zdGVwMyIsImxhdGVzdF9lbWFpbF9zZW50X2F0IiwidXBkYXRlZF9hdCIsImdldFBpcGVsaW5lU3RhZ2VzIiwicGlwZWxpbmVJZCIsInN1cGFiYXNlIiwicGlwZWxpbmUiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvcmRlciIsImFzY2VuZGluZyIsImxpbWl0IiwibWF5YmVTaW5nbGUiLCJnZXREZWFsc0J5UGlwZWxpbmUiLCJwaWQiLCJkZWFscyIsImNvbXBhbnlJZHMiLCJBcnJheSIsIlNldCIsIm1hcCIsImQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY29udGFjdElkcyIsImNvbnRhY3RfaWQiLCJjb21wYW5pZXNSZXMiLCJjb250YWN0c1JlcyIsIlByb21pc2UiLCJhbGwiLCJsZW5ndGgiLCJpbiIsInJlc29sdmUiLCJjb21wYW55TWFwIiwiTWFwIiwiYyIsImNvbnRhY3RNYXAiLCJncm91cGVkIiwiY2FyZCIsImNvbXBhbnkiLCJnZXQiLCJwdXNoIiwiZ2V0RGVhbERldGFpbCIsImFueURlYWwiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmbGF0IiwicGlwZWxpbmVfaWQiLCJzdGF0dXMiLCJzb3VyY2UiLCJub3RlcyIsImNsb3NlX2RhdGUiLCJnZXRBY3Rpdml0aWVzRm9yIiwicmVsYXRlZFR5cGUiLCJyZWxhdGVkSWQiLCJnZXRDb250YWN0IiwiZ2V0Q29udGFjdEZvckRlYWwiLCJjb250YWN0SWQiLCJnZXRTdGFnZU5hbWUiLCJzdGFnZUlkIiwiZmluZCIsInMiLCJ1cGRhdGVEZWFsU3RhZ2UiLCJkZWFsSWQiLCJuZXh0U3RhZ2VJZCIsIm9rIiwidXBkYXRlIiwibWVzc2FnZSIsInVwZGF0ZUNvbnRhY3RTdGF0dXMiLCJnZXRDYWxlbmRhckxpbmsiLCJ1cmwiLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsImdldE9wZW5EZWFsc0NvdW50IiwicXVlcnkiLCJjb3VudCIsImdldExhc3Q3RGF5c1JlcGx5Q291bnQiLCJzZXZlbkRheXNBZ28iLCJzZXREYXRlIiwiZ2V0RGF0ZSIsIm5vdCIsImd0ZSIsImdldFBpcGVsaW5lQ29udmVyc2lvbiIsInN0YWdlX25hbWUiLCJjb252ZXJzaW9uX3RvX25leHQiLCJ1bmRlZmluZWQiLCJzdGFnZUNvdW50cyIsInN0YWdlIiwiY29udmVyc2lvbkRhdGEiLCJpIiwiY3VycmVudFN0YWdlIiwiY3VycmVudENvdW50IiwiY29udmVyc2lvblRvTmV4dCIsIm5leHRTdGFnZSIsIm5leHRDb3VudCIsIk1hdGgiLCJyb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});