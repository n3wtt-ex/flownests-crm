"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getRepliesLast7d: function() { return /* binding */ getRepliesLast7d; },\n/* harmony export */   getSimpleConversion: function() { return /* binding */ getSimpleConversion; },\n/* harmony export */   getStageDistribution: function() { return /* binding */ getStageDistribution; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDeal: function() { return /* binding */ updateDeal; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/**\r\n * Read-only CRM API helpers (MVP skeleton).\r\n * Implementation note:\r\n * - Start with mock/placeholder implementations.\r\n * - Replace with Supabase client or backend proxy once auth/RLS strategy is set.\r\n */ const MOCK_DELAY = 150;\nfunction sleep() {\n    let ms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MOCK_DELAY;\n    return new Promise((res)=>setTimeout(res, ms));\n}\n// In-memory mock\nconst mockStages = [\n    {\n        id: \"s_new\",\n        name: \"New\",\n        order_index: 0,\n        probability: 0.05,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_contacted\",\n        name: \"Contacted\",\n        order_index: 1,\n        probability: 0.15,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_qualified\",\n        name: \"Qualified\",\n        order_index: 2,\n        probability: 0.35,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_meeting\",\n        name: \"Meeting Scheduled\",\n        order_index: 3,\n        probability: 0.5,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_proposal\",\n        name: \"Proposal Sent\",\n        order_index: 4,\n        probability: 0.7,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_won\",\n        name: \"Won\",\n        order_index: 5,\n        probability: 1.0,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_lost\",\n        name: \"Lost\",\n        order_index: 6,\n        probability: 0,\n        pipeline_id: \"p_default\"\n    }\n];\nconst mockDeals = [\n    {\n        id: \"d1\",\n        title: \"Acme - Pilot\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_new\",\n        amount: 2500,\n        currency: \"USD\",\n        source: \"outbound\"\n    },\n    {\n        id: \"d2\",\n        title: \"Globex - Discovery\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_contacted\",\n        amount: 5000,\n        currency: \"USD\",\n        source: \"reply\"\n    },\n    {\n        id: \"d3\",\n        title: \"Initech - Expansion\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_meeting\",\n        amount: 12000,\n        currency: \"USD\",\n        source: \"booking\"\n    }\n];\nconst mockContacts = {\n    c1: {\n        id: \"c1\",\n        full_name: \"John Doe\",\n        email: \"john@acme.com\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/john\",\n        website: \"https://acme.com\"\n    },\n    c2: {\n        id: \"c2\",\n        full_name: \"Mike Neo\",\n        email: \"mike@globex.com\",\n        title: \"Head of Ops\",\n        linkedin_url: \"https://linkedin.com/in/mike\",\n        website: \"https://globex.example\",\n        reply_status: \"question\",\n        reply_summary: \"Asked about pricing\"\n    }\n};\nconst mockActivities = [\n    {\n        id: \"a1\",\n        type: \"email_in\",\n        related_type: \"deal\",\n        related_id: \"d2\",\n        content: \"pricing details?\",\n        created_at: new Date(Date.now() - 86400000).toISOString()\n    },\n    {\n        id: \"a2\",\n        type: \"meeting\",\n        related_type: \"deal\",\n        related_id: \"d3\",\n        content: \"Discovery Call scheduled\",\n        created_at: new Date(Date.now() - 3600000).toISOString()\n    },\n    {\n        id: \"a3\",\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: \"d1\",\n        content: \"Deal created\",\n        created_at: new Date(Date.now() - 1800000).toISOString()\n    }\n];\n// Map one contact to deals for demo\nconst dealToContact = {\n    d1: \"c1\",\n    d2: \"c2\",\n    d3: \"c2\"\n};\nasync function getPipelineStages(pipelineId) {\n    // TODO: Replace with Supabase select from pipeline_stages where pipeline_id = pipelineId order by order_index\n    await sleep();\n    return mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n}\nasync function getDealsByPipeline(pipelineId) {\n    // TODO: Replace with Supabase select from deals where pipeline_id = pipelineId\n    await sleep();\n    return mockDeals.filter((d)=>d.pipeline_id === pipelineId);\n}\nasync function getDealDetail(id) {\n    // TODO: Replace with Supabase select deals by id\n    await sleep();\n    const deal = mockDeals.find((d)=>d.id === id);\n    if (!deal) throw new Error(\"Deal not found\");\n    return deal;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    // TODO: Replace with Supabase select activities where related_type = relatedType and related_id = relatedId order by created_at desc\n    await sleep();\n    return mockActivities.filter((a)=>a.related_type === relatedType && a.related_id === relatedId).sort((a, b)=>+new Date(b.created_at) - +new Date(a.created_at));\n}\nasync function getContact(id) {\n    // TODO: Replace with Supabase select contacts by id\n    await sleep();\n    const c = mockContacts[id];\n    if (!c) throw new Error(\"Contact not found\");\n    return c;\n}\n/**\r\n * Sprint 2 — ContactQuick actions: interested / not_interested toggle\r\n * Gerçek entegrasyonda POST /crm/actions/contacts çağrısına dönüşecektir.\r\n */ async function updateContactStatus(contactId, status) {\n    await sleep();\n    const c = mockContacts[contactId];\n    if (!c) return {\n        ok: false,\n        error: \"Contact not found\"\n    };\n    const prev = {\n        ...c\n    };\n    c.reply_status = status;\n    // Log activity\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"contact\",\n        related_id: contactId,\n        content: \"Contact status changed\",\n        meta_json: {\n            from: prev.reply_status,\n            to: status\n        },\n        created_at: new Date().toISOString()\n    });\n    // Outbound webhook (log-only, mock)\n    // In real impl: fire-and-forget POST with event_type=contact_status_changed\n    return {\n        ok: true,\n        contact: c\n    };\n}\n/**\r\n * Sprint 2 — ContactQuick actions: send calendar link (placeholder)\r\n * S2: yalnızca link üretip döndürür; S3: gerçek e-posta/mesaj otomasyonu.\r\n */ async function getCalendarLink(contactId) {\n    var _mockContacts_contactId;\n    await sleep();\n    const base = \"https://cal.com/your-team/30min\";\n    // basitçe kişi e-postasını query olarak iliştir\n    const email = ((_mockContacts_contactId = mockContacts[contactId]) === null || _mockContacts_contactId === void 0 ? void 0 : _mockContacts_contactId.email) || \"prospect@example.com\";\n    const url = \"\".concat(base, \"?email=\").concat(encodeURIComponent(email));\n    return {\n        ok: true,\n        url\n    };\n}\n// Helper to compute stage name for a given stage_id (useful for UI)\nasync function getStageName(pipelineId, stageId) {\n    var _stages_find;\n    const stages = await getPipelineStages(pipelineId);\n    return (_stages_find = stages.find((s)=>s.id === stageId)) === null || _stages_find === void 0 ? void 0 : _stages_find.name;\n}\n// Demo-only helpers to bridge mock relations\nasync function getContactForDeal(dealId) {\n    const contactId = dealToContact[dealId];\n    if (!contactId) return undefined;\n    return getContact(contactId);\n}\n/**\r\n * Reporting helpers (Snapshot MVP)\r\n * Note: Mock implementation using in-memory data; replace with Supabase/Edge queries later.\r\n */ async function getRepliesLast7d() {\n    await sleep();\n    const since = Date.now() - 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && +new Date(a.created_at) >= since).length;\n}\nasync function getStageDistribution(pipelineId) {\n    await sleep();\n    const dist = {};\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        dist[d.stage_id] = (dist[d.stage_id] || 0) + 1;\n    }\n    return dist;\n}\nasync function getSimpleConversion(pipelineId) {\n    await sleep();\n    // Basit bir oran: New -> Qualified\n    const from = \"s_new\";\n    const to = \"s_qualified\";\n    const inFrom = mockDeals.filter((d)=>d.pipeline_id === pipelineId && d.stage_id === from).length;\n    const inTo = mockDeals.filter((d)=>d.pipeline_id === pipelineId && d.stage_id === to).length;\n    const rate = inFrom > 0 ? Number((inTo / inFrom * 100).toFixed(0)) : null;\n    return {\n        from,\n        to,\n        rate\n    };\n}\nasync function updateDeal(input, options) {\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) return {\n        ok: false,\n        error: \"Simulated update error\"\n    };\n    const idx = mockDeals.findIndex((d)=>d.id === input.id);\n    if (idx === -1) return {\n        ok: false,\n        error: \"Deal not found\"\n    };\n    const prev = mockDeals[idx];\n    // basic validation\n    if (typeof input.amount !== \"undefined\" && Number.isNaN(Number(input.amount))) {\n        return {\n            ok: false,\n            error: \"Amount must be numeric\"\n        };\n    }\n    if (typeof input.close_date !== \"undefined\") {\n        const t = Date.parse(input.close_date);\n        if (Number.isNaN(t)) return {\n            ok: false,\n            error: \"close_date must be ISO string\"\n        };\n    }\n    var _input_title, _input_currency, _input_close_date, _input_stage_id;\n    const next = {\n        ...prev,\n        title: (_input_title = input.title) !== null && _input_title !== void 0 ? _input_title : prev.title,\n        amount: typeof input.amount !== \"undefined\" ? Number(input.amount) : prev.amount,\n        currency: (_input_currency = input.currency) !== null && _input_currency !== void 0 ? _input_currency : prev.currency,\n        close_date: (_input_close_date = input.close_date) !== null && _input_close_date !== void 0 ? _input_close_date : prev.close_date,\n        stage_id: (_input_stage_id = input.stage_id) !== null && _input_stage_id !== void 0 ? _input_stage_id : prev.stage_id\n    };\n    mockDeals[idx] = next;\n    // log activity\n    const changed = {};\n    for (const k of [\n        \"title\",\n        \"amount\",\n        \"currency\",\n        \"close_date\",\n        \"stage_id\"\n    ]){\n        if (prev[k] !== next[k]) changed[k] = {\n            from: prev[k],\n            to: next[k]\n        };\n    }\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: input.id,\n        content: \"Deal updated\",\n        meta_json: {\n            changed\n        },\n        created_at: new Date().toISOString()\n    });\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Sprint 2 - İlk Görev: Kanban Drag & Drop → Stage Change\r\n * Mock ortamda optimistic UI akışını doğrulamak için stage güncelleme helper'ı.\r\n * Gerçek entegrasyonda bu fonksiyon, Edge Function'a (POST /crm/actions/deals/:id/stage) çağrı yapacak.\r\n */ async function updateDealStage(dealId, nextStageId, options) {\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) {\n        return {\n            ok: false,\n            error: \"Simulated network/server error\"\n        };\n    }\n    const idx = mockDeals.findIndex((d)=>d.id === dealId);\n    if (idx === -1) {\n        return {\n            ok: false,\n            error: \"Deal not found\"\n        };\n    }\n    const prev = mockDeals[idx];\n    const next = {\n        ...prev,\n        stage_id: nextStageId\n    };\n    mockDeals[idx] = next;\n    // System activity insert (mock)\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: dealId,\n        content: \"Stage changed\",\n        meta_json: {\n            from: prev.stage_id,\n            to: nextStageId,\n            occurred_at: options === null || options === void 0 ? void 0 : options.occurredAtISO\n        },\n        created_at: new Date().toISOString()\n    });\n    // Outbound webhook (log-only, mock)\n    // In real impl: fire-and-forget POST to outbound endpoint with event_type=deal_stage_changed\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Reporting (MVP, mock)\r\n * - open deals count\r\n * - last 7 days reply count (email_in)\r\n * - simple pipeline conversion (stage-to-stage ratios within current mock snapshot)\r\n */ async function getOpenDealsCount(pipelineId) {\n    await sleep();\n    const list = pipelineId ? mockDeals.filter((d)=>d.pipeline_id === pipelineId) : mockDeals;\n    // Open = not Won and not Lost\n    return list.filter((d)=>d.stage_id !== \"s_won\" && d.stage_id !== \"s_lost\").length;\n}\nasync function getLast7DaysReplyCount() {\n    await sleep();\n    const now = Date.now();\n    const sevenDays = 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && now - +new Date(a.created_at) <= sevenDays).length;\n}\nasync function getPipelineConversion() {\n    let pipelineId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"p_default\";\n    await sleep();\n    const stages = mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n    const byStageCount = {};\n    for (const s of stages)byStageCount[s.id] = 0;\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        if (byStageCount[d.stage_id] !== undefined) byStageCount[d.stage_id] += 1;\n    }\n    const result = stages.map((s, idx)=>{\n        const count = byStageCount[s.id] || 0;\n        let conversion = undefined;\n        if (idx < stages.length - 1) {\n            const nextStage = stages[idx + 1];\n            const nextCount = byStageCount[nextStage.id] || 0;\n            // naive ratio using snapshot counts (not cohort-based)\n            conversion = count > 0 ? Math.round(nextCount / count * 100) : undefined;\n        }\n        return {\n            stage_id: s.id,\n            stage_name: s.name,\n            count,\n            conversion_to_next: conversion\n        };\n    });\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQXNDRCxNQUFNQSxhQUFhO0FBRW5CLFNBQVNDO1FBQU1DLEtBQUFBLGlFQUFLRjtJQUNsQixPQUFPLElBQUlHLFFBQVEsQ0FBQ0MsTUFBUUMsV0FBV0QsS0FBS0Y7QUFDOUM7QUFFQSxpQkFBaUI7QUFDakIsTUFBTUksYUFBc0I7SUFDMUI7UUFBRUMsSUFBSTtRQUFTQyxNQUFNO1FBQU9DLGFBQWE7UUFBR0MsYUFBYTtRQUFNQyxhQUFhO0lBQVk7SUFDeEY7UUFBRUosSUFBSTtRQUFlQyxNQUFNO1FBQWFDLGFBQWE7UUFBR0MsYUFBYTtRQUFNQyxhQUFhO0lBQVk7SUFDcEc7UUFBRUosSUFBSTtRQUFlQyxNQUFNO1FBQWFDLGFBQWE7UUFBR0MsYUFBYTtRQUFNQyxhQUFhO0lBQVk7SUFDcEc7UUFBRUosSUFBSTtRQUFhQyxNQUFNO1FBQXFCQyxhQUFhO1FBQUdDLGFBQWE7UUFBS0MsYUFBYTtJQUFZO0lBQ3pHO1FBQUVKLElBQUk7UUFBY0MsTUFBTTtRQUFpQkMsYUFBYTtRQUFHQyxhQUFhO1FBQUtDLGFBQWE7SUFBWTtJQUN0RztRQUFFSixJQUFJO1FBQVNDLE1BQU07UUFBT0MsYUFBYTtRQUFHQyxhQUFhO1FBQUtDLGFBQWE7SUFBWTtJQUN2RjtRQUFFSixJQUFJO1FBQVVDLE1BQU07UUFBUUMsYUFBYTtRQUFHQyxhQUFhO1FBQUdDLGFBQWE7SUFBWTtDQUN4RjtBQUVELE1BQU1DLFlBQW9CO0lBQ3hCO1FBQUVMLElBQUk7UUFBTU0sT0FBTztRQUFnQkYsYUFBYTtRQUFhRyxVQUFVO1FBQVNDLFFBQVE7UUFBTUMsVUFBVTtRQUFPQyxRQUFRO0lBQVc7SUFDbEk7UUFBRVYsSUFBSTtRQUFNTSxPQUFPO1FBQXNCRixhQUFhO1FBQWFHLFVBQVU7UUFBZUMsUUFBUTtRQUFNQyxVQUFVO1FBQU9DLFFB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InNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc2VydmljZXMvY3JtQXBpLnRzPzgxZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJlYWQtb25seSBDUk0gQVBJIGhlbHBlcnMgKE1WUCBza2VsZXRvbikuXHJcbiAqIEltcGxlbWVudGF0aW9uIG5vdGU6XHJcbiAqIC0gU3RhcnQgd2l0aCBtb2NrL3BsYWNlaG9sZGVyIGltcGxlbWVudGF0aW9ucy5cclxuICogLSBSZXBsYWNlIHdpdGggU3VwYWJhc2UgY2xpZW50IG9yIGJhY2tlbmQgcHJveHkgb25jZSBhdXRoL1JMUyBzdHJhdGVneSBpcyBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHR5cGUgU3RhZ2UgPSB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgb3JkZXJfaW5kZXg6IG51bWJlcjsgcGlwZWxpbmVfaWQ/OiBzdHJpbmc7IHByb2JhYmlsaXR5PzogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIERlYWwgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGNvbXBhbnlfaWQ/OiBzdHJpbmc7XHJcbiAgY29udGFjdF9pZD86IHN0cmluZztcclxuICBwaXBlbGluZV9pZDogc3RyaW5nO1xyXG4gIHN0YWdlX2lkOiBzdHJpbmc7XHJcbiAgYW1vdW50PzogbnVtYmVyO1xyXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xyXG4gIGNsb3NlX2RhdGU/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIHNvdXJjZT86IHN0cmluZztcclxuICBub3Rlcz86IHN0cmluZztcclxuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xyXG59O1xyXG5leHBvcnQgdHlwZSBBY3Rpdml0eSA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHR5cGU6ICdlbWFpbF9pbicgfCAnZW1haWxfb3V0JyB8ICdjYWxsJyB8ICdtZWV0aW5nJyB8ICd0YXNrJyB8ICdub3RlJyB8ICdzeXN0ZW0nO1xyXG4gIHJlbGF0ZWRfdHlwZTogJ2RlYWwnIHwgJ2NvbnRhY3QnIHwgJ2NvbXBhbnknO1xyXG4gIHJlbGF0ZWRfaWQ6IHN0cmluZztcclxuICBjb250ZW50Pzogc3RyaW5nO1xyXG4gIG1ldGFfanNvbj86IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5leHBvcnQgdHlwZSBDb250YWN0ID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgZnVsbF9uYW1lPzogc3RyaW5nO1xyXG4gIGVtYWlsPzogc3RyaW5nO1xyXG4gIHRpdGxlPzogc3RyaW5nO1xyXG4gIGxpbmtlZGluX3VybD86IHN0cmluZztcclxuICB3ZWJzaXRlPzogc3RyaW5nO1xyXG4gIHJlcGx5X3N0YXR1cz86ICdpbnRlcmVzdGVkJyB8ICdub3RfaW50ZXJlc3RlZCcgfCAncXVlc3Rpb24nIHwgc3RyaW5nO1xyXG4gIHJlcGx5X3N1bW1hcnk/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5jb25zdCBNT0NLX0RFTEFZID0gMTUwO1xyXG5cclxuZnVuY3Rpb24gc2xlZXAobXMgPSBNT0NLX0RFTEFZKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xyXG59XHJcblxyXG4vLyBJbi1tZW1vcnkgbW9ja1xyXG5jb25zdCBtb2NrU3RhZ2VzOiBTdGFnZVtdID0gW1xyXG4gIHsgaWQ6ICdzX25ldycsIG5hbWU6ICdOZXcnLCBvcmRlcl9pbmRleDogMCwgcHJvYmFiaWxpdHk6IDAuMDUsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX2NvbnRhY3RlZCcsIG5hbWU6ICdDb250YWN0ZWQnLCBvcmRlcl9pbmRleDogMSwgcHJvYmFiaWxpdHk6IDAuMTUsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX3F1YWxpZmllZCcsIG5hbWU6ICdRdWFsaWZpZWQnLCBvcmRlcl9pbmRleDogMiwgcHJvYmFiaWxpdHk6IDAuMzUsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX21lZXRpbmcnLCBuYW1lOiAnTWVldGluZyBTY2hlZHVsZWQnLCBvcmRlcl9pbmRleDogMywgcHJvYmFiaWxpdHk6IDAuNSwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbiAgeyBpZDogJ3NfcHJvcG9zYWwnLCBuYW1lOiAnUHJvcG9zYWwgU2VudCcsIG9yZGVyX2luZGV4OiA0LCBwcm9iYWJpbGl0eTogMC43LCBwaXBlbGluZV9pZDogJ3BfZGVmYXVsdCcgfSxcclxuICB7IGlkOiAnc193b24nLCBuYW1lOiAnV29uJywgb3JkZXJfaW5kZXg6IDUsIHByb2JhYmlsaXR5OiAxLjAsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX2xvc3QnLCBuYW1lOiAnTG9zdCcsIG9yZGVyX2luZGV4OiA2LCBwcm9iYWJpbGl0eTogMCwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbl07XHJcblxyXG5jb25zdCBtb2NrRGVhbHM6IERlYWxbXSA9IFtcclxuICB7IGlkOiAnZDEnLCB0aXRsZTogJ0FjbWUgLSBQaWxvdCcsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0Jywgc3RhZ2VfaWQ6ICdzX25ldycsIGFtb3VudDogMjUwMCwgY3VycmVuY3k6ICdVU0QnLCBzb3VyY2U6ICdvdXRib3VuZCcgfSxcclxuICB7IGlkOiAnZDInLCB0aXRsZTogJ0dsb2JleCAtIERpc2NvdmVyeScsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0Jywgc3RhZ2VfaWQ6ICdzX2NvbnRhY3RlZCcsIGFtb3VudDogNTAwMCwgY3VycmVuY3k6ICdVU0QnLCBzb3VyY2U6ICdyZXBseScgfSxcclxuICB7IGlkOiAnZDMnLCB0aXRsZTogJ0luaXRlY2ggLSBFeHBhbnNpb24nLCBwaXBlbGluZV9pZDogJ3BfZGVmYXVsdCcsIHN0YWdlX2lkOiAnc19tZWV0aW5nJywgYW1vdW50OiAxMjAwMCwgY3VycmVuY3k6ICdVU0QnLCBzb3VyY2U6ICdib29raW5nJyB9LFxyXG5dO1xyXG5cclxuY29uc3QgbW9ja0NvbnRhY3RzOiBSZWNvcmQ8c3RyaW5nLCBDb250YWN0PiA9IHtcclxuICBjMTogeyBpZDogJ2MxJywgZnVsbF9uYW1lOiAnSm9obiBEb2UnLCBlbWFpbDogJ2pvaG5AYWNtZS5jb20nLCB0aXRsZTogJ1ZQIFNhbGVzJywgbGlua2VkaW5fdXJsOiAnaHR0cHM6Ly9saW5rZWRpbi5jb20vaW4vam9obicsIHdlYnNpdGU6ICdodHRwczovL2FjbWUuY29tJyB9LFxyXG4gIGMyOiB7IGlkOiAnYzInLCBmdWxsX25hbWU6ICdNaWtlIE5lbycsIGVtYWlsOiAnbWlrZUBnbG9iZXguY29tJywgdGl0bGU6ICdIZWFkIG9mIE9wcycsIGxpbmtlZGluX3VybDogJ2h0dHBzOi8vbGlua2VkaW4uY29tL2luL21pa2UnLCB3ZWJzaXRlOiAnaHR0cHM6Ly9nbG9iZXguZXhhbXBsZScsIHJlcGx5X3N0YXR1czogJ3F1ZXN0aW9uJywgcmVwbHlfc3VtbWFyeTogJ0Fza2VkIGFib3V0IHByaWNpbmcnIH0sXHJcbn07XHJcblxyXG5jb25zdCBtb2NrQWN0aXZpdGllczogQWN0aXZpdHlbXSA9IFtcclxuICB7IGlkOiAnYTEnLCB0eXBlOiAnZW1haWxfaW4nLCByZWxhdGVkX3R5cGU6ICdkZWFsJywgcmVsYXRlZF9pZDogJ2QyJywgY29udGVudDogJ3ByaWNpbmcgZGV0YWlscz8nLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gODY0MDAwMDApLnRvSVNPU3RyaW5nKCkgfSxcclxuICB7IGlkOiAnYTInLCB0eXBlOiAnbWVldGluZycsIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLCByZWxhdGVkX2lkOiAnZDMnLCBjb250ZW50OiAnRGlzY292ZXJ5IENhbGwgc2NoZWR1bGVkJywgY3JlYXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDM2MDAwMDApLnRvSVNPU3RyaW5nKCkgfSxcclxuICB7IGlkOiAnYTMnLCB0eXBlOiAnc3lzdGVtJywgcmVsYXRlZF90eXBlOiAnZGVhbCcsIHJlbGF0ZWRfaWQ6ICdkMScsIGNvbnRlbnQ6ICdEZWFsIGNyZWF0ZWQnLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTgwMDAwMCkudG9JU09TdHJpbmcoKSB9LFxyXG5dO1xyXG5cclxuLy8gTWFwIG9uZSBjb250YWN0IHRvIGRlYWxzIGZvciBkZW1vXHJcbmNvbnN0IGRlYWxUb0NvbnRhY3Q6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgZDE6ICdjMScsXHJcbiAgZDI6ICdjMicsXHJcbiAgZDM6ICdjMicsXHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGlwZWxpbmVTdGFnZXMocGlwZWxpbmVJZDogc3RyaW5nKTogUHJvbWlzZTxTdGFnZVtdPiB7XHJcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFN1cGFiYXNlIHNlbGVjdCBmcm9tIHBpcGVsaW5lX3N0YWdlcyB3aGVyZSBwaXBlbGluZV9pZCA9IHBpcGVsaW5lSWQgb3JkZXIgYnkgb3JkZXJfaW5kZXhcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIHJldHVybiBtb2NrU3RhZ2VzLmZpbHRlcigocykgPT4gcy5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCkuc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbHNCeVBpcGVsaW5lKHBpcGVsaW5lSWQ6IHN0cmluZyk6IFByb21pc2U8RGVhbFtdPiB7XHJcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFN1cGFiYXNlIHNlbGVjdCBmcm9tIGRlYWxzIHdoZXJlIHBpcGVsaW5lX2lkID0gcGlwZWxpbmVJZFxyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgcmV0dXJuIG1vY2tEZWFscy5maWx0ZXIoKGQpID0+IGQucGlwZWxpbmVfaWQgPT09IHBpcGVsaW5lSWQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbERldGFpbChpZDogc3RyaW5nKTogUHJvbWlzZTxEZWFsPiB7XHJcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFN1cGFiYXNlIHNlbGVjdCBkZWFscyBieSBpZFxyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgZGVhbCA9IG1vY2tEZWFscy5maW5kKChkKSA9PiBkLmlkID09PSBpZCk7XHJcbiAgaWYgKCFkZWFsKSB0aHJvdyBuZXcgRXJyb3IoJ0RlYWwgbm90IGZvdW5kJyk7XHJcbiAgcmV0dXJuIGRlYWw7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY3Rpdml0aWVzRm9yKHJlbGF0ZWRUeXBlOiAnZGVhbCd8J2NvbnRhY3QnfCdjb21wYW55JywgcmVsYXRlZElkOiBzdHJpbmcpOiBQcm9taXNlPEFjdGl2aXR5W10+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGFjdGl2aXRpZXMgd2hlcmUgcmVsYXRlZF90eXBlID0gcmVsYXRlZFR5cGUgYW5kIHJlbGF0ZWRfaWQgPSByZWxhdGVkSWQgb3JkZXIgYnkgY3JlYXRlZF9hdCBkZXNjXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICByZXR1cm4gbW9ja0FjdGl2aXRpZXMuZmlsdGVyKChhKSA9PiBhLnJlbGF0ZWRfdHlwZSA9PT0gcmVsYXRlZFR5cGUgJiYgYS5yZWxhdGVkX2lkID09PSByZWxhdGVkSWQpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gK25ldyBEYXRlKGIuY3JlYXRlZF9hdCkgLSArbmV3IERhdGUoYS5jcmVhdGVkX2F0KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3Q+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGNvbnRhY3RzIGJ5IGlkXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBjID0gbW9ja0NvbnRhY3RzW2lkXTtcclxuICBpZiAoIWMpIHRocm93IG5ldyBFcnJvcignQ29udGFjdCBub3QgZm91bmQnKTtcclxuICByZXR1cm4gYztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwcmludCAyIOKAlCBDb250YWN0UXVpY2sgYWN0aW9uczogaW50ZXJlc3RlZCAvIG5vdF9pbnRlcmVzdGVkIHRvZ2dsZVxyXG4gKiBHZXLDp2VrIGVudGVncmFzeW9uZGEgUE9TVCAvY3JtL2FjdGlvbnMvY29udGFjdHMgw6dhxJ9yxLFzxLFuYSBkw7Zuw7zFn2VjZWt0aXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29udGFjdFN0YXR1cyhcclxuICBjb250YWN0SWQ6IHN0cmluZyxcclxuICBzdGF0dXM6ICdpbnRlcmVzdGVkJyB8ICdub3RfaW50ZXJlc3RlZCdcclxuKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgY29udGFjdD86IENvbnRhY3QgfT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgYyA9IG1vY2tDb250YWN0c1tjb250YWN0SWRdO1xyXG4gIGlmICghYykgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0NvbnRhY3Qgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0geyAuLi5jIH07XHJcbiAgYy5yZXBseV9zdGF0dXMgPSBzdGF0dXM7XHJcblxyXG4gIC8vIExvZyBhY3Rpdml0eVxyXG4gIG1vY2tBY3Rpdml0aWVzLnB1c2goe1xyXG4gICAgaWQ6IGBhXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgdHlwZTogJ3N5c3RlbScsXHJcbiAgICByZWxhdGVkX3R5cGU6ICdjb250YWN0JyxcclxuICAgIHJlbGF0ZWRfaWQ6IGNvbnRhY3RJZCxcclxuICAgIGNvbnRlbnQ6ICdDb250YWN0IHN0YXR1cyBjaGFuZ2VkJyxcclxuICAgIG1ldGFfanNvbjogeyBmcm9tOiBwcmV2LnJlcGx5X3N0YXR1cywgdG86IHN0YXR1cyB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICAvLyBPdXRib3VuZCB3ZWJob29rIChsb2ctb25seSwgbW9jaylcclxuICAvLyBJbiByZWFsIGltcGw6IGZpcmUtYW5kLWZvcmdldCBQT1NUIHdpdGggZXZlbnRfdHlwZT1jb250YWN0X3N0YXR1c19jaGFuZ2VkXHJcblxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBjb250YWN0OiBjIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcHJpbnQgMiDigJQgQ29udGFjdFF1aWNrIGFjdGlvbnM6IHNlbmQgY2FsZW5kYXIgbGluayAocGxhY2Vob2xkZXIpXHJcbiAqIFMyOiB5YWxuxLF6Y2EgbGluayDDvHJldGlwIGTDtm5kw7xyw7xyOyBTMzogZ2Vyw6dlayBlLXBvc3RhL21lc2FqIG90b21hc3lvbnUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJMaW5rKGNvbnRhY3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyB1cmw6IHN0cmluZyB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBiYXNlID0gJ2h0dHBzOi8vY2FsLmNvbS95b3VyLXRlYW0vMzBtaW4nO1xyXG4gIC8vIGJhc2l0w6dlIGtpxZ9pIGUtcG9zdGFzxLFuxLEgcXVlcnkgb2xhcmFrIGlsacWfdGlyXHJcbiAgY29uc3QgZW1haWwgPSBtb2NrQ29udGFjdHNbY29udGFjdElkXT8uZW1haWwgfHwgJ3Byb3NwZWN0QGV4YW1wbGUuY29tJztcclxuICBjb25zdCB1cmwgPSBgJHtiYXNlfT9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9YDtcclxuICByZXR1cm4geyBvazogdHJ1ZSwgdXJsIH07XHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBjb21wdXRlIHN0YWdlIG5hbWUgZm9yIGEgZ2l2ZW4gc3RhZ2VfaWQgKHVzZWZ1bCBmb3IgVUkpXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZU5hbWUocGlwZWxpbmVJZDogc3RyaW5nLCBzdGFnZUlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xyXG4gIGNvbnN0IHN0YWdlcyA9IGF3YWl0IGdldFBpcGVsaW5lU3RhZ2VzKHBpcGVsaW5lSWQpO1xyXG4gIHJldHVybiBzdGFnZXMuZmluZCgocykgPT4gcy5pZCA9PT0gc3RhZ2VJZCk/Lm5hbWU7XHJcbn1cclxuXHJcbi8vIERlbW8tb25seSBoZWxwZXJzIHRvIGJyaWRnZSBtb2NrIHJlbGF0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udGFjdEZvckRlYWwoZGVhbElkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3QgfCB1bmRlZmluZWQ+IHtcclxuICBjb25zdCBjb250YWN0SWQgPSBkZWFsVG9Db250YWN0W2RlYWxJZF07XHJcbiAgaWYgKCFjb250YWN0SWQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgcmV0dXJuIGdldENvbnRhY3QoY29udGFjdElkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydGluZyBoZWxwZXJzIChTbmFwc2hvdCBNVlApXHJcbiAqIE5vdGU6IE1vY2sgaW1wbGVtZW50YXRpb24gdXNpbmcgaW4tbWVtb3J5IGRhdGE7IHJlcGxhY2Ugd2l0aCBTdXBhYmFzZS9FZGdlIHF1ZXJpZXMgbGF0ZXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVwbGllc0xhc3Q3ZCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3Qgc2luY2UgPSBEYXRlLm5vdygpIC0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcbiAgcmV0dXJuIG1vY2tBY3Rpdml0aWVzLmZpbHRlcigoYSkgPT4gYS50eXBlID09PSAnZW1haWxfaW4nICYmICtuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpID49IHNpbmNlKS5sZW5ndGg7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZURpc3RyaWJ1dGlvbihwaXBlbGluZUlkOiBzdHJpbmcpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGNvbnN0IGRpc3Q6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICBmb3IgKGNvbnN0IGQgb2YgbW9ja0RlYWxzKSB7XHJcbiAgICBpZiAoZC5waXBlbGluZV9pZCAhPT0gcGlwZWxpbmVJZCkgY29udGludWU7XHJcbiAgICBkaXN0W2Quc3RhZ2VfaWRdID0gKGRpc3RbZC5zdGFnZV9pZF0gfHwgMCkgKyAxO1xyXG4gIH1cclxuICByZXR1cm4gZGlzdDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNpbXBsZUNvbnZlcnNpb24ocGlwZWxpbmVJZDogc3RyaW5nKTogUHJvbWlzZTx7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgcmF0ZTogbnVtYmVyIHwgbnVsbCB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICAvLyBCYXNpdCBiaXIgb3JhbjogTmV3IC0+IFF1YWxpZmllZFxyXG4gIGNvbnN0IGZyb20gPSAnc19uZXcnO1xyXG4gIGNvbnN0IHRvID0gJ3NfcXVhbGlmaWVkJztcclxuICBjb25zdCBpbkZyb20gPSBtb2NrRGVhbHMuZmlsdGVyKChkKSA9PiBkLnBpcGVsaW5lX2lkID09PSBwaXBlbGluZUlkICYmIGQuc3RhZ2VfaWQgPT09IGZyb20pLmxlbmd0aDtcclxuICBjb25zdCBpblRvID0gbW9ja0RlYWxzLmZpbHRlcigoZCkgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCAmJiBkLnN0YWdlX2lkID09PSB0bykubGVuZ3RoO1xyXG4gIGNvbnN0IHJhdGUgPSBpbkZyb20gPiAwID8gTnVtYmVyKCgoaW5UbyAvIGluRnJvbSkgKiAxMDApLnRvRml4ZWQoMCkpIDogbnVsbDtcclxuICByZXR1cm4geyBmcm9tLCB0bywgcmF0ZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogU3ByaW50IDIg4oCUIERlYWxEZXRhaWwgaW5saW5lIGVkaXQgbW9jayBoZWxwZXIuXHJcbiAqIEdlcsOnZWsgZW50ZWdyYXN5b25kYSBQT1NUIC9jcm0vYWN0aW9ucy9kZWFscyDDp2HEn3LEsXPEsW5hIGTDtm7DvMWfZWNla3Rpci5cclxuICovXHJcbmV4cG9ydCB0eXBlIERlYWxVcGRhdGVJbnB1dCA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlPzogc3RyaW5nO1xyXG4gIGFtb3VudD86IG51bWJlcjtcclxuICBjdXJyZW5jeT86IHN0cmluZztcclxuICBjbG9zZV9kYXRlPzogc3RyaW5nOyAvLyBJU09cclxuICBzdGFnZV9pZD86IHN0cmluZztcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVEZWFsKGlucHV0OiBEZWFsVXBkYXRlSW5wdXQsIG9wdGlvbnM/OiB7IHNpbXVsYXRlRXJyb3I/OiBib29sZWFuIH0pOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyBkZWFsPzogRGVhbCB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBpZiAob3B0aW9ucz8uc2ltdWxhdGVFcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ1NpbXVsYXRlZCB1cGRhdGUgZXJyb3InIH07XHJcblxyXG4gIGNvbnN0IGlkeCA9IG1vY2tEZWFscy5maW5kSW5kZXgoKGQpID0+IGQuaWQgPT09IGlucHV0LmlkKTtcclxuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0RlYWwgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0gbW9ja0RlYWxzW2lkeF07XHJcbiAgLy8gYmFzaWMgdmFsaWRhdGlvblxyXG4gIGlmICh0eXBlb2YgaW5wdXQuYW1vdW50ICE9PSAndW5kZWZpbmVkJyAmJiBOdW1iZXIuaXNOYU4oTnVtYmVyKGlucHV0LmFtb3VudCkpKSB7XHJcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnQW1vdW50IG11c3QgYmUgbnVtZXJpYycgfTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBpbnB1dC5jbG9zZV9kYXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgY29uc3QgdCA9IERhdGUucGFyc2UoaW5wdXQuY2xvc2VfZGF0ZSk7XHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHQpKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnY2xvc2VfZGF0ZSBtdXN0IGJlIElTTyBzdHJpbmcnIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCBuZXh0OiBEZWFsID0ge1xyXG4gICAgLi4ucHJldixcclxuICAgIHRpdGxlOiBpbnB1dC50aXRsZSA/PyBwcmV2LnRpdGxlLFxyXG4gICAgYW1vdW50OiB0eXBlb2YgaW5wdXQuYW1vdW50ICE9PSAndW5kZWZpbmVkJyA/IE51bWJlcihpbnB1dC5hbW91bnQpIDogcHJldi5hbW91bnQsXHJcbiAgICBjdXJyZW5jeTogaW5wdXQuY3VycmVuY3kgPz8gcHJldi5jdXJyZW5jeSxcclxuICAgIGNsb3NlX2RhdGU6IGlucHV0LmNsb3NlX2RhdGUgPz8gcHJldi5jbG9zZV9kYXRlLFxyXG4gICAgc3RhZ2VfaWQ6IGlucHV0LnN0YWdlX2lkID8/IHByZXYuc3RhZ2VfaWQsXHJcbiAgfTtcclxuICBtb2NrRGVhbHNbaWR4XSA9IG5leHQ7XHJcblxyXG4gIC8vIGxvZyBhY3Rpdml0eVxyXG4gIGNvbnN0IGNoYW5nZWQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICBmb3IgKGNvbnN0IGsgb2YgWyd0aXRsZScsICdhbW91bnQnLCAnY3VycmVuY3knLCAnY2xvc2VfZGF0ZScsICdzdGFnZV9pZCddIGFzIGNvbnN0KSB7XHJcbiAgICBpZiAoKHByZXYgYXMgYW55KVtrXSAhPT0gKG5leHQgYXMgYW55KVtrXSkgY2hhbmdlZFtrXSA9IHsgZnJvbTogKHByZXYgYXMgYW55KVtrXSwgdG86IChuZXh0IGFzIGFueSlba10gfTtcclxuICB9XHJcbiAgbW9ja0FjdGl2aXRpZXMucHVzaCh7XHJcbiAgICBpZDogYGFfJHtEYXRlLm5vdygpfWAsXHJcbiAgICB0eXBlOiAnc3lzdGVtJyxcclxuICAgIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLFxyXG4gICAgcmVsYXRlZF9pZDogaW5wdXQuaWQsXHJcbiAgICBjb250ZW50OiAnRGVhbCB1cGRhdGVkJyxcclxuICAgIG1ldGFfanNvbjogeyBjaGFuZ2VkIH0sXHJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBkZWFsOiBuZXh0IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcHJpbnQgMiAtIMSwbGsgR8O2cmV2OiBLYW5iYW4gRHJhZyAmIERyb3Ag4oaSIFN0YWdlIENoYW5nZVxyXG4gKiBNb2NrIG9ydGFtZGEgb3B0aW1pc3RpYyBVSSBha8SxxZ/EsW7EsSBkb8SfcnVsYW1hayBpw6dpbiBzdGFnZSBnw7xuY2VsbGVtZSBoZWxwZXInxLEuXHJcbiAqIEdlcsOnZWsgZW50ZWdyYXN5b25kYSBidSBmb25rc2l5b24sIEVkZ2UgRnVuY3Rpb24nYSAoUE9TVCAvY3JtL2FjdGlvbnMvZGVhbHMvOmlkL3N0YWdlKSDDp2HEn3LEsSB5YXBhY2FrLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURlYWxTdGFnZShcclxuICBkZWFsSWQ6IHN0cmluZyxcclxuICBuZXh0U3RhZ2VJZDogc3RyaW5nLFxyXG4gIG9wdGlvbnM/OiB7IG9jY3VycmVkQXRJU08/OiBzdHJpbmc7IGlkZW1wb3RlbmN5S2V5Pzogc3RyaW5nOyBzaW11bGF0ZUVycm9yPzogYm9vbGVhbiB9XHJcbik6IFByb21pc2U8eyBvazogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmc7IGRlYWw/OiBEZWFsIH0+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGlmIChvcHRpb25zPy5zaW11bGF0ZUVycm9yKSB7XHJcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnU2ltdWxhdGVkIG5ldHdvcmsvc2VydmVyIGVycm9yJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaWR4ID0gbW9ja0RlYWxzLmZpbmRJbmRleCgoZCkgPT4gZC5pZCA9PT0gZGVhbElkKTtcclxuICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0RlYWwgbm90IGZvdW5kJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldiA9IG1vY2tEZWFsc1tpZHhdO1xyXG4gIGNvbnN0IG5leHQ6IERlYWwgPSB7IC4uLnByZXYsIHN0YWdlX2lkOiBuZXh0U3RhZ2VJZCB9O1xyXG4gIG1vY2tEZWFsc1tpZHhdID0gbmV4dDtcclxuXHJcbiAgLy8gU3lzdGVtIGFjdGl2aXR5IGluc2VydCAobW9jaylcclxuICBtb2NrQWN0aXZpdGllcy5wdXNoKHtcclxuICAgIGlkOiBgYV8ke0RhdGUubm93KCl9YCxcclxuICAgIHR5cGU6ICdzeXN0ZW0nLFxyXG4gICAgcmVsYXRlZF90eXBlOiAnZGVhbCcsXHJcbiAgICByZWxhdGVkX2lkOiBkZWFsSWQsXHJcbiAgICBjb250ZW50OiAnU3RhZ2UgY2hhbmdlZCcsXHJcbiAgICBtZXRhX2pzb246IHsgZnJvbTogcHJldi5zdGFnZV9pZCwgdG86IG5leHRTdGFnZUlkLCBvY2N1cnJlZF9hdDogb3B0aW9ucz8ub2NjdXJyZWRBdElTTyB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICAvLyBPdXRib3VuZCB3ZWJob29rIChsb2ctb25seSwgbW9jaylcclxuICAvLyBJbiByZWFsIGltcGw6IGZpcmUtYW5kLWZvcmdldCBQT1NUIHRvIG91dGJvdW5kIGVuZHBvaW50IHdpdGggZXZlbnRfdHlwZT1kZWFsX3N0YWdlX2NoYW5nZWRcclxuXHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIGRlYWw6IG5leHQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydGluZyAoTVZQLCBtb2NrKVxyXG4gKiAtIG9wZW4gZGVhbHMgY291bnRcclxuICogLSBsYXN0IDcgZGF5cyByZXBseSBjb3VudCAoZW1haWxfaW4pXHJcbiAqIC0gc2ltcGxlIHBpcGVsaW5lIGNvbnZlcnNpb24gKHN0YWdlLXRvLXN0YWdlIHJhdGlvcyB3aXRoaW4gY3VycmVudCBtb2NrIHNuYXBzaG90KVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9wZW5EZWFsc0NvdW50KHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgbGlzdCA9IHBpcGVsaW5lSWQgPyBtb2NrRGVhbHMuZmlsdGVyKGQgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCkgOiBtb2NrRGVhbHM7XHJcbiAgLy8gT3BlbiA9IG5vdCBXb24gYW5kIG5vdCBMb3N0XHJcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGQgPT4gZC5zdGFnZV9pZCAhPT0gJ3Nfd29uJyAmJiBkLnN0YWdlX2lkICE9PSAnc19sb3N0JykubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGFzdDdEYXlzUmVwbHlDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCBzZXZlbkRheXMgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuICByZXR1cm4gbW9ja0FjdGl2aXRpZXMuZmlsdGVyKGEgPT5cclxuICAgIGEudHlwZSA9PT0gJ2VtYWlsX2luJyAmJiAobm93IC0gK25ldyBEYXRlKGEuY3JlYXRlZF9hdCkpIDw9IHNldmVuRGF5c1xyXG4gICkubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQaXBlbGluZUNvbnZlcnNpb24gPSB7XHJcbiAgc3RhZ2VfaWQ6IHN0cmluZztcclxuICBzdGFnZV9uYW1lOiBzdHJpbmc7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICBjb252ZXJzaW9uX3RvX25leHQ/OiBudW1iZXI7IC8vIHBlcmNlbnQgWzAuLjEwMF1cclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQaXBlbGluZUNvbnZlcnNpb24ocGlwZWxpbmVJZDogc3RyaW5nID0gJ3BfZGVmYXVsdCcpOiBQcm9taXNlPFBpcGVsaW5lQ29udmVyc2lvbltdPiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBzdGFnZXMgPSBtb2NrU3RhZ2VzXHJcbiAgICAuZmlsdGVyKHMgPT4gcy5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZClcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCk7XHJcblxyXG4gIGNvbnN0IGJ5U3RhZ2VDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gIGZvciAoY29uc3QgcyBvZiBzdGFnZXMpIGJ5U3RhZ2VDb3VudFtzLmlkXSA9IDA7XHJcbiAgZm9yIChjb25zdCBkIG9mIG1vY2tEZWFscykge1xyXG4gICAgaWYgKGQucGlwZWxpbmVfaWQgIT09IHBpcGVsaW5lSWQpIGNvbnRpbnVlO1xyXG4gICAgaWYgKGJ5U3RhZ2VDb3VudFtkLnN0YWdlX2lkXSAhPT0gdW5kZWZpbmVkKSBieVN0YWdlQ291bnRbZC5zdGFnZV9pZF0gKz0gMTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdDogUGlwZWxpbmVDb252ZXJzaW9uW10gPSBzdGFnZXMubWFwKChzLCBpZHgpID0+IHtcclxuICAgIGNvbnN0IGNvdW50ID0gYnlTdGFnZUNvdW50W3MuaWRdIHx8IDA7XHJcbiAgICBsZXQgY29udmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlkeCA8IHN0YWdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGNvbnN0IG5leHRTdGFnZSA9IHN0YWdlc1tpZHggKyAxXTtcclxuICAgICAgY29uc3QgbmV4dENvdW50ID0gYnlTdGFnZUNvdW50W25leHRTdGFnZS5pZF0gfHwgMDtcclxuICAgICAgLy8gbmFpdmUgcmF0aW8gdXNpbmcgc25hcHNob3QgY291bnRzIChub3QgY29ob3J0LWJhc2VkKVxyXG4gICAgICBjb252ZXJzaW9uID0gY291bnQgPiAwID8gTWF0aC5yb3VuZCgobmV4dENvdW50IC8gY291bnQpICogMTAwKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHN0YWdlX2lkOiBzLmlkLCBzdGFnZV9uYW1lOiBzLm5hbWUsIGNvdW50LCBjb252ZXJzaW9uX3RvX25leHQ6IGNvbnZlcnNpb24gfTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4iXSwibmFtZXMiOlsiTU9DS19ERUxBWSIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsIm1vY2tTdGFnZXMiLCJpZCIsIm5hbWUiLCJvcmRlcl9pbmRleCIsInByb2JhYmlsaXR5IiwicGlwZWxpbmVfaWQiLCJtb2NrRGVhbHMiLCJ0aXRsZSIsInN0YWdlX2lkIiwiYW1vdW50IiwiY3VycmVuY3kiLCJzb3VyY2UiLCJtb2NrQ29udGFjdHMiLCJjMSIsImZ1bGxfbmFtZSIsImVtYWlsIiwibGlua2VkaW5fdXJsIiwid2Vic2l0ZSIsImMyIiwicmVwbHlfc3RhdHVzIiwicmVwbHlfc3VtbWFyeSIsIm1vY2tBY3Rpdml0aWVzIiwidHlwZSIsInJlbGF0ZWRfdHlwZSIsInJlbGF0ZWRfaWQiLCJjb250ZW50IiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsImRlYWxUb0NvbnRhY3QiLCJkMSIsImQyIiwiZDMiLCJnZXRQaXBlbGluZVN0YWdlcyIsInBpcGVsaW5lSWQiLCJmaWx0ZXIiLCJzIiwic29ydCIsImEiLCJiIiwiZ2V0RGVhbHNCeVBpcGVsaW5lIiwiZCIsImdldERlYWxEZXRhaWwiLCJkZWFsIiwiZmluZCIsIkVycm9yIiwiZ2V0QWN0aXZpdGllc0ZvciIsInJlbGF0ZWRUeXBlIiwicmVsYXRlZElkIiwiZ2V0Q29udGFjdCIsImMiLCJ1cGRhdGVDb250YWN0U3RhdHVzIiwiY29udGFjdElkIiwic3RhdHVzIiwib2siLCJlcnJvciIsInByZXYiLCJwdXNoIiwibWV0YV9qc29uIiwiZnJvbSIsInRvIiwiY29udGFjdCIsImdldENhbGVuZGFyTGluayIsImJhc2UiLCJ1cmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRTdGFnZU5hbWUiLCJzdGFnZUlkIiwic3RhZ2VzIiwiZ2V0Q29udGFjdEZvckRlYWwiLCJkZWFsSWQiLCJ1bmRlZmluZWQiLCJnZXRSZXBsaWVzTGFzdDdkIiwic2luY2UiLCJsZW5ndGgiLCJnZXRTdGFnZURpc3RyaWJ1dGlvbiIsImRpc3QiLCJnZXRTaW1wbGVDb252ZXJzaW9uIiwiaW5Gcm9tIiwiaW5UbyIsInJhdGUiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwidXBkYXRlRGVhbCIsImlucHV0Iiwib3B0aW9ucyIsInNpbXVsYXRlRXJyb3IiLCJpZHgiLCJmaW5kSW5kZXgiLCJpc05hTiIsImNsb3NlX2RhdGUiLCJ0IiwicGFyc2UiLCJuZXh0IiwiY2hhbmdlZCIsImsiLCJ1cGRhdGVEZWFsU3RhZ2UiLCJuZXh0U3RhZ2VJZCIsIm9jY3VycmVkX2F0Iiwib2NjdXJyZWRBdElTTyIsImdldE9wZW5EZWFsc0NvdW50IiwibGlzdCIsImdldExhc3Q3RGF5c1JlcGx5Q291bnQiLCJzZXZlbkRheXMiLCJnZXRQaXBlbGluZUNvbnZlcnNpb24iLCJieVN0YWdlQ291bnQiLCJyZXN1bHQiLCJtYXAiLCJjb3VudCIsImNvbnZlcnNpb24iLCJuZXh0U3RhZ2UiLCJuZXh0Q291bnQiLCJNYXRoIiwicm91bmQiLCJzdGFnZV9uYW1lIiwiY29udmVyc2lvbl90b19uZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});