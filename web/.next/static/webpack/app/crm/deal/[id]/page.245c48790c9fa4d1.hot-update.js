"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/deal/[id]/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getRepliesLast7d: function() { return /* binding */ getRepliesLast7d; },\n/* harmony export */   getSimpleConversion: function() { return /* binding */ getSimpleConversion; },\n/* harmony export */   getStageDistribution: function() { return /* binding */ getStageDistribution; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDeal: function() { return /* binding */ updateDeal; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\r\n * Read-only CRM API helpers (MVP skeleton).\r\n * Implementation note:\r\n * - Start with mock/placeholder implementations.\r\n * - Replace with Supabase client or backend proxy once auth/RLS strategy is set.\r\n */ const MOCK_DELAY = 150;\nfunction sleep() {\n    let ms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MOCK_DELAY;\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\r\n * Edge Actions HTTP helpers (MVP)\r\n * Switchable via NEXT_PUBLIC_CRM_API_BASE:\r\n * - If defined: real Edge endpoint calls\r\n * - If not defined: fallback to mock in-memory behavior\r\n */ function getApiBase() {\n    var _process_env;\n    // e.g. http://localhost:8000 or / (if proxied)\n    if (typeof process !== \"undefined\" && ((_process_env = process.env) === null || _process_env === void 0 ? void 0 : _process_env.NEXT_PUBLIC_CRM_API_BASE)) {\n        return process.env.NEXT_PUBLIC_CRM_API_BASE;\n    }\n    return null;\n}\nasync function getAuthToken() {\n    // TODO: integrate with Supabase/NextAuth. For now, return null (no Authorization header).\n    return null;\n}\nasync function apiRequest(path) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const base = getApiBase();\n    if (!base) {\n        // no base configured → fallback inform caller to use mocks\n        return {\n            ok: false,\n            status: 0,\n            error: \"API base not configured (using mock fallback)\"\n        };\n    }\n    const url = path.startsWith(\"http\") ? path : \"\".concat(base.replace(/\\/+$/, \"\"), \"/\").concat(path.replace(/^\\/+/, \"\"));\n    const token = await getAuthToken();\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        ...opts.headers || {}\n    };\n    if (token) headers[\"Authorization\"] = \"Bearer \".concat(token);\n    if (opts.idempotencyKey) headers[\"Idempotency-Key\"] = opts.idempotencyKey;\n    const res = await fetch(url, {\n        method: opts.method || \"POST\",\n        headers,\n        body: typeof opts.body !== \"undefined\" ? JSON.stringify(opts.body) : undefined\n    });\n    let payload = undefined;\n    try {\n        payload = await res.json();\n    } catch (e) {\n    // ignore body parse errors\n    }\n    if (!res.ok) {\n        const msg = typeof (payload === null || payload === void 0 ? void 0 : payload.error) === \"string\" ? payload.error : \"HTTP \".concat(res.status);\n        return {\n            ok: false,\n            status: res.status,\n            error: msg\n        };\n    }\n    return {\n        ok: true,\n        status: res.status,\n        data: payload\n    };\n    return mockActivities.filter((a)=>a.related_type === relatedType && a.related_id === relatedId).sort((a, b)=>+new Date(b.created_at) - +new Date(a.created_at));\n}\nasync function getContact(id) {\n    // TODO: Replace with Supabase select contacts by id\n    await sleep();\n    const c = mockContacts[id];\n    if (!c) throw new Error(\"Contact not found\");\n    return c;\n}\n/**\r\n * Sprint 2 — ContactQuick actions: interested / not_interested toggle\r\n * Gerçek entegrasyonda POST /crm/actions/contacts çağrısına dönüşecektir.\r\n */ async function updateContactStatus(contactId, status) {\n    await sleep();\n    const c = mockContacts[contactId];\n    if (!c) return {\n        ok: false,\n        error: \"Contact not found\"\n    };\n    const prev = {\n        ...c\n    };\n    c.reply_status = status;\n    // Log activity\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"contact\",\n        related_id: contactId,\n        content: \"Contact status changed\",\n        meta_json: {\n            from: prev.reply_status,\n            to: status\n        },\n        created_at: new Date().toISOString()\n    });\n    // Outbound webhook (log-only, mock)\n    // In real impl: fire-and-forget POST with event_type=contact_status_changed\n    return {\n        ok: true,\n        contact: c\n    };\n}\n/**\r\n * Sprint 2 — ContactQuick actions: send calendar link (placeholder)\r\n * S2: yalnızca link üretip döndürür; S3: gerçek e-posta/mesaj otomasyonu.\r\n */ async function getCalendarLink(contactId) {\n    var _mockContacts_contactId;\n    await sleep();\n    const base = \"https://cal.com/your-team/30min\";\n    // basitçe kişi e-postasını query olarak iliştir\n    const email = ((_mockContacts_contactId = mockContacts[contactId]) === null || _mockContacts_contactId === void 0 ? void 0 : _mockContacts_contactId.email) || \"prospect@example.com\";\n    const url = \"\".concat(base, \"?email=\").concat(encodeURIComponent(email));\n    return {\n        ok: true,\n        url\n    };\n}\n// Helper to compute stage name for a given stage_id (useful for UI)\nasync function getStageName(pipelineId, stageId) {\n    var _stages_find;\n    const stages = await getPipelineStages(pipelineId);\n    return (_stages_find = stages.find((s)=>s.id === stageId)) === null || _stages_find === void 0 ? void 0 : _stages_find.name;\n}\n// Demo-only helpers to bridge mock relations\nasync function getContactForDeal(dealId) {\n    const contactId = dealToContact[dealId];\n    if (!contactId) return undefined;\n    return getContact(contactId);\n}\n/**\r\n * Reporting helpers (Snapshot MVP)\r\n * Note: Mock implementation using in-memory data; replace with Supabase/Edge queries later.\r\n */ async function getRepliesLast7d() {\n    await sleep();\n    const since = Date.now() - 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && +new Date(a.created_at) >= since).length;\n}\nasync function getStageDistribution(pipelineId) {\n    await sleep();\n    const dist = {};\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        dist[d.stage_id] = (dist[d.stage_id] || 0) + 1;\n    }\n    return dist;\n}\nasync function getSimpleConversion(pipelineId) {\n    await sleep();\n    // Basit bir oran: New -> Qualified\n    const from = \"s_new\";\n    const to = \"s_qualified\";\n    const inFrom = mockDeals.filter((d)=>d.pipeline_id === pipelineId && d.stage_id === from).length;\n    const inTo = mockDeals.filter((d)=>d.pipeline_id === pipelineId && d.stage_id === to).length;\n    const rate = inFrom > 0 ? Number((inTo / inFrom * 100).toFixed(0)) : null;\n    return {\n        from,\n        to,\n        rate\n    };\n}\nasync function updateDeal(input, options) {\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) return {\n        ok: false,\n        error: \"Simulated update error\"\n    };\n    const idx = mockDeals.findIndex((d)=>d.id === input.id);\n    if (idx === -1) return {\n        ok: false,\n        error: \"Deal not found\"\n    };\n    const prev = mockDeals[idx];\n    // basic validation\n    if (typeof input.amount !== \"undefined\" && Number.isNaN(Number(input.amount))) {\n        return {\n            ok: false,\n            error: \"Amount must be numeric\"\n        };\n    }\n    if (typeof input.close_date !== \"undefined\") {\n        const t = Date.parse(input.close_date);\n        if (Number.isNaN(t)) return {\n            ok: false,\n            error: \"close_date must be ISO string\"\n        };\n    }\n    var _input_title, _input_currency, _input_close_date, _input_stage_id;\n    const next = {\n        ...prev,\n        title: (_input_title = input.title) !== null && _input_title !== void 0 ? _input_title : prev.title,\n        amount: typeof input.amount !== \"undefined\" ? Number(input.amount) : prev.amount,\n        currency: (_input_currency = input.currency) !== null && _input_currency !== void 0 ? _input_currency : prev.currency,\n        close_date: (_input_close_date = input.close_date) !== null && _input_close_date !== void 0 ? _input_close_date : prev.close_date,\n        stage_id: (_input_stage_id = input.stage_id) !== null && _input_stage_id !== void 0 ? _input_stage_id : prev.stage_id\n    };\n    mockDeals[idx] = next;\n    // log activity\n    const changed = {};\n    for (const k of [\n        \"title\",\n        \"amount\",\n        \"currency\",\n        \"close_date\",\n        \"stage_id\"\n    ]){\n        if (prev[k] !== next[k]) changed[k] = {\n            from: prev[k],\n            to: next[k]\n        };\n    }\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: input.id,\n        content: \"Deal updated\",\n        meta_json: {\n            changed\n        },\n        created_at: new Date().toISOString()\n    });\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Sprint 2 - İlk Görev: Kanban Drag & Drop → Stage Change\r\n * Mock ortamda optimistic UI akışını doğrulamak için stage güncelleme helper'ı.\r\n * Gerçek entegrasyonda bu fonksiyon, Edge Function'a (POST /crm/actions/deals/:id/stage) çağrı yapacak.\r\n */ async function updateDealStage(dealId, nextStageId, options) {\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) {\n        return {\n            ok: false,\n            error: \"Simulated network/server error\"\n        };\n    }\n    const idx = mockDeals.findIndex((d)=>d.id === dealId);\n    if (idx === -1) {\n        return {\n            ok: false,\n            error: \"Deal not found\"\n        };\n    }\n    const prev = mockDeals[idx];\n    const next = {\n        ...prev,\n        stage_id: nextStageId\n    };\n    mockDeals[idx] = next;\n    // System activity insert (mock)\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: dealId,\n        content: \"Stage changed\",\n        meta_json: {\n            from: prev.stage_id,\n            to: nextStageId,\n            occurred_at: options === null || options === void 0 ? void 0 : options.occurredAtISO\n        },\n        created_at: new Date().toISOString()\n    });\n    // Outbound webhook (log-only, mock)\n    // In real impl: fire-and-forget POST to outbound endpoint with event_type=deal_stage_changed\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Reporting (MVP, mock)\r\n * - open deals count\r\n * - last 7 days reply count (email_in)\r\n * - simple pipeline conversion (stage-to-stage ratios within current mock snapshot)\r\n */ async function getOpenDealsCount(pipelineId) {\n    await sleep();\n    const list = pipelineId ? mockDeals.filter((d)=>d.pipeline_id === pipelineId) : mockDeals;\n    // Open = not Won and not Lost\n    return list.filter((d)=>d.stage_id !== \"s_won\" && d.stage_id !== \"s_lost\").length;\n}\nasync function getLast7DaysReplyCount() {\n    await sleep();\n    const now = Date.now();\n    const sevenDays = 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && now - +new Date(a.created_at) <= sevenDays).length;\n}\nasync function getPipelineConversion() {\n    let pipelineId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"p_default\";\n    await sleep();\n    const stages = mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n    const byStageCount = {};\n    for (const s of stages)byStageCount[s.id] = 0;\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        if (byStageCount[d.stage_id] !== undefined) byStageCount[d.stage_id] += 1;\n    }\n    const result = stages.map((s, idx)=>{\n        const count = byStageCount[s.id] || 0;\n        let conversion = undefined;\n        if (idx < stages.length - 1) {\n            const nextStage = stages[idx + 1];\n            const nextCount = byStageCount[nextStage.id] || 0;\n            // naive ratio using snapshot counts (not cohort-based)\n            conversion = count > 0 ? Math.round(nextCount / count * 100) : undefined;\n        }\n        return {\n            stage_id: s.id,\n            stage_name: s.name,\n            count,\n            conversion_to_next: conversion\n        };\n    });\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQXNDRCxNQUFNQSxhQUFhO0FBRW5CLFNBQVNDO1FBQU1DLEtBQUFBLGlFQUFLRjtJQUNsQixPQUFPLElBQUlHLFFBQVEsQ0FBQ0MsTUFBUUMsV0FBV0QsS0FBS0Y7QUFDOUM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNJO1FBRStCQztJQUR0QywrQ0FBK0M7SUFDL0MsSUFBSSxPQUFPQSxPQUFPQSxLQUFLLGlCQUFlQSxlQUFBQSxRQUFRQyxHQUFHLGNBQVhELG1DQUFBQSxhQUFhRSx3QkFBd0IsR0FBRTtRQUMzRSxPQUFPRixPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHdCQUF3QjtJQUM3QztJQUNBLE9BQU87QUFDVDtBQUVBLGVBQWVDO0lBQ2IsMEZBQTBGO0lBQzFGLE9BQU87QUFDVDtBQVNBLGVBQWVDLFdBQW9CQyxJQUFZO1FBQUVDLE9BQUFBLGlFQUF1QixDQUFDO0lBQ3ZFLE1BQU1DLE9BQU9SO0lBQ2IsSUFBSSxDQUFDUSxNQUFNO1FBQ1QsMkRBQTJEO1FBQzNELE9BQU87WUFBRUMsSUFBSTtZQUFPQyxRQUFRO1lBQUdDLE9BQU87UUFBZ0Q7SUFDeEY7SUFDQSxNQUFNQyxNQUFNTixLQUFLTyxVQUFVLENBQUMsVUFBVVAsT0FBTyxHQUErQkEsT0FBNUJFLEtBQUtNLE9BQU8sQ0FBQyxRQUFRLEtBQUksS0FBNEIsT0FBekJSLEtBQUtRLE9BQU8sQ0FBQyxRQUFRO0lBQ2pHLE1BQU1DLFFBQVEsTUFBTVg7SUFDcEIsTUFBTVksVUFBa0M7UUFDdEMsZ0JBQWdCO1FBQ2hCLEdBQUlULEtBQUtTLE9BQU8sSUFBSSxDQUFDLENBQUM7SUFDeEI7SUFDQSxJQUFJRCxPQUFPQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsVUFBZ0IsT0FBTkQ7SUFDaEQsSUFBSVIsS0FBS1UsY0FBYyxFQUFFRCxPQUFPLENBQUMsa0JBQWtCLEdBQUdULEtBQUtVLGNBQWM7SUFFekUsTUFBTW5CLE1BQU0sTUFBTW9CLE1BQU1OLEtBQUs7UUFDM0JPLFFBQVFaLEtBQUtZLE1BQU0sSUFBSTtRQUN2Qkg7UUFDQUksTUFBTSxPQUFPYixLQUFLYSxJQUFJLEtBQUssY0FBY0MsS0FBS0MsU0FBUyxDQUFDZixLQUFLYSxJQUFJLElBQUlHO0lBQ3ZFO0lBRUEsSUFBSUMsVUFBZUQ7SUFDbkIsSUFBSTtRQUNGQyxVQUFVLE1BQU0xQixJQUFJMkIsSUFBSTtJQUMxQixFQUFFLFVBQU07SUFDTiwyQkFBMkI7SUFDN0I7SUFDQSxJQUFJLENBQUMzQixJQUFJVyxFQUFFLEVBQUU7UUFDWCxNQUFNaUIsTUFBTSxRQUFPRixvQkFBQUEsOEJBQUFBLFFBQVNiLEtBQUssTUFBSyxXQUFXYSxRQUFRYixLQUFLLEdBQUcsUUFBbUIsT0FBWGIsSUFBSVksTUFBTTtRQUNuRixPQUFPO1lBQUVELElBQUk7WUFBT0MsUUFBUVosSUFBSVksTUFBTTtZQUFFQyxPQUFPZTtRQUFJO0lBQ3JEO0lBQ0EsT0FBTztRQUFFakIsSUFBSTtRQUFNQyxRQUFRWixJQUFJWSxNQUFNO1FBQUVpQixNQUFNSDtJQUFRO0lBQ3JELE9BQU9JLGVBQWVDLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxZQUFZLEtBQUtDLGVBQWVGLEVBQUVHLFVBQVUsS0FBS0MsV0FDcEZDLElBQUksQ0FBQyxDQUFDTCxHQUFHTSxJQUFNLENBQUMsSUFBSUMsS0FBS0QsRUFBRUUsVUFBVSxJQUFJLENBQUMsSUFBSUQsS0FBS1AsRUFBRVEsVUFBVTtBQUNwRTtBQUVPLGVBQWVDLFdBQVdDLEVBQVU7SUFDekMsb0RBQW9EO0lBQ3BELE1BQU03QztJQUNOLE1BQU04QyxJQUFJQyxZQUFZLENBQUNGLEdBQUc7SUFDMUIsSUFBSSxDQUFDQyxHQUFHLE1BQU0sSUFBSUUsTUFBTTtJQUN4QixPQUFPRjtBQUNUO0FBRUE7OztDQUdDLEdBQ00sZUFBZUcsb0JBQ3BCQyxTQUFpQixFQUNqQm5DLE1BQXVDO0lBRXZDLE1BQU1mO0lBQ04sTUFBTThDLElBQUlDLFlBQVksQ0FBQ0csVUFBVTtJQUNqQyxJQUFJLENBQUNKLEdBQUcsT0FBTztRQUFFaEMsSUFBSTtRQUFPRSxPQUFPO0lBQW9CO0lBRXZELE1BQU1tQyxPQUFPO1FBQUUsR0FBR0wsQ0FBQztJQUFDO0lBQ3BCQSxFQUFFTSxZQUFZLEdBQUdyQztJQUVqQixlQUFlO0lBQ2ZrQixlQUFlb0IsSUFBSSxDQUFDO1FBQ2xCUixJQUFJLEtBQWdCLE9BQVhILEtBQUtZLEdBQUc7UUFDakJDLE1BQU07UUFDTm5CLGNBQWM7UUFDZEUsWUFBWVk7UUFDWk0sU0FBUztRQUNUQyxXQUFXO1lBQUVDLE1BQU1QLEtBQUtDLFlBQVk7WUFBRU8sSUFBSTVDO1FBQU87UUFDakQ0QixZQUFZLElBQUlELE9BQU9rQixXQUFXO0lBQ3BDO0lBRUEsb0NBQW9DO0lBQ3BDLDRFQUE0RTtJQUU1RSxPQUFPO1FBQUU5QyxJQUFJO1FBQU0rQyxTQUFTZjtJQUFFO0FBQ2hDO0FBRUE7OztDQUdDLEdBQ00sZUFBZWdCLGdCQUFnQlosU0FBaUI7UUFJdkNIO0lBSGQsTUFBTS9DO0lBQ04sTUFBTWEsT0FBTztJQUNiLGdEQUFnRDtJQUNoRCxNQUFNa0QsUUFBUWhCLEVBQUFBLDBCQUFBQSxZQUFZLENBQUNHLFVBQVUsY0FBdkJILDhDQUFBQSx3QkFBeUJnQixLQUFLLEtBQUk7SUFDaEQsTUFBTTlDLE1BQU0sR0FBaUIrQyxPQUFkbkQsTUFBSyxXQUFtQyxPQUExQm1ELG1CQUFtQkQ7SUFDaEQsT0FBTztRQUFFakQsSUFBSTtRQUFNRztJQUFJO0FBQ3pCO0FBRUEsb0VBQW9FO0FBQzdELGVBQWVnRCxhQUFhQyxVQUFrQixFQUFFQyxPQUFlO1FBRTdEQztJQURQLE1BQU1BLFNBQVMsTUFBTUMsa0JBQWtCSDtJQUN2QyxRQUFPRSxlQUFBQSxPQUFPRSxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRTFCLEVBQUUsS0FBS3NCLHNCQUE1QkMsbUNBQUFBLGFBQXNDSSxJQUFJO0FBQ25EO0FBRUEsNkNBQTZDO0FBQ3RDLGVBQWVDLGtCQUFrQkMsTUFBYztJQUNwRCxNQUFNeEIsWUFBWXlCLGFBQWEsQ0FBQ0QsT0FBTztJQUN2QyxJQUFJLENBQUN4QixXQUFXLE9BQU90QjtJQUN2QixPQUFPZ0IsV0FBV007QUFDcEI7QUFFQTs7O0NBR0MsR0FDTSxlQUFlMEI7SUFDcEIsTUFBTTVFO0lBQ04sTUFBTTZFLFFBQVFuQyxLQUFLWSxHQUFHLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSztJQUM5QyxPQUFPckIsZUFBZUMsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVvQixJQUFJLEtBQUssY0FBYyxDQUFDLElBQUliLEtBQUtQLEVBQUVRLFVBQVUsS0FBS2tDLE9BQU9DLE1BQU07QUFDdkc7QUFFTyxlQUFlQyxxQkFBcUJiLFVBQWtCO0lBQzNELE1BQU1sRTtJQUNOLE1BQU1nRixPQUErQixDQUFDO0lBQ3RDLEtBQUssTUFBTUMsS0FBS0MsVUFBVztRQUN6QixJQUFJRCxFQUFFRSxXQUFXLEtBQUtqQixZQUFZO1FBQ2xDYyxJQUFJLENBQUNDLEVBQUVHLFFBQVEsQ0FBQyxHQUFHLENBQUNKLElBQUksQ0FBQ0MsRUFBRUcsUUFBUSxDQUFDLElBQUksS0FBSztJQUMvQztJQUNBLE9BQU9KO0FBQ1Q7QUFFTyxlQUFlSyxvQkFBb0JuQixVQUFrQjtJQUMxRCxNQUFNbEU7SUFDTixtQ0FBbUM7SUFDbkMsTUFBTTBELE9BQU87SUFDYixNQUFNQyxLQUFLO0lBQ1gsTUFBTTJCLFNBQVNKLFVBQVVoRCxNQUFNLENBQUMsQ0FBQytDLElBQU1BLEVBQUVFLFdBQVcsS0FBS2pCLGNBQWNlLEVBQUVHLFFBQVEsS0FBSzFCLE1BQU1vQixNQUFNO0lBQ2xHLE1BQU1TLE9BQU9MLFVBQVVoRCxNQUFNLENBQUMsQ0FBQytDLElBQU1BLEVBQUVFLFdBQVcsS0FBS2pCLGNBQWNlLEVBQUVHLFFBQVEsS0FBS3pCLElBQUltQixNQUFNO0lBQzlGLE1BQU1VLE9BQU9GLFNBQVMsSUFBSUcsT0FBTyxDQUFDLE9BQVFILFNBQVUsR0FBRSxFQUFHSSxPQUFPLENBQUMsTUFBTTtJQUN2RSxPQUFPO1FBQUVoQztRQUFNQztRQUFJNkI7SUFBSztBQUMxQjtBQWVPLGVBQWVHLFdBQVdDLEtBQXNCLEVBQUVDLE9BQXFDO0lBQzVGLE1BQU03RjtJQUNOLElBQUk2RixvQkFBQUEsOEJBQUFBLFFBQVNDLGFBQWEsRUFBRSxPQUFPO1FBQUVoRixJQUFJO1FBQU9FLE9BQU87SUFBeUI7SUFFaEYsTUFBTStFLE1BQU1iLFVBQVVjLFNBQVMsQ0FBQyxDQUFDZixJQUFNQSxFQUFFcEMsRUFBRSxLQUFLK0MsTUFBTS9DLEVBQUU7SUFDeEQsSUFBSWtELFFBQVEsQ0FBQyxHQUFHLE9BQU87UUFBRWpGLElBQUk7UUFBT0UsT0FBTztJQUFpQjtJQUU1RCxNQUFNbUMsT0FBTytCLFNBQVMsQ0FBQ2EsSUFBSTtJQUMzQixtQkFBbUI7SUFDbkIsSUFBSSxPQUFPSCxNQUFNSyxNQUFNLEtBQUssZUFBZVIsT0FBT1MsS0FBSyxDQUFDVCxPQUFPRyxNQUFNSyxNQUFNLElBQUk7UUFDN0UsT0FBTztZQUFFbkYsSUFBSTtZQUFPRSxPQUFPO1FBQXlCO0lBQ3REO0lBQ0EsSUFBSSxPQUFPNEUsTUFBTU8sVUFBVSxLQUFLLGFBQWE7UUFDM0MsTUFBTUMsSUFBSTFELEtBQUsyRCxLQUFLLENBQUNULE1BQU1PLFVBQVU7UUFDckMsSUFBSVYsT0FBT1MsS0FBSyxDQUFDRSxJQUFJLE9BQU87WUFBRXRGLElBQUk7WUFBT0UsT0FBTztRQUFnQztJQUNsRjtRQUlTNEUsY0FFR0EsaUJBQ0VBLG1CQUNGQTtJQU5aLE1BQU1VLE9BQWE7UUFDakIsR0FBR25ELElBQUk7UUFDUG9ELE9BQU9YLENBQUFBLGVBQUFBLE1BQU1XLEtBQUssY0FBWFgsMEJBQUFBLGVBQWV6QyxLQUFLb0QsS0FBSztRQUNoQ04sUUFBUSxPQUFPTCxNQUFNSyxNQUFNLEtBQUssY0FBY1IsT0FBT0csTUFBTUssTUFBTSxJQUFJOUMsS0FBSzhDLE1BQU07UUFDaEZPLFVBQVVaLENBQUFBLGtCQUFBQSxNQUFNWSxRQUFRLGNBQWRaLDZCQUFBQSxrQkFBa0J6QyxLQUFLcUQsUUFBUTtRQUN6Q0wsWUFBWVAsQ0FBQUEsb0JBQUFBLE1BQU1PLFVBQVUsY0FBaEJQLCtCQUFBQSxvQkFBb0J6QyxLQUFLZ0QsVUFBVTtRQUMvQ2YsVUFBVVEsQ0FBQUEsa0JBQUFBLE1BQU1SLFFBQVEsY0FBZFEsNkJBQUFBLGtCQUFrQnpDLEtBQUtpQyxRQUFRO0lBQzNDO0lBQ0FGLFNBQVMsQ0FBQ2EsSUFBSSxHQUFHTztJQUVqQixlQUFlO0lBQ2YsTUFBTUcsVUFBK0IsQ0FBQztJQUN0QyxLQUFLLE1BQU1DLEtBQUs7UUFBQztRQUFTO1FBQVU7UUFBWTtRQUFjO0tBQVcsQ0FBVztRQUNsRixJQUFJLElBQWEsQ0FBQ0EsRUFBRSxLQUFLLElBQWEsQ0FBQ0EsRUFBRSxFQUFFRCxPQUFPLENBQUNDLEVBQUUsR0FBRztZQUFFaEQsTUFBTSxJQUFhLENBQUNnRCxFQUFFO1lBQUUvQyxJQUFJLElBQWEsQ0FBQytDLEVBQUU7UUFBQztJQUN6RztJQUNBekUsZUFBZW9CLElBQUksQ0FBQztRQUNsQlIsSUFBSSxLQUFnQixPQUFYSCxLQUFLWSxHQUFHO1FBQ2pCQyxNQUFNO1FBQ05uQixjQUFjO1FBQ2RFLFlBQVlzRCxNQUFNL0MsRUFBRTtRQUNwQlcsU0FBUztRQUNUQyxXQUFXO1lBQUVnRDtRQUFRO1FBQ3JCOUQsWUFBWSxJQUFJRCxPQUFPa0IsV0FBVztJQUNwQztJQUVBLE9BQU87UUFBRTlDLElBQUk7UUFBTTZGLE1BQU1MO0lBQUs7QUFDaEM7QUFFQTs7OztDQUlDLEdBQ00sZUFBZU0sZ0JBQ3BCbEMsTUFBYyxFQUNkbUMsV0FBbUIsRUFDbkJoQixPQUFzRjtJQUV0RixNQUFNN0Y7SUFDTixJQUFJNkYsb0JBQUFBLDhCQUFBQSxRQUFTQyxhQUFhLEVBQUU7UUFDMUIsT0FBTztZQUFFaEYsSUFBSTtZQUFPRSxPQUFPO1FBQWlDO0lBQzlEO0lBRUEsTUFBTStFLE1BQU1iLFVBQVVjLFNBQVMsQ0FBQyxDQUFDZixJQUFNQSxFQUFFcEMsRUFBRSxLQUFLNkI7SUFDaEQsSUFBSXFCLFFBQVEsQ0FBQyxHQUFHO1FBQ2QsT0FBTztZQUFFakYsSUFBSTtZQUFPRSxPQUFPO1FBQWlCO0lBQzlDO0lBRUEsTUFBTW1DLE9BQU8rQixTQUFTLENBQUNhLElBQUk7SUFDM0IsTUFBTU8sT0FBYTtRQUFFLEdBQUduRCxJQUFJO1FBQUVpQyxVQUFVeUI7SUFBWTtJQUNwRDNCLFNBQVMsQ0FBQ2EsSUFBSSxHQUFHTztJQUVqQixnQ0FBZ0M7SUFDaENyRSxlQUFlb0IsSUFBSSxDQUFDO1FBQ2xCUixJQUFJLEtBQWdCLE9BQVhILEtBQUtZLEdBQUc7UUFDakJDLE1BQU07UUFDTm5CLGNBQWM7UUFDZEUsWUFBWW9DO1FBQ1psQixTQUFTO1FBQ1RDLFdBQVc7WUFBRUMsTUFBTVAsS0FBS2lDLFFBQVE7WUFBRXpCLElBQUlrRDtZQUFhQyxXQUFXLEVBQUVqQixvQkFBQUEsOEJBQUFBLFFBQVNrQixhQUFhO1FBQUM7UUFDdkZwRSxZQUFZLElBQUlELE9BQU9rQixXQUFXO0lBQ3BDO0lBRUEsb0NBQW9DO0lBQ3BDLDZGQUE2RjtJQUU3RixPQUFPO1FBQUU5QyxJQUFJO1FBQU02RixNQUFNTDtJQUFLO0FBQ2hDO0FBRUE7Ozs7O0NBS0MsR0FDTSxlQUFlVSxrQkFBa0I5QyxVQUFtQjtJQUN6RCxNQUFNbEU7SUFDTixNQUFNaUgsT0FBTy9DLGFBQWFnQixVQUFVaEQsTUFBTSxDQUFDK0MsQ0FBQUEsSUFBS0EsRUFBRUUsV0FBVyxLQUFLakIsY0FBY2dCO0lBQ2hGLDhCQUE4QjtJQUM5QixPQUFPK0IsS0FBSy9FLE1BQU0sQ0FBQytDLENBQUFBLElBQUtBLEVBQUVHLFFBQVEsS0FBSyxXQUFXSCxFQUFFRyxRQUFRLEtBQUssVUFBVU4sTUFBTTtBQUNuRjtBQUVPLGVBQWVvQztJQUNwQixNQUFNbEg7SUFDTixNQUFNc0QsTUFBTVosS0FBS1ksR0FBRztJQUNwQixNQUFNNkQsWUFBWSxJQUFJLEtBQUssS0FBSyxLQUFLO0lBQ3JDLE9BQU9sRixlQUFlQyxNQUFNLENBQUNDLENBQUFBLElBQzNCQSxFQUFFb0IsSUFBSSxLQUFLLGNBQWMsTUFBTyxDQUFDLElBQUliLEtBQUtQLEVBQUVRLFVBQVUsS0FBTXdFLFdBQzVEckMsTUFBTTtBQUNWO0FBU08sZUFBZXNDO1FBQXNCbEQsYUFBQUEsaUVBQXFCO0lBQy9ELE1BQU1sRTtJQUNOLE1BQU1vRSxTQUFTaUQsV0FDWm5GLE1BQU0sQ0FBQ3FDLENBQUFBLElBQUtBLEVBQUVZLFdBQVcsS0FBS2pCLFlBQzlCMUIsSUFBSSxDQUFDLENBQUNMLEdBQUdNLElBQU1OLEVBQUVtRixXQUFXLEdBQUc3RSxFQUFFNkUsV0FBVztJQUUvQyxNQUFNQyxlQUF1QyxDQUFDO0lBQzlDLEtBQUssTUFBTWhELEtBQUtILE9BQVFtRCxZQUFZLENBQUNoRCxFQUFFMUIsRUFBRSxDQUFDLEdBQUc7SUFDN0MsS0FBSyxNQUFNb0MsS0FBS0MsVUFBVztRQUN6QixJQUFJRCxFQUFFRSxXQUFXLEtBQUtqQixZQUFZO1FBQ2xDLElBQUlxRCxZQUFZLENBQUN0QyxFQUFFRyxRQUFRLENBQUMsS0FBS3hELFdBQVcyRixZQUFZLENBQUN0QyxFQUFFRyxRQUFRLENBQUMsSUFBSTtJQUMxRTtJQUVBLE1BQU1vQyxTQUErQnBELE9BQU9xRCxHQUFHLENBQUMsQ0FBQ2xELEdBQUd3QjtRQUNsRCxNQUFNMkIsUUFBUUgsWUFBWSxDQUFDaEQsRUFBRTFCLEVBQUUsQ0FBQyxJQUFJO1FBQ3BDLElBQUk4RSxhQUFpQy9GO1FBQ3JDLElBQUltRSxNQUFNM0IsT0FBT1UsTUFBTSxHQUFHLEdBQUc7WUFDM0IsTUFBTThDLFlBQVl4RCxNQUFNLENBQUMyQixNQUFNLEVBQUU7WUFDakMsTUFBTThCLFlBQVlOLFlBQVksQ0FBQ0ssVUFBVS9FLEVBQUUsQ0FBQyxJQUFJO1lBQ2hELHVEQUF1RDtZQUN2RDhFLGFBQWFELFFBQVEsSUFBSUksS0FBS0MsS0FBSyxDQUFDLFlBQWFMLFFBQVMsT0FBTzlGO1FBQ25FO1FBQ0EsT0FBTztZQUFFd0QsVUFBVWIsRUFBRTFCLEVBQUU7WUFBRW1GLFlBQVl6RCxFQUFFQyxJQUFJO1lBQUVrRDtZQUFPTyxvQkFBb0JOO1FBQVc7SUFDckY7SUFFQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHM/ODFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUmVhZC1vbmx5IENSTSBBUEkgaGVscGVycyAoTVZQIHNrZWxldG9uKS5cclxuICogSW1wbGVtZW50YXRpb24gbm90ZTpcclxuICogLSBTdGFydCB3aXRoIG1vY2svcGxhY2Vob2xkZXIgaW1wbGVtZW50YXRpb25zLlxyXG4gKiAtIFJlcGxhY2Ugd2l0aCBTdXBhYmFzZSBjbGllbnQgb3IgYmFja2VuZCBwcm94eSBvbmNlIGF1dGgvUkxTIHN0cmF0ZWd5IGlzIHNldC5cclxuICovXHJcblxyXG5leHBvcnQgdHlwZSBTdGFnZSA9IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyBvcmRlcl9pbmRleDogbnVtYmVyOyBwaXBlbGluZV9pZD86IHN0cmluZzsgcHJvYmFiaWxpdHk/OiBudW1iZXIgfTtcclxuZXhwb3J0IHR5cGUgRGVhbCA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgY29tcGFueV9pZD86IHN0cmluZztcclxuICBjb250YWN0X2lkPzogc3RyaW5nO1xyXG4gIHBpcGVsaW5lX2lkOiBzdHJpbmc7XHJcbiAgc3RhZ2VfaWQ6IHN0cmluZztcclxuICBhbW91bnQ/OiBudW1iZXI7XHJcbiAgY3VycmVuY3k/OiBzdHJpbmc7XHJcbiAgY2xvc2VfZGF0ZT86IHN0cmluZztcclxuICBzdGF0dXM/OiBzdHJpbmc7XHJcbiAgc291cmNlPzogc3RyaW5nO1xyXG4gIG5vdGVzPzogc3RyaW5nO1xyXG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmc7XHJcbn07XHJcbmV4cG9ydCB0eXBlIEFjdGl2aXR5ID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdHlwZTogJ2VtYWlsX2luJyB8ICdlbWFpbF9vdXQnIHwgJ2NhbGwnIHwgJ21lZXRpbmcnIHwgJ3Rhc2snIHwgJ25vdGUnIHwgJ3N5c3RlbSc7XHJcbiAgcmVsYXRlZF90eXBlOiAnZGVhbCcgfCAnY29udGFjdCcgfCAnY29tcGFueSc7XHJcbiAgcmVsYXRlZF9pZDogc3RyaW5nO1xyXG4gIGNvbnRlbnQ/OiBzdHJpbmc7XHJcbiAgbWV0YV9qc29uPzogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICBjcmVhdGVkX2F0OiBzdHJpbmc7XHJcbn07XHJcbmV4cG9ydCB0eXBlIENvbnRhY3QgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBmdWxsX25hbWU/OiBzdHJpbmc7XHJcbiAgZW1haWw/OiBzdHJpbmc7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgbGlua2VkaW5fdXJsPzogc3RyaW5nO1xyXG4gIHdlYnNpdGU/OiBzdHJpbmc7XHJcbiAgcmVwbHlfc3RhdHVzPzogJ2ludGVyZXN0ZWQnIHwgJ25vdF9pbnRlcmVzdGVkJyB8ICdxdWVzdGlvbicgfCBzdHJpbmc7XHJcbiAgcmVwbHlfc3VtbWFyeT86IHN0cmluZztcclxufTtcclxuXHJcbmNvbnN0IE1PQ0tfREVMQVkgPSAxNTA7XHJcblxyXG5mdW5jdGlvbiBzbGVlcChtcyA9IE1PQ0tfREVMQVkpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIG1zKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFZGdlIEFjdGlvbnMgSFRUUCBoZWxwZXJzIChNVlApXHJcbiAqIFN3aXRjaGFibGUgdmlhIE5FWFRfUFVCTElDX0NSTV9BUElfQkFTRTpcclxuICogLSBJZiBkZWZpbmVkOiByZWFsIEVkZ2UgZW5kcG9pbnQgY2FsbHNcclxuICogLSBJZiBub3QgZGVmaW5lZDogZmFsbGJhY2sgdG8gbW9jayBpbi1tZW1vcnkgYmVoYXZpb3JcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwaUJhc2UoKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgLy8gZS5nLiBodHRwOi8vbG9jYWxob3N0OjgwMDAgb3IgLyAoaWYgcHJveGllZClcclxuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Py5ORVhUX1BVQkxJQ19DUk1fQVBJX0JBU0UpIHtcclxuICAgIHJldHVybiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DUk1fQVBJX0JBU0UhO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFRva2VuKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gIC8vIFRPRE86IGludGVncmF0ZSB3aXRoIFN1cGFiYXNlL05leHRBdXRoLiBGb3Igbm93LCByZXR1cm4gbnVsbCAobm8gQXV0aG9yaXphdGlvbiBoZWFkZXIpLlxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG50eXBlIFJlcXVlc3RPcHRpb25zID0ge1xyXG4gIG1ldGhvZD86ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnUEFUQ0gnIHwgJ0RFTEVURSc7XHJcbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgYm9keT86IGFueTtcclxuICBpZGVtcG90ZW5jeUtleT86IHN0cmluZztcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGFwaVJlcXVlc3Q8VCA9IGFueT4ocGF0aDogc3RyaW5nLCBvcHRzOiBSZXF1ZXN0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBzdGF0dXM6IG51bWJlcjsgZGF0YT86IFQ7IGVycm9yPzogc3RyaW5nIH0+IHtcclxuICBjb25zdCBiYXNlID0gZ2V0QXBpQmFzZSgpO1xyXG4gIGlmICghYmFzZSkge1xyXG4gICAgLy8gbm8gYmFzZSBjb25maWd1cmVkIOKGkiBmYWxsYmFjayBpbmZvcm0gY2FsbGVyIHRvIHVzZSBtb2Nrc1xyXG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBzdGF0dXM6IDAsIGVycm9yOiAnQVBJIGJhc2Ugbm90IGNvbmZpZ3VyZWQgKHVzaW5nIG1vY2sgZmFsbGJhY2spJyB9O1xyXG4gIH1cclxuICBjb25zdCB1cmwgPSBwYXRoLnN0YXJ0c1dpdGgoJ2h0dHAnKSA/IHBhdGggOiBgJHtiYXNlLnJlcGxhY2UoL1xcLyskLywgJycpfS8ke3BhdGgucmVwbGFjZSgvXlxcLysvLCAnJyl9YDtcclxuICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldEF1dGhUb2tlbigpO1xyXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgLi4uKG9wdHMuaGVhZGVycyB8fCB7fSksXHJcbiAgfTtcclxuICBpZiAodG9rZW4pIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xyXG4gIGlmIChvcHRzLmlkZW1wb3RlbmN5S2V5KSBoZWFkZXJzWydJZGVtcG90ZW5jeS1LZXknXSA9IG9wdHMuaWRlbXBvdGVuY3lLZXk7XHJcblxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAnUE9TVCcsXHJcbiAgICBoZWFkZXJzLFxyXG4gICAgYm9keTogdHlwZW9mIG9wdHMuYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OLnN0cmluZ2lmeShvcHRzLmJvZHkpIDogdW5kZWZpbmVkLFxyXG4gIH0pO1xyXG5cclxuICBsZXQgcGF5bG9hZDogYW55ID0gdW5kZWZpbmVkO1xyXG4gIHRyeSB7XHJcbiAgICBwYXlsb2FkID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIGlnbm9yZSBib2R5IHBhcnNlIGVycm9yc1xyXG4gIH1cclxuICBpZiAoIXJlcy5vaykge1xyXG4gICAgY29uc3QgbXNnID0gdHlwZW9mIHBheWxvYWQ/LmVycm9yID09PSAnc3RyaW5nJyA/IHBheWxvYWQuZXJyb3IgOiBgSFRUUCAke3Jlcy5zdGF0dXN9YDtcclxuICAgIHJldHVybiB7IG9rOiBmYWxzZSwgc3RhdHVzOiByZXMuc3RhdHVzLCBlcnJvcjogbXNnIH07XHJcbiAgfVxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IHBheWxvYWQgfTtcclxuICByZXR1cm4gbW9ja0FjdGl2aXRpZXMuZmlsdGVyKChhKSA9PiBhLnJlbGF0ZWRfdHlwZSA9PT0gcmVsYXRlZFR5cGUgJiYgYS5yZWxhdGVkX2lkID09PSByZWxhdGVkSWQpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gK25ldyBEYXRlKGIuY3JlYXRlZF9hdCkgLSArbmV3IERhdGUoYS5jcmVhdGVkX2F0KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3Q+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGNvbnRhY3RzIGJ5IGlkXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBjID0gbW9ja0NvbnRhY3RzW2lkXTtcclxuICBpZiAoIWMpIHRocm93IG5ldyBFcnJvcignQ29udGFjdCBub3QgZm91bmQnKTtcclxuICByZXR1cm4gYztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwcmludCAyIOKAlCBDb250YWN0UXVpY2sgYWN0aW9uczogaW50ZXJlc3RlZCAvIG5vdF9pbnRlcmVzdGVkIHRvZ2dsZVxyXG4gKiBHZXLDp2VrIGVudGVncmFzeW9uZGEgUE9TVCAvY3JtL2FjdGlvbnMvY29udGFjdHMgw6dhxJ9yxLFzxLFuYSBkw7Zuw7zFn2VjZWt0aXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29udGFjdFN0YXR1cyhcclxuICBjb250YWN0SWQ6IHN0cmluZyxcclxuICBzdGF0dXM6ICdpbnRlcmVzdGVkJyB8ICdub3RfaW50ZXJlc3RlZCdcclxuKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgY29udGFjdD86IENvbnRhY3QgfT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgYyA9IG1vY2tDb250YWN0c1tjb250YWN0SWRdO1xyXG4gIGlmICghYykgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0NvbnRhY3Qgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0geyAuLi5jIH07XHJcbiAgYy5yZXBseV9zdGF0dXMgPSBzdGF0dXM7XHJcblxyXG4gIC8vIExvZyBhY3Rpdml0eVxyXG4gIG1vY2tBY3Rpdml0aWVzLnB1c2goe1xyXG4gICAgaWQ6IGBhXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgdHlwZTogJ3N5c3RlbScsXHJcbiAgICByZWxhdGVkX3R5cGU6ICdjb250YWN0JyxcclxuICAgIHJlbGF0ZWRfaWQ6IGNvbnRhY3RJZCxcclxuICAgIGNvbnRlbnQ6ICdDb250YWN0IHN0YXR1cyBjaGFuZ2VkJyxcclxuICAgIG1ldGFfanNvbjogeyBmcm9tOiBwcmV2LnJlcGx5X3N0YXR1cywgdG86IHN0YXR1cyB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICAvLyBPdXRib3VuZCB3ZWJob29rIChsb2ctb25seSwgbW9jaylcclxuICAvLyBJbiByZWFsIGltcGw6IGZpcmUtYW5kLWZvcmdldCBQT1NUIHdpdGggZXZlbnRfdHlwZT1jb250YWN0X3N0YXR1c19jaGFuZ2VkXHJcblxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBjb250YWN0OiBjIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcHJpbnQgMiDigJQgQ29udGFjdFF1aWNrIGFjdGlvbnM6IHNlbmQgY2FsZW5kYXIgbGluayAocGxhY2Vob2xkZXIpXHJcbiAqIFMyOiB5YWxuxLF6Y2EgbGluayDDvHJldGlwIGTDtm5kw7xyw7xyOyBTMzogZ2Vyw6dlayBlLXBvc3RhL21lc2FqIG90b21hc3lvbnUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJMaW5rKGNvbnRhY3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyB1cmw6IHN0cmluZyB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBiYXNlID0gJ2h0dHBzOi8vY2FsLmNvbS95b3VyLXRlYW0vMzBtaW4nO1xyXG4gIC8vIGJhc2l0w6dlIGtpxZ9pIGUtcG9zdGFzxLFuxLEgcXVlcnkgb2xhcmFrIGlsacWfdGlyXHJcbiAgY29uc3QgZW1haWwgPSBtb2NrQ29udGFjdHNbY29udGFjdElkXT8uZW1haWwgfHwgJ3Byb3NwZWN0QGV4YW1wbGUuY29tJztcclxuICBjb25zdCB1cmwgPSBgJHtiYXNlfT9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9YDtcclxuICByZXR1cm4geyBvazogdHJ1ZSwgdXJsIH07XHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBjb21wdXRlIHN0YWdlIG5hbWUgZm9yIGEgZ2l2ZW4gc3RhZ2VfaWQgKHVzZWZ1bCBmb3IgVUkpXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZU5hbWUocGlwZWxpbmVJZDogc3RyaW5nLCBzdGFnZUlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xyXG4gIGNvbnN0IHN0YWdlcyA9IGF3YWl0IGdldFBpcGVsaW5lU3RhZ2VzKHBpcGVsaW5lSWQpO1xyXG4gIHJldHVybiBzdGFnZXMuZmluZCgocykgPT4gcy5pZCA9PT0gc3RhZ2VJZCk/Lm5hbWU7XHJcbn1cclxuXHJcbi8vIERlbW8tb25seSBoZWxwZXJzIHRvIGJyaWRnZSBtb2NrIHJlbGF0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udGFjdEZvckRlYWwoZGVhbElkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3QgfCB1bmRlZmluZWQ+IHtcclxuICBjb25zdCBjb250YWN0SWQgPSBkZWFsVG9Db250YWN0W2RlYWxJZF07XHJcbiAgaWYgKCFjb250YWN0SWQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgcmV0dXJuIGdldENvbnRhY3QoY29udGFjdElkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydGluZyBoZWxwZXJzIChTbmFwc2hvdCBNVlApXHJcbiAqIE5vdGU6IE1vY2sgaW1wbGVtZW50YXRpb24gdXNpbmcgaW4tbWVtb3J5IGRhdGE7IHJlcGxhY2Ugd2l0aCBTdXBhYmFzZS9FZGdlIHF1ZXJpZXMgbGF0ZXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVwbGllc0xhc3Q3ZCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3Qgc2luY2UgPSBEYXRlLm5vdygpIC0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcbiAgcmV0dXJuIG1vY2tBY3Rpdml0aWVzLmZpbHRlcigoYSkgPT4gYS50eXBlID09PSAnZW1haWxfaW4nICYmICtuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpID49IHNpbmNlKS5sZW5ndGg7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZURpc3RyaWJ1dGlvbihwaXBlbGluZUlkOiBzdHJpbmcpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGNvbnN0IGRpc3Q6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICBmb3IgKGNvbnN0IGQgb2YgbW9ja0RlYWxzKSB7XHJcbiAgICBpZiAoZC5waXBlbGluZV9pZCAhPT0gcGlwZWxpbmVJZCkgY29udGludWU7XHJcbiAgICBkaXN0W2Quc3RhZ2VfaWRdID0gKGRpc3RbZC5zdGFnZV9pZF0gfHwgMCkgKyAxO1xyXG4gIH1cclxuICByZXR1cm4gZGlzdDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNpbXBsZUNvbnZlcnNpb24ocGlwZWxpbmVJZDogc3RyaW5nKTogUHJvbWlzZTx7IGZyb206IHN0cmluZzsgdG86IHN0cmluZzsgcmF0ZTogbnVtYmVyIHwgbnVsbCB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICAvLyBCYXNpdCBiaXIgb3JhbjogTmV3IC0+IFF1YWxpZmllZFxyXG4gIGNvbnN0IGZyb20gPSAnc19uZXcnO1xyXG4gIGNvbnN0IHRvID0gJ3NfcXVhbGlmaWVkJztcclxuICBjb25zdCBpbkZyb20gPSBtb2NrRGVhbHMuZmlsdGVyKChkKSA9PiBkLnBpcGVsaW5lX2lkID09PSBwaXBlbGluZUlkICYmIGQuc3RhZ2VfaWQgPT09IGZyb20pLmxlbmd0aDtcclxuICBjb25zdCBpblRvID0gbW9ja0RlYWxzLmZpbHRlcigoZCkgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCAmJiBkLnN0YWdlX2lkID09PSB0bykubGVuZ3RoO1xyXG4gIGNvbnN0IHJhdGUgPSBpbkZyb20gPiAwID8gTnVtYmVyKCgoaW5UbyAvIGluRnJvbSkgKiAxMDApLnRvRml4ZWQoMCkpIDogbnVsbDtcclxuICByZXR1cm4geyBmcm9tLCB0bywgcmF0ZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogU3ByaW50IDIg4oCUIERlYWxEZXRhaWwgaW5saW5lIGVkaXQgbW9jayBoZWxwZXIuXHJcbiAqIEdlcsOnZWsgZW50ZWdyYXN5b25kYSBQT1NUIC9jcm0vYWN0aW9ucy9kZWFscyDDp2HEn3LEsXPEsW5hIGTDtm7DvMWfZWNla3Rpci5cclxuICovXHJcbmV4cG9ydCB0eXBlIERlYWxVcGRhdGVJbnB1dCA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlPzogc3RyaW5nO1xyXG4gIGFtb3VudD86IG51bWJlcjtcclxuICBjdXJyZW5jeT86IHN0cmluZztcclxuICBjbG9zZV9kYXRlPzogc3RyaW5nOyAvLyBJU09cclxuICBzdGFnZV9pZD86IHN0cmluZztcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVEZWFsKGlucHV0OiBEZWFsVXBkYXRlSW5wdXQsIG9wdGlvbnM/OiB7IHNpbXVsYXRlRXJyb3I/OiBib29sZWFuIH0pOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyBkZWFsPzogRGVhbCB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBpZiAob3B0aW9ucz8uc2ltdWxhdGVFcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ1NpbXVsYXRlZCB1cGRhdGUgZXJyb3InIH07XHJcblxyXG4gIGNvbnN0IGlkeCA9IG1vY2tEZWFscy5maW5kSW5kZXgoKGQpID0+IGQuaWQgPT09IGlucHV0LmlkKTtcclxuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0RlYWwgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0gbW9ja0RlYWxzW2lkeF07XHJcbiAgLy8gYmFzaWMgdmFsaWRhdGlvblxyXG4gIGlmICh0eXBlb2YgaW5wdXQuYW1vdW50ICE9PSAndW5kZWZpbmVkJyAmJiBOdW1iZXIuaXNOYU4oTnVtYmVyKGlucHV0LmFtb3VudCkpKSB7XHJcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnQW1vdW50IG11c3QgYmUgbnVtZXJpYycgfTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBpbnB1dC5jbG9zZV9kYXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgY29uc3QgdCA9IERhdGUucGFyc2UoaW5wdXQuY2xvc2VfZGF0ZSk7XHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHQpKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnY2xvc2VfZGF0ZSBtdXN0IGJlIElTTyBzdHJpbmcnIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCBuZXh0OiBEZWFsID0ge1xyXG4gICAgLi4ucHJldixcclxuICAgIHRpdGxlOiBpbnB1dC50aXRsZSA/PyBwcmV2LnRpdGxlLFxyXG4gICAgYW1vdW50OiB0eXBlb2YgaW5wdXQuYW1vdW50ICE9PSAndW5kZWZpbmVkJyA/IE51bWJlcihpbnB1dC5hbW91bnQpIDogcHJldi5hbW91bnQsXHJcbiAgICBjdXJyZW5jeTogaW5wdXQuY3VycmVuY3kgPz8gcHJldi5jdXJyZW5jeSxcclxuICAgIGNsb3NlX2RhdGU6IGlucHV0LmNsb3NlX2RhdGUgPz8gcHJldi5jbG9zZV9kYXRlLFxyXG4gICAgc3RhZ2VfaWQ6IGlucHV0LnN0YWdlX2lkID8/IHByZXYuc3RhZ2VfaWQsXHJcbiAgfTtcclxuICBtb2NrRGVhbHNbaWR4XSA9IG5leHQ7XHJcblxyXG4gIC8vIGxvZyBhY3Rpdml0eVxyXG4gIGNvbnN0IGNoYW5nZWQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICBmb3IgKGNvbnN0IGsgb2YgWyd0aXRsZScsICdhbW91bnQnLCAnY3VycmVuY3knLCAnY2xvc2VfZGF0ZScsICdzdGFnZV9pZCddIGFzIGNvbnN0KSB7XHJcbiAgICBpZiAoKHByZXYgYXMgYW55KVtrXSAhPT0gKG5leHQgYXMgYW55KVtrXSkgY2hhbmdlZFtrXSA9IHsgZnJvbTogKHByZXYgYXMgYW55KVtrXSwgdG86IChuZXh0IGFzIGFueSlba10gfTtcclxuICB9XHJcbiAgbW9ja0FjdGl2aXRpZXMucHVzaCh7XHJcbiAgICBpZDogYGFfJHtEYXRlLm5vdygpfWAsXHJcbiAgICB0eXBlOiAnc3lzdGVtJyxcclxuICAgIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLFxyXG4gICAgcmVsYXRlZF9pZDogaW5wdXQuaWQsXHJcbiAgICBjb250ZW50OiAnRGVhbCB1cGRhdGVkJyxcclxuICAgIG1ldGFfanNvbjogeyBjaGFuZ2VkIH0sXHJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBkZWFsOiBuZXh0IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcHJpbnQgMiAtIMSwbGsgR8O2cmV2OiBLYW5iYW4gRHJhZyAmIERyb3Ag4oaSIFN0YWdlIENoYW5nZVxyXG4gKiBNb2NrIG9ydGFtZGEgb3B0aW1pc3RpYyBVSSBha8SxxZ/EsW7EsSBkb8SfcnVsYW1hayBpw6dpbiBzdGFnZSBnw7xuY2VsbGVtZSBoZWxwZXInxLEuXHJcbiAqIEdlcsOnZWsgZW50ZWdyYXN5b25kYSBidSBmb25rc2l5b24sIEVkZ2UgRnVuY3Rpb24nYSAoUE9TVCAvY3JtL2FjdGlvbnMvZGVhbHMvOmlkL3N0YWdlKSDDp2HEn3LEsSB5YXBhY2FrLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURlYWxTdGFnZShcclxuICBkZWFsSWQ6IHN0cmluZyxcclxuICBuZXh0U3RhZ2VJZDogc3RyaW5nLFxyXG4gIG9wdGlvbnM/OiB7IG9jY3VycmVkQXRJU08/OiBzdHJpbmc7IGlkZW1wb3RlbmN5S2V5Pzogc3RyaW5nOyBzaW11bGF0ZUVycm9yPzogYm9vbGVhbiB9XHJcbik6IFByb21pc2U8eyBvazogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmc7IGRlYWw/OiBEZWFsIH0+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGlmIChvcHRpb25zPy5zaW11bGF0ZUVycm9yKSB7XHJcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnU2ltdWxhdGVkIG5ldHdvcmsvc2VydmVyIGVycm9yJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaWR4ID0gbW9ja0RlYWxzLmZpbmRJbmRleCgoZCkgPT4gZC5pZCA9PT0gZGVhbElkKTtcclxuICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0RlYWwgbm90IGZvdW5kJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldiA9IG1vY2tEZWFsc1tpZHhdO1xyXG4gIGNvbnN0IG5leHQ6IERlYWwgPSB7IC4uLnByZXYsIHN0YWdlX2lkOiBuZXh0U3RhZ2VJZCB9O1xyXG4gIG1vY2tEZWFsc1tpZHhdID0gbmV4dDtcclxuXHJcbiAgLy8gU3lzdGVtIGFjdGl2aXR5IGluc2VydCAobW9jaylcclxuICBtb2NrQWN0aXZpdGllcy5wdXNoKHtcclxuICAgIGlkOiBgYV8ke0RhdGUubm93KCl9YCxcclxuICAgIHR5cGU6ICdzeXN0ZW0nLFxyXG4gICAgcmVsYXRlZF90eXBlOiAnZGVhbCcsXHJcbiAgICByZWxhdGVkX2lkOiBkZWFsSWQsXHJcbiAgICBjb250ZW50OiAnU3RhZ2UgY2hhbmdlZCcsXHJcbiAgICBtZXRhX2pzb246IHsgZnJvbTogcHJldi5zdGFnZV9pZCwgdG86IG5leHRTdGFnZUlkLCBvY2N1cnJlZF9hdDogb3B0aW9ucz8ub2NjdXJyZWRBdElTTyB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICAvLyBPdXRib3VuZCB3ZWJob29rIChsb2ctb25seSwgbW9jaylcclxuICAvLyBJbiByZWFsIGltcGw6IGZpcmUtYW5kLWZvcmdldCBQT1NUIHRvIG91dGJvdW5kIGVuZHBvaW50IHdpdGggZXZlbnRfdHlwZT1kZWFsX3N0YWdlX2NoYW5nZWRcclxuXHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIGRlYWw6IG5leHQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydGluZyAoTVZQLCBtb2NrKVxyXG4gKiAtIG9wZW4gZGVhbHMgY291bnRcclxuICogLSBsYXN0IDcgZGF5cyByZXBseSBjb3VudCAoZW1haWxfaW4pXHJcbiAqIC0gc2ltcGxlIHBpcGVsaW5lIGNvbnZlcnNpb24gKHN0YWdlLXRvLXN0YWdlIHJhdGlvcyB3aXRoaW4gY3VycmVudCBtb2NrIHNuYXBzaG90KVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9wZW5EZWFsc0NvdW50KHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgbGlzdCA9IHBpcGVsaW5lSWQgPyBtb2NrRGVhbHMuZmlsdGVyKGQgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCkgOiBtb2NrRGVhbHM7XHJcbiAgLy8gT3BlbiA9IG5vdCBXb24gYW5kIG5vdCBMb3N0XHJcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGQgPT4gZC5zdGFnZV9pZCAhPT0gJ3Nfd29uJyAmJiBkLnN0YWdlX2lkICE9PSAnc19sb3N0JykubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGFzdDdEYXlzUmVwbHlDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCBzZXZlbkRheXMgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuICByZXR1cm4gbW9ja0FjdGl2aXRpZXMuZmlsdGVyKGEgPT5cclxuICAgIGEudHlwZSA9PT0gJ2VtYWlsX2luJyAmJiAobm93IC0gK25ldyBEYXRlKGEuY3JlYXRlZF9hdCkpIDw9IHNldmVuRGF5c1xyXG4gICkubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQaXBlbGluZUNvbnZlcnNpb24gPSB7XHJcbiAgc3RhZ2VfaWQ6IHN0cmluZztcclxuICBzdGFnZV9uYW1lOiBzdHJpbmc7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICBjb252ZXJzaW9uX3RvX25leHQ/OiBudW1iZXI7IC8vIHBlcmNlbnQgWzAuLjEwMF1cclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQaXBlbGluZUNvbnZlcnNpb24ocGlwZWxpbmVJZDogc3RyaW5nID0gJ3BfZGVmYXVsdCcpOiBQcm9taXNlPFBpcGVsaW5lQ29udmVyc2lvbltdPiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBzdGFnZXMgPSBtb2NrU3RhZ2VzXHJcbiAgICAuZmlsdGVyKHMgPT4gcy5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZClcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCk7XHJcblxyXG4gIGNvbnN0IGJ5U3RhZ2VDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gIGZvciAoY29uc3QgcyBvZiBzdGFnZXMpIGJ5U3RhZ2VDb3VudFtzLmlkXSA9IDA7XHJcbiAgZm9yIChjb25zdCBkIG9mIG1vY2tEZWFscykge1xyXG4gICAgaWYgKGQucGlwZWxpbmVfaWQgIT09IHBpcGVsaW5lSWQpIGNvbnRpbnVlO1xyXG4gICAgaWYgKGJ5U3RhZ2VDb3VudFtkLnN0YWdlX2lkXSAhPT0gdW5kZWZpbmVkKSBieVN0YWdlQ291bnRbZC5zdGFnZV9pZF0gKz0gMTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdDogUGlwZWxpbmVDb252ZXJzaW9uW10gPSBzdGFnZXMubWFwKChzLCBpZHgpID0+IHtcclxuICAgIGNvbnN0IGNvdW50ID0gYnlTdGFnZUNvdW50W3MuaWRdIHx8IDA7XHJcbiAgICBsZXQgY29udmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlkeCA8IHN0YWdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGNvbnN0IG5leHRTdGFnZSA9IHN0YWdlc1tpZHggKyAxXTtcclxuICAgICAgY29uc3QgbmV4dENvdW50ID0gYnlTdGFnZUNvdW50W25leHRTdGFnZS5pZF0gfHwgMDtcclxuICAgICAgLy8gbmFpdmUgcmF0aW8gdXNpbmcgc25hcHNob3QgY291bnRzIChub3QgY29ob3J0LWJhc2VkKVxyXG4gICAgICBjb252ZXJzaW9uID0gY291bnQgPiAwID8gTWF0aC5yb3VuZCgobmV4dENvdW50IC8gY291bnQpICogMTAwKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHN0YWdlX2lkOiBzLmlkLCBzdGFnZV9uYW1lOiBzLm5hbWUsIGNvdW50LCBjb252ZXJzaW9uX3RvX25leHQ6IGNvbnZlcnNpb24gfTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4iXSwibmFtZXMiOlsiTU9DS19ERUxBWSIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsImdldEFwaUJhc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ1JNX0FQSV9CQVNFIiwiZ2V0QXV0aFRva2VuIiwiYXBpUmVxdWVzdCIsInBhdGgiLCJvcHRzIiwiYmFzZSIsIm9rIiwic3RhdHVzIiwiZXJyb3IiLCJ1cmwiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsInRva2VuIiwiaGVhZGVycyIsImlkZW1wb3RlbmN5S2V5IiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsInBheWxvYWQiLCJqc29uIiwibXNnIiwiZGF0YSIsIm1vY2tBY3Rpdml0aWVzIiwiZmlsdGVyIiwiYSIsInJlbGF0ZWRfdHlwZSIsInJlbGF0ZWRUeXBlIiwicmVsYXRlZF9pZCIsInJlbGF0ZWRJZCIsInNvcnQiLCJiIiwiRGF0ZSIsImNyZWF0ZWRfYXQiLCJnZXRDb250YWN0IiwiaWQiLCJjIiwibW9ja0NvbnRhY3RzIiwiRXJyb3IiLCJ1cGRhdGVDb250YWN0U3RhdHVzIiwiY29udGFjdElkIiwicHJldiIsInJlcGx5X3N0YXR1cyIsInB1c2giLCJub3ciLCJ0eXBlIiwiY29udGVudCIsIm1ldGFfanNvbiIsImZyb20iLCJ0byIsInRvSVNPU3RyaW5nIiwiY29udGFjdCIsImdldENhbGVuZGFyTGluayIsImVtYWlsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0U3RhZ2VOYW1lIiwicGlwZWxpbmVJZCIsInN0YWdlSWQiLCJzdGFnZXMiLCJnZXRQaXBlbGluZVN0YWdlcyIsImZpbmQiLCJzIiwibmFtZSIsImdldENvbnRhY3RGb3JEZWFsIiwiZGVhbElkIiwiZGVhbFRvQ29udGFjdCIsImdldFJlcGxpZXNMYXN0N2QiLCJzaW5jZSIsImxlbmd0aCIsImdldFN0YWdlRGlzdHJpYnV0aW9uIiwiZGlzdCIsImQiLCJtb2NrRGVhbHMiLCJwaXBlbGluZV9pZCIsInN0YWdlX2lkIiwiZ2V0U2ltcGxlQ29udmVyc2lvbiIsImluRnJvbSIsImluVG8iLCJyYXRlIiwiTnVtYmVyIiwidG9GaXhlZCIsInVwZGF0ZURlYWwiLCJpbnB1dCIsIm9wdGlvbnMiLCJzaW11bGF0ZUVycm9yIiwiaWR4IiwiZmluZEluZGV4IiwiYW1vdW50IiwiaXNOYU4iLCJjbG9zZV9kYXRlIiwidCIsInBhcnNlIiwibmV4dCIsInRpdGxlIiwiY3VycmVuY3kiLCJjaGFuZ2VkIiwiayIsImRlYWwiLCJ1cGRhdGVEZWFsU3RhZ2UiLCJuZXh0U3RhZ2VJZCIsIm9jY3VycmVkX2F0Iiwib2NjdXJyZWRBdElTTyIsImdldE9wZW5EZWFsc0NvdW50IiwibGlzdCIsImdldExhc3Q3RGF5c1JlcGx5Q291bnQiLCJzZXZlbkRheXMiLCJnZXRQaXBlbGluZUNvbnZlcnNpb24iLCJtb2NrU3RhZ2VzIiwib3JkZXJfaW5kZXgiLCJieVN0YWdlQ291bnQiLCJyZXN1bHQiLCJtYXAiLCJjb3VudCIsImNvbnZlcnNpb24iLCJuZXh0U3RhZ2UiLCJuZXh0Q291bnQiLCJNYXRoIiwicm91bmQiLCJzdGFnZV9uYW1lIiwiY29udmVyc2lvbl90b19uZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});