"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/deal/[id]/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDeal: function() { return /* binding */ updateDeal; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/**\r\n * Read-only CRM API helpers (MVP skeleton).\r\n * Implementation note:\r\n * - Start with mock/placeholder implementations.\r\n * - Replace with Supabase client or backend proxy once auth/RLS strategy is set.\r\n */ const MOCK_DELAY = 150;\nfunction sleep() {\n    let ms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MOCK_DELAY;\n    return new Promise((res)=>setTimeout(res, ms));\n}\n// In-memory mock\nconst mockStages = [\n    {\n        id: \"s_new\",\n        name: \"New\",\n        order_index: 0,\n        probability: 0.05,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_contacted\",\n        name: \"Contacted\",\n        order_index: 1,\n        probability: 0.15,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_qualified\",\n        name: \"Qualified\",\n        order_index: 2,\n        probability: 0.35,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_meeting\",\n        name: \"Meeting Scheduled\",\n        order_index: 3,\n        probability: 0.5,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_proposal\",\n        name: \"Proposal Sent\",\n        order_index: 4,\n        probability: 0.7,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_won\",\n        name: \"Won\",\n        order_index: 5,\n        probability: 1.0,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_lost\",\n        name: \"Lost\",\n        order_index: 6,\n        probability: 0,\n        pipeline_id: \"p_default\"\n    }\n];\nconst mockDeals = [\n    {\n        id: \"d1\",\n        title: \"Acme - Pilot\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_new\",\n        amount: 2500,\n        currency: \"USD\",\n        source: \"outbound\"\n    },\n    {\n        id: \"d2\",\n        title: \"Globex - Discovery\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_contacted\",\n        amount: 5000,\n        currency: \"USD\",\n        source: \"reply\"\n    },\n    {\n        id: \"d3\",\n        title: \"Initech - Expansion\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_meeting\",\n        amount: 12000,\n        currency: \"USD\",\n        source: \"booking\"\n    }\n];\nconst mockContacts = {\n    c1: {\n        id: \"c1\",\n        full_name: \"John Doe\",\n        email: \"john@acme.com\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/john\",\n        website: \"https://acme.com\"\n    },\n    c2: {\n        id: \"c2\",\n        full_name: \"Mike Neo\",\n        email: \"mike@globex.com\",\n        title: \"Head of Ops\",\n        linkedin_url: \"https://linkedin.com/in/mike\",\n        website: \"https://globex.example\",\n        reply_status: \"question\",\n        reply_summary: \"Asked about pricing\"\n    }\n};\nconst mockActivities = [\n    {\n        id: \"a1\",\n        type: \"email_in\",\n        related_type: \"deal\",\n        related_id: \"d2\",\n        content: \"pricing details?\",\n        created_at: new Date(Date.now() - 86400000).toISOString()\n    },\n    {\n        id: \"a2\",\n        type: \"meeting\",\n        related_type: \"deal\",\n        related_id: \"d3\",\n        content: \"Discovery Call scheduled\",\n        created_at: new Date(Date.now() - 3600000).toISOString()\n    },\n    {\n        id: \"a3\",\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: \"d1\",\n        content: \"Deal created\",\n        created_at: new Date(Date.now() - 1800000).toISOString()\n    }\n];\n// Map one contact to deals for demo\nconst dealToContact = {\n    d1: \"c1\",\n    d2: \"c2\",\n    d3: \"c2\"\n};\nasync function getPipelineStages(pipelineId) {\n    // TODO: Replace with Supabase select from pipeline_stages where pipeline_id = pipelineId order by order_index\n    await sleep();\n    return mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n}\nasync function getDealsByPipeline(pipelineId) {\n    // TODO: Replace with Supabase select from deals where pipeline_id = pipelineId\n    await sleep();\n    return mockDeals.filter((d)=>d.pipeline_id === pipelineId);\n}\nasync function getDealDetail(id) {\n    // TODO: Replace with Supabase select deals by id\n    await sleep();\n    const deal = mockDeals.find((d)=>d.id === id);\n    if (!deal) throw new Error(\"Deal not found\");\n    return deal;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    // TODO: Replace with Supabase select activities where related_type = relatedType and related_id = relatedId order by created_at desc\n    await sleep();\n    return mockActivities.filter((a)=>a.related_type === relatedType && a.related_id === relatedId).sort((a, b)=>+new Date(b.created_at) - +new Date(a.created_at));\n}\nasync function getContact(id) {\n    // TODO: Replace with Supabase select contacts by id\n    await sleep();\n    const c = mockContacts[id];\n    if (!c) throw new Error(\"Contact not found\");\n    return c;\n}\n/**\r\n * Sprint 2 — ContactQuick actions: interested / not_interested toggle\r\n * Gerçek entegrasyonda POST /crm/actions/contacts çağrısına dönüşecektir.\r\n */ async function updateContactStatus(contactId, status) {\n    await sleep();\n    const c = mockContacts[contactId];\n    if (!c) return {\n        ok: false,\n        error: \"Contact not found\"\n    };\n    const prev = {\n        ...c\n    };\n    c.reply_status = status;\n    // Log activity\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"contact\",\n        related_id: contactId,\n        content: \"Contact status changed\",\n        meta_json: {\n            from: prev.reply_status,\n            to: status\n        },\n        created_at: new Date().toISOString()\n    });\n    // Outbound webhook (log-only, mock)\n    // In real impl: fire-and-forget POST with event_type=contact_status_changed\n    return {\n        ok: true,\n        contact: c\n    };\n}\n/**\r\n * Sprint 2 — ContactQuick actions: send calendar link (placeholder)\r\n * S2: yalnızca link üretip döndürür; S3: gerçek e-posta/mesaj otomasyonu.\r\n */ async function getCalendarLink(contactId) {\n    var _mockContacts_contactId;\n    await sleep();\n    const base = \"https://cal.com/your-team/30min\";\n    // basitçe kişi e-postasını query olarak iliştir\n    const email = ((_mockContacts_contactId = mockContacts[contactId]) === null || _mockContacts_contactId === void 0 ? void 0 : _mockContacts_contactId.email) || \"prospect@example.com\";\n    const url = \"\".concat(base, \"?email=\").concat(encodeURIComponent(email));\n    return {\n        ok: true,\n        url\n    };\n}\n// Helper to compute stage name for a given stage_id (useful for UI)\nasync function getStageName(pipelineId, stageId) {\n    var _stages_find;\n    const stages = await getPipelineStages(pipelineId);\n    return (_stages_find = stages.find((s)=>s.id === stageId)) === null || _stages_find === void 0 ? void 0 : _stages_find.name;\n}\n// Demo-only helpers to bridge mock relations\nasync function getContactForDeal(dealId) {\n    const contactId = dealToContact[dealId];\n    if (!contactId) return undefined;\n    return getContact(contactId);\n}\nasync function updateDeal(input, options) {\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) return {\n        ok: false,\n        error: \"Simulated update error\"\n    };\n    const idx = mockDeals.findIndex((d)=>d.id === input.id);\n    if (idx === -1) return {\n        ok: false,\n        error: \"Deal not found\"\n    };\n    const prev = mockDeals[idx];\n    // basic validation\n    if (typeof input.amount !== \"undefined\" && Number.isNaN(Number(input.amount))) {\n        return {\n            ok: false,\n            error: \"Amount must be numeric\"\n        };\n    }\n    if (typeof input.close_date !== \"undefined\") {\n        const t = Date.parse(input.close_date);\n        if (Number.isNaN(t)) return {\n            ok: false,\n            error: \"close_date must be ISO string\"\n        };\n    }\n    var _input_title, _input_currency, _input_close_date, _input_stage_id;\n    const next = {\n        ...prev,\n        title: (_input_title = input.title) !== null && _input_title !== void 0 ? _input_title : prev.title,\n        amount: typeof input.amount !== \"undefined\" ? Number(input.amount) : prev.amount,\n        currency: (_input_currency = input.currency) !== null && _input_currency !== void 0 ? _input_currency : prev.currency,\n        close_date: (_input_close_date = input.close_date) !== null && _input_close_date !== void 0 ? _input_close_date : prev.close_date,\n        stage_id: (_input_stage_id = input.stage_id) !== null && _input_stage_id !== void 0 ? _input_stage_id : prev.stage_id\n    };\n    mockDeals[idx] = next;\n    // log activity\n    const changed = {};\n    for (const k of [\n        \"title\",\n        \"amount\",\n        \"currency\",\n        \"close_date\",\n        \"stage_id\"\n    ]){\n        if (prev[k] !== next[k]) changed[k] = {\n            from: prev[k],\n            to: next[k]\n        };\n    }\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: input.id,\n        content: \"Deal updated\",\n        meta_json: {\n            changed\n        },\n        created_at: new Date().toISOString()\n    });\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Sprint 2 - İlk Görev: Kanban Drag & Drop → Stage Change\r\n * Mock ortamda optimistic UI akışını doğrulamak için stage güncelleme helper'ı.\r\n * Gerçek entegrasyonda bu fonksiyon, Edge Function'a (POST /crm/actions/deals/:id/stage) çağrı yapacak.\r\n */ async function updateDealStage(dealId, nextStageId, options) {\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) {\n        return {\n            ok: false,\n            error: \"Simulated network/server error\"\n        };\n    }\n    const idx = mockDeals.findIndex((d)=>d.id === dealId);\n    if (idx === -1) {\n        return {\n            ok: false,\n            error: \"Deal not found\"\n        };\n    }\n    const prev = mockDeals[idx];\n    const next = {\n        ...prev,\n        stage_id: nextStageId\n    };\n    mockDeals[idx] = next;\n    // System activity insert (mock)\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: dealId,\n        content: \"Stage changed\",\n        meta_json: {\n            from: prev.stage_id,\n            to: nextStageId,\n            occurred_at: options === null || options === void 0 ? void 0 : options.occurredAtISO\n        },\n        created_at: new Date().toISOString()\n    });\n    // Outbound webhook (log-only, mock)\n    // In real impl: fire-and-forget POST to outbound endpoint with event_type=deal_stage_changed\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Reporting (MVP, mock)\r\n * - open deals count\r\n * - last 7 days reply count (email_in)\r\n * - simple pipeline conversion (stage-to-stage ratios within current mock snapshot)\r\n */ async function getOpenDealsCount(pipelineId) {\n    await sleep();\n    const list = pipelineId ? mockDeals.filter((d)=>d.pipeline_id === pipelineId) : mockDeals;\n    // Open = not Won and not Lost\n    return list.filter((d)=>d.stage_id !== \"s_won\" && d.stage_id !== \"s_lost\").length;\n}\nasync function getLast7DaysReplyCount() {\n    await sleep();\n    const now = Date.now();\n    const sevenDays = 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && now - +new Date(a.created_at) <= sevenDays).length;\n}\nasync function getPipelineConversion() {\n    let pipelineId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"p_default\";\n    await sleep();\n    const stages = mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n    const byStageCount = {};\n    for (const s of stages)byStageCount[s.id] = 0;\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        if (byStageCount[d.stage_id] !== undefined) byStageCount[d.stage_id] += 1;\n    }\n    const result = stages.map((s, idx)=>{\n        const count = byStageCount[s.id] || 0;\n        let conversion = undefined;\n        if (idx < stages.length - 1) {\n            const nextStage = stages[idx + 1];\n            const nextCount = byStageCount[nextStage.id] || 0;\n            // naive ratio using snapshot counts (not cohort-based)\n            conversion = count > 0 ? Math.round(nextCount / count * 100) : undefined;\n        }\n        return {\n            stage_id: s.id,\n            stage_name: s.name,\n            count,\n            conversion_to_next: conversion\n        };\n    });\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQXNDRCxNQUFNQSxhQUFhO0FBRW5CLFNBQVNDO1FBQU1DLEtBQUFBLGlFQUFLRjtJQUNsQixPQUFPLElBQUlHLFFBQVEsQ0FBQ0MsTUFBUUMsV0FBV0QsS0FBS0Y7QUFDOUM7QUFFQSxpQkFBaUI7QUFDakIsTUFBTUksYUFBc0I7SUFDMUI7UUFBRUMsSUFBSTtRQUFTQyxNQUFNO1FBQU9DLGFBQWE7UUFBR0MsYUFBYTtRQUFNQyxhQUFhO0lBQVk7SUFDeEY7UUFBRUosSUFBSTtRQUFlQyxNQUFNO1FBQWFDLGFBQWE7UUFBR0MsYUFBYTtRQUFNQyxhQUFhO0lBQVk7SUFDcEc7UUFBRUosSUFBSTtRQUFlQyxNQUFNO1FBQWFDLGFBQWE7UUFBR0MsYUFBYTtRQUFNQyxhQUFhO0lBQVk7SUFDcEc7UUFBRUosSUFBSTtRQUFhQyxNQUFNO1FBQXFCQyxhQUFhO1FBQUdDLGFBQWE7UUFBS0MsYUFBYTtJQUFZO0lBQ3pHO1FBQUVKLElBQUk7UUFBY0MsTUFBTTtRQUFpQkMsYUFBYTtRQUFHQyxhQUFhO1FBQUtDLGFBQWE7SUFBWTtJQUN0RztRQUFFSixJQUFJO1FBQVNDLE1BQU07UUFBT0MsYUFBYTtRQUFHQyxhQUFhO1FBQUtDLGFBQWE7SUFBWTtJQUN2RjtRQUFFSixJQUFJO1FBQVVDLE1BQU07UUFBUUMsYUFBYTtRQUFHQyxhQUFhO1FBQUdDLGFBQWE7SUFBWTtDQUN4RjtBQUVELE1BQU1DLFlBQW9CO0lBQ3hCO1FBQUVMLElBQUk7UUFBTU0sT0FBTztRQUFnQkYsYUFBYTtRQUFhRyxVQUFVO1FBQVNDLFFBQVE7UUFBTUMsVUFBVTtRQUFPQyxRQUFRO0lBQVc7SUFDbEk7UUFBRVYsSUFBSTtRQUFNTSxPQUFPO1FBQXNCRixhQUFhO1FBQWFHLFVBQVU7UUFBZUMsUUFBUTtRQUFNQyxVQUFVO1FBQU9DLFFBQVE7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b0JBQW9CTjtRQUFXO0lBQ3JGO0lBRUEsT0FBT0g7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc2VydmljZXMvY3JtQXBpLnRzPzgxZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJlYWQtb25seSBDUk0gQVBJIGhlbHBlcnMgKE1WUCBza2VsZXRvbikuXHJcbiAqIEltcGxlbWVudGF0aW9uIG5vdGU6XHJcbiAqIC0gU3RhcnQgd2l0aCBtb2NrL3BsYWNlaG9sZGVyIGltcGxlbWVudGF0aW9ucy5cclxuICogLSBSZXBsYWNlIHdpdGggU3VwYWJhc2UgY2xpZW50IG9yIGJhY2tlbmQgcHJveHkgb25jZSBhdXRoL1JMUyBzdHJhdGVneSBpcyBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHR5cGUgU3RhZ2UgPSB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgb3JkZXJfaW5kZXg6IG51bWJlcjsgcGlwZWxpbmVfaWQ/OiBzdHJpbmc7IHByb2JhYmlsaXR5PzogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIERlYWwgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGNvbXBhbnlfaWQ/OiBzdHJpbmc7XHJcbiAgY29udGFjdF9pZD86IHN0cmluZztcclxuICBwaXBlbGluZV9pZDogc3RyaW5nO1xyXG4gIHN0YWdlX2lkOiBzdHJpbmc7XHJcbiAgYW1vdW50PzogbnVtYmVyO1xyXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xyXG4gIGNsb3NlX2RhdGU/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIHNvdXJjZT86IHN0cmluZztcclxuICBub3Rlcz86IHN0cmluZztcclxuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xyXG59O1xyXG5leHBvcnQgdHlwZSBBY3Rpdml0eSA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHR5cGU6ICdlbWFpbF9pbicgfCAnZW1haWxfb3V0JyB8ICdjYWxsJyB8ICdtZWV0aW5nJyB8ICd0YXNrJyB8ICdub3RlJyB8ICdzeXN0ZW0nO1xyXG4gIHJlbGF0ZWRfdHlwZTogJ2RlYWwnIHwgJ2NvbnRhY3QnIHwgJ2NvbXBhbnknO1xyXG4gIHJlbGF0ZWRfaWQ6IHN0cmluZztcclxuICBjb250ZW50Pzogc3RyaW5nO1xyXG4gIG1ldGFfanNvbj86IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5leHBvcnQgdHlwZSBDb250YWN0ID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgZnVsbF9uYW1lPzogc3RyaW5nO1xyXG4gIGVtYWlsPzogc3RyaW5nO1xyXG4gIHRpdGxlPzogc3RyaW5nO1xyXG4gIGxpbmtlZGluX3VybD86IHN0cmluZztcclxuICB3ZWJzaXRlPzogc3RyaW5nO1xyXG4gIHJlcGx5X3N0YXR1cz86ICdpbnRlcmVzdGVkJyB8ICdub3RfaW50ZXJlc3RlZCcgfCAncXVlc3Rpb24nIHwgc3RyaW5nO1xyXG4gIHJlcGx5X3N1bW1hcnk/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5jb25zdCBNT0NLX0RFTEFZID0gMTUwO1xyXG5cclxuZnVuY3Rpb24gc2xlZXAobXMgPSBNT0NLX0RFTEFZKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xyXG59XHJcblxyXG4vLyBJbi1tZW1vcnkgbW9ja1xyXG5jb25zdCBtb2NrU3RhZ2VzOiBTdGFnZVtdID0gW1xyXG4gIHsgaWQ6ICdzX25ldycsIG5hbWU6ICdOZXcnLCBvcmRlcl9pbmRleDogMCwgcHJvYmFiaWxpdHk6IDAuMDUsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX2NvbnRhY3RlZCcsIG5hbWU6ICdDb250YWN0ZWQnLCBvcmRlcl9pbmRleDogMSwgcHJvYmFiaWxpdHk6IDAuMTUsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX3F1YWxpZmllZCcsIG5hbWU6ICdRdWFsaWZpZWQnLCBvcmRlcl9pbmRleDogMiwgcHJvYmFiaWxpdHk6IDAuMzUsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX21lZXRpbmcnLCBuYW1lOiAnTWVldGluZyBTY2hlZHVsZWQnLCBvcmRlcl9pbmRleDogMywgcHJvYmFiaWxpdHk6IDAuNSwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbiAgeyBpZDogJ3NfcHJvcG9zYWwnLCBuYW1lOiAnUHJvcG9zYWwgU2VudCcsIG9yZGVyX2luZGV4OiA0LCBwcm9iYWJpbGl0eTogMC43LCBwaXBlbGluZV9pZDogJ3BfZGVmYXVsdCcgfSxcclxuICB7IGlkOiAnc193b24nLCBuYW1lOiAnV29uJywgb3JkZXJfaW5kZXg6IDUsIHByb2JhYmlsaXR5OiAxLjAsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX2xvc3QnLCBuYW1lOiAnTG9zdCcsIG9yZGVyX2luZGV4OiA2LCBwcm9iYWJpbGl0eTogMCwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbl07XHJcblxyXG5jb25zdCBtb2NrRGVhbHM6IERlYWxbXSA9IFtcclxuICB7IGlkOiAnZDEnLCB0aXRsZTogJ0FjbWUgLSBQaWxvdCcsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0Jywgc3RhZ2VfaWQ6ICdzX25ldycsIGFtb3VudDogMjUwMCwgY3VycmVuY3k6ICdVU0QnLCBzb3VyY2U6ICdvdXRib3VuZCcgfSxcclxuICB7IGlkOiAnZDInLCB0aXRsZTogJ0dsb2JleCAtIERpc2NvdmVyeScsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0Jywgc3RhZ2VfaWQ6ICdzX2NvbnRhY3RlZCcsIGFtb3VudDogNTAwMCwgY3VycmVuY3k6ICdVU0QnLCBzb3VyY2U6ICdyZXBseScgfSxcclxuICB7IGlkOiAnZDMnLCB0aXRsZTogJ0luaXRlY2ggLSBFeHBhbnNpb24nLCBwaXBlbGluZV9pZDogJ3BfZGVmYXVsdCcsIHN0YWdlX2lkOiAnc19tZWV0aW5nJywgYW1vdW50OiAxMjAwMCwgY3VycmVuY3k6ICdVU0QnLCBzb3VyY2U6ICdib29raW5nJyB9LFxyXG5dO1xyXG5cclxuY29uc3QgbW9ja0NvbnRhY3RzOiBSZWNvcmQ8c3RyaW5nLCBDb250YWN0PiA9IHtcclxuICBjMTogeyBpZDogJ2MxJywgZnVsbF9uYW1lOiAnSm9obiBEb2UnLCBlbWFpbDogJ2pvaG5AYWNtZS5jb20nLCB0aXRsZTogJ1ZQIFNhbGVzJywgbGlua2VkaW5fdXJsOiAnaHR0cHM6Ly9saW5rZWRpbi5jb20vaW4vam9obicsIHdlYnNpdGU6ICdodHRwczovL2FjbWUuY29tJyB9LFxyXG4gIGMyOiB7IGlkOiAnYzInLCBmdWxsX25hbWU6ICdNaWtlIE5lbycsIGVtYWlsOiAnbWlrZUBnbG9iZXguY29tJywgdGl0bGU6ICdIZWFkIG9mIE9wcycsIGxpbmtlZGluX3VybDogJ2h0dHBzOi8vbGlua2VkaW4uY29tL2luL21pa2UnLCB3ZWJzaXRlOiAnaHR0cHM6Ly9nbG9iZXguZXhhbXBsZScsIHJlcGx5X3N0YXR1czogJ3F1ZXN0aW9uJywgcmVwbHlfc3VtbWFyeTogJ0Fza2VkIGFib3V0IHByaWNpbmcnIH0sXHJcbn07XHJcblxyXG5jb25zdCBtb2NrQWN0aXZpdGllczogQWN0aXZpdHlbXSA9IFtcclxuICB7IGlkOiAnYTEnLCB0eXBlOiAnZW1haWxfaW4nLCByZWxhdGVkX3R5cGU6ICdkZWFsJywgcmVsYXRlZF9pZDogJ2QyJywgY29udGVudDogJ3ByaWNpbmcgZGV0YWlscz8nLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gODY0MDAwMDApLnRvSVNPU3RyaW5nKCkgfSxcclxuICB7IGlkOiAnYTInLCB0eXBlOiAnbWVldGluZycsIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLCByZWxhdGVkX2lkOiAnZDMnLCBjb250ZW50OiAnRGlzY292ZXJ5IENhbGwgc2NoZWR1bGVkJywgY3JlYXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDM2MDAwMDApLnRvSVNPU3RyaW5nKCkgfSxcclxuICB7IGlkOiAnYTMnLCB0eXBlOiAnc3lzdGVtJywgcmVsYXRlZF90eXBlOiAnZGVhbCcsIHJlbGF0ZWRfaWQ6ICdkMScsIGNvbnRlbnQ6ICdEZWFsIGNyZWF0ZWQnLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTgwMDAwMCkudG9JU09TdHJpbmcoKSB9LFxyXG5dO1xyXG5cclxuLy8gTWFwIG9uZSBjb250YWN0IHRvIGRlYWxzIGZvciBkZW1vXHJcbmNvbnN0IGRlYWxUb0NvbnRhY3Q6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgZDE6ICdjMScsXHJcbiAgZDI6ICdjMicsXHJcbiAgZDM6ICdjMicsXHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGlwZWxpbmVTdGFnZXMocGlwZWxpbmVJZDogc3RyaW5nKTogUHJvbWlzZTxTdGFnZVtdPiB7XHJcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFN1cGFiYXNlIHNlbGVjdCBmcm9tIHBpcGVsaW5lX3N0YWdlcyB3aGVyZSBwaXBlbGluZV9pZCA9IHBpcGVsaW5lSWQgb3JkZXIgYnkgb3JkZXJfaW5kZXhcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIHJldHVybiBtb2NrU3RhZ2VzLmZpbHRlcigocykgPT4gcy5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCkuc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbHNCeVBpcGVsaW5lKHBpcGVsaW5lSWQ6IHN0cmluZyk6IFByb21pc2U8RGVhbFtdPiB7XHJcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFN1cGFiYXNlIHNlbGVjdCBmcm9tIGRlYWxzIHdoZXJlIHBpcGVsaW5lX2lkID0gcGlwZWxpbmVJZFxyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgcmV0dXJuIG1vY2tEZWFscy5maWx0ZXIoKGQpID0+IGQucGlwZWxpbmVfaWQgPT09IHBpcGVsaW5lSWQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbERldGFpbChpZDogc3RyaW5nKTogUHJvbWlzZTxEZWFsPiB7XHJcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFN1cGFiYXNlIHNlbGVjdCBkZWFscyBieSBpZFxyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgZGVhbCA9IG1vY2tEZWFscy5maW5kKChkKSA9PiBkLmlkID09PSBpZCk7XHJcbiAgaWYgKCFkZWFsKSB0aHJvdyBuZXcgRXJyb3IoJ0RlYWwgbm90IGZvdW5kJyk7XHJcbiAgcmV0dXJuIGRlYWw7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY3Rpdml0aWVzRm9yKHJlbGF0ZWRUeXBlOiAnZGVhbCd8J2NvbnRhY3QnfCdjb21wYW55JywgcmVsYXRlZElkOiBzdHJpbmcpOiBQcm9taXNlPEFjdGl2aXR5W10+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGFjdGl2aXRpZXMgd2hlcmUgcmVsYXRlZF90eXBlID0gcmVsYXRlZFR5cGUgYW5kIHJlbGF0ZWRfaWQgPSByZWxhdGVkSWQgb3JkZXIgYnkgY3JlYXRlZF9hdCBkZXNjXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICByZXR1cm4gbW9ja0FjdGl2aXRpZXMuZmlsdGVyKChhKSA9PiBhLnJlbGF0ZWRfdHlwZSA9PT0gcmVsYXRlZFR5cGUgJiYgYS5yZWxhdGVkX2lkID09PSByZWxhdGVkSWQpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gK25ldyBEYXRlKGIuY3JlYXRlZF9hdCkgLSArbmV3IERhdGUoYS5jcmVhdGVkX2F0KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3Q+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGNvbnRhY3RzIGJ5IGlkXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBjID0gbW9ja0NvbnRhY3RzW2lkXTtcclxuICBpZiAoIWMpIHRocm93IG5ldyBFcnJvcignQ29udGFjdCBub3QgZm91bmQnKTtcclxuICByZXR1cm4gYztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwcmludCAyIOKAlCBDb250YWN0UXVpY2sgYWN0aW9uczogaW50ZXJlc3RlZCAvIG5vdF9pbnRlcmVzdGVkIHRvZ2dsZVxyXG4gKiBHZXLDp2VrIGVudGVncmFzeW9uZGEgUE9TVCAvY3JtL2FjdGlvbnMvY29udGFjdHMgw6dhxJ9yxLFzxLFuYSBkw7Zuw7zFn2VjZWt0aXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29udGFjdFN0YXR1cyhcclxuICBjb250YWN0SWQ6IHN0cmluZyxcclxuICBzdGF0dXM6ICdpbnRlcmVzdGVkJyB8ICdub3RfaW50ZXJlc3RlZCdcclxuKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgY29udGFjdD86IENvbnRhY3QgfT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgYyA9IG1vY2tDb250YWN0c1tjb250YWN0SWRdO1xyXG4gIGlmICghYykgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0NvbnRhY3Qgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0geyAuLi5jIH07XHJcbiAgYy5yZXBseV9zdGF0dXMgPSBzdGF0dXM7XHJcblxyXG4gIC8vIExvZyBhY3Rpdml0eVxyXG4gIG1vY2tBY3Rpdml0aWVzLnB1c2goe1xyXG4gICAgaWQ6IGBhXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgdHlwZTogJ3N5c3RlbScsXHJcbiAgICByZWxhdGVkX3R5cGU6ICdjb250YWN0JyxcclxuICAgIHJlbGF0ZWRfaWQ6IGNvbnRhY3RJZCxcclxuICAgIGNvbnRlbnQ6ICdDb250YWN0IHN0YXR1cyBjaGFuZ2VkJyxcclxuICAgIG1ldGFfanNvbjogeyBmcm9tOiBwcmV2LnJlcGx5X3N0YXR1cywgdG86IHN0YXR1cyB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICAvLyBPdXRib3VuZCB3ZWJob29rIChsb2ctb25seSwgbW9jaylcclxuICAvLyBJbiByZWFsIGltcGw6IGZpcmUtYW5kLWZvcmdldCBQT1NUIHdpdGggZXZlbnRfdHlwZT1jb250YWN0X3N0YXR1c19jaGFuZ2VkXHJcblxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBjb250YWN0OiBjIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcHJpbnQgMiDigJQgQ29udGFjdFF1aWNrIGFjdGlvbnM6IHNlbmQgY2FsZW5kYXIgbGluayAocGxhY2Vob2xkZXIpXHJcbiAqIFMyOiB5YWxuxLF6Y2EgbGluayDDvHJldGlwIGTDtm5kw7xyw7xyOyBTMzogZ2Vyw6dlayBlLXBvc3RhL21lc2FqIG90b21hc3lvbnUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJMaW5rKGNvbnRhY3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyB1cmw6IHN0cmluZyB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBiYXNlID0gJ2h0dHBzOi8vY2FsLmNvbS95b3VyLXRlYW0vMzBtaW4nO1xyXG4gIC8vIGJhc2l0w6dlIGtpxZ9pIGUtcG9zdGFzxLFuxLEgcXVlcnkgb2xhcmFrIGlsacWfdGlyXHJcbiAgY29uc3QgZW1haWwgPSBtb2NrQ29udGFjdHNbY29udGFjdElkXT8uZW1haWwgfHwgJ3Byb3NwZWN0QGV4YW1wbGUuY29tJztcclxuICBjb25zdCB1cmwgPSBgJHtiYXNlfT9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9YDtcclxuICByZXR1cm4geyBvazogdHJ1ZSwgdXJsIH07XHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBjb21wdXRlIHN0YWdlIG5hbWUgZm9yIGEgZ2l2ZW4gc3RhZ2VfaWQgKHVzZWZ1bCBmb3IgVUkpXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZU5hbWUocGlwZWxpbmVJZDogc3RyaW5nLCBzdGFnZUlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xyXG4gIGNvbnN0IHN0YWdlcyA9IGF3YWl0IGdldFBpcGVsaW5lU3RhZ2VzKHBpcGVsaW5lSWQpO1xyXG4gIHJldHVybiBzdGFnZXMuZmluZCgocykgPT4gcy5pZCA9PT0gc3RhZ2VJZCk/Lm5hbWU7XHJcbn1cclxuXHJcbi8vIERlbW8tb25seSBoZWxwZXJzIHRvIGJyaWRnZSBtb2NrIHJlbGF0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udGFjdEZvckRlYWwoZGVhbElkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3QgfCB1bmRlZmluZWQ+IHtcclxuICBjb25zdCBjb250YWN0SWQgPSBkZWFsVG9Db250YWN0W2RlYWxJZF07XHJcbiAgaWYgKCFjb250YWN0SWQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgcmV0dXJuIGdldENvbnRhY3QoY29udGFjdElkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydGluZyBoZWxwZXJzIChTbmFwc2hvdCBNVlApXHJcbiAqIE5vdGU6IE1vY2sgaW1wbGVtZW50YXRpb24gdXNpbmcgaW4tbWVtb3J5IGRhdGE7IHJlcGxhY2Ugd2l0aCBTdXBhYmFzZS9FZGdlIHF1ZXJpZXMgbGF0ZXIuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBEZWFsVXBkYXRlSW5wdXQgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZT86IHN0cmluZztcclxuICBhbW91bnQ/OiBudW1iZXI7XHJcbiAgY3VycmVuY3k/OiBzdHJpbmc7XHJcbiAgY2xvc2VfZGF0ZT86IHN0cmluZzsgLy8gSVNPXHJcbiAgc3RhZ2VfaWQ/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVhbChpbnB1dDogRGVhbFVwZGF0ZUlucHV0LCBvcHRpb25zPzogeyBzaW11bGF0ZUVycm9yPzogYm9vbGVhbiB9KTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgZGVhbD86IERlYWwgfT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgaWYgKG9wdGlvbnM/LnNpbXVsYXRlRXJyb3IpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdTaW11bGF0ZWQgdXBkYXRlIGVycm9yJyB9O1xyXG5cclxuICBjb25zdCBpZHggPSBtb2NrRGVhbHMuZmluZEluZGV4KChkKSA9PiBkLmlkID09PSBpbnB1dC5pZCk7XHJcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdEZWFsIG5vdCBmb3VuZCcgfTtcclxuXHJcbiAgY29uc3QgcHJldiA9IG1vY2tEZWFsc1tpZHhdO1xyXG4gIC8vIGJhc2ljIHZhbGlkYXRpb25cclxuICBpZiAodHlwZW9mIGlucHV0LmFtb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgTnVtYmVyLmlzTmFOKE51bWJlcihpbnB1dC5hbW91bnQpKSkge1xyXG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0Ftb3VudCBtdXN0IGJlIG51bWVyaWMnIH07XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgaW5wdXQuY2xvc2VfZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGNvbnN0IHQgPSBEYXRlLnBhcnNlKGlucHV0LmNsb3NlX2RhdGUpO1xyXG4gICAgaWYgKE51bWJlci5pc05hTih0KSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ2Nsb3NlX2RhdGUgbXVzdCBiZSBJU08gc3RyaW5nJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbmV4dDogRGVhbCA9IHtcclxuICAgIC4uLnByZXYsXHJcbiAgICB0aXRsZTogaW5wdXQudGl0bGUgPz8gcHJldi50aXRsZSxcclxuICAgIGFtb3VudDogdHlwZW9mIGlucHV0LmFtb3VudCAhPT0gJ3VuZGVmaW5lZCcgPyBOdW1iZXIoaW5wdXQuYW1vdW50KSA6IHByZXYuYW1vdW50LFxyXG4gICAgY3VycmVuY3k6IGlucHV0LmN1cnJlbmN5ID8/IHByZXYuY3VycmVuY3ksXHJcbiAgICBjbG9zZV9kYXRlOiBpbnB1dC5jbG9zZV9kYXRlID8/IHByZXYuY2xvc2VfZGF0ZSxcclxuICAgIHN0YWdlX2lkOiBpbnB1dC5zdGFnZV9pZCA/PyBwcmV2LnN0YWdlX2lkLFxyXG4gIH07XHJcbiAgbW9ja0RlYWxzW2lkeF0gPSBuZXh0O1xyXG5cclxuICAvLyBsb2cgYWN0aXZpdHlcclxuICBjb25zdCBjaGFuZ2VkOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XHJcbiAgZm9yIChjb25zdCBrIG9mIFsndGl0bGUnLCAnYW1vdW50JywgJ2N1cnJlbmN5JywgJ2Nsb3NlX2RhdGUnLCAnc3RhZ2VfaWQnXSBhcyBjb25zdCkge1xyXG4gICAgaWYgKChwcmV2IGFzIGFueSlba10gIT09IChuZXh0IGFzIGFueSlba10pIGNoYW5nZWRba10gPSB7IGZyb206IChwcmV2IGFzIGFueSlba10sIHRvOiAobmV4dCBhcyBhbnkpW2tdIH07XHJcbiAgfVxyXG4gIG1vY2tBY3Rpdml0aWVzLnB1c2goe1xyXG4gICAgaWQ6IGBhXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgdHlwZTogJ3N5c3RlbScsXHJcbiAgICByZWxhdGVkX3R5cGU6ICdkZWFsJyxcclxuICAgIHJlbGF0ZWRfaWQ6IGlucHV0LmlkLFxyXG4gICAgY29udGVudDogJ0RlYWwgdXBkYXRlZCcsXHJcbiAgICBtZXRhX2pzb246IHsgY2hhbmdlZCB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4geyBvazogdHJ1ZSwgZGVhbDogbmV4dCB9O1xyXG59XHJcblxyXG4vKipcclxuICogU3ByaW50IDIgLSDEsGxrIEfDtnJldjogS2FuYmFuIERyYWcgJiBEcm9wIOKGkiBTdGFnZSBDaGFuZ2VcclxuICogTW9jayBvcnRhbWRhIG9wdGltaXN0aWMgVUkgYWvEscWfxLFuxLEgZG/En3J1bGFtYWsgacOnaW4gc3RhZ2UgZ8O8bmNlbGxlbWUgaGVscGVyJ8SxLlxyXG4gKiBHZXLDp2VrIGVudGVncmFzeW9uZGEgYnUgZm9ua3NpeW9uLCBFZGdlIEZ1bmN0aW9uJ2EgKFBPU1QgL2NybS9hY3Rpb25zL2RlYWxzLzppZC9zdGFnZSkgw6dhxJ9yxLEgeWFwYWNhay5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVEZWFsU3RhZ2UoXHJcbiAgZGVhbElkOiBzdHJpbmcsXHJcbiAgbmV4dFN0YWdlSWQ6IHN0cmluZyxcclxuICBvcHRpb25zPzogeyBvY2N1cnJlZEF0SVNPPzogc3RyaW5nOyBpZGVtcG90ZW5jeUtleT86IHN0cmluZzsgc2ltdWxhdGVFcnJvcj86IGJvb2xlYW4gfVxyXG4pOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyBkZWFsPzogRGVhbCB9PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBpZiAob3B0aW9ucz8uc2ltdWxhdGVFcnJvcikge1xyXG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ1NpbXVsYXRlZCBuZXR3b3JrL3NlcnZlciBlcnJvcicgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlkeCA9IG1vY2tEZWFscy5maW5kSW5kZXgoKGQpID0+IGQuaWQgPT09IGRlYWxJZCk7XHJcbiAgaWYgKGlkeCA9PT0gLTEpIHtcclxuICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdEZWFsIG5vdCBmb3VuZCcgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHByZXYgPSBtb2NrRGVhbHNbaWR4XTtcclxuICBjb25zdCBuZXh0OiBEZWFsID0geyAuLi5wcmV2LCBzdGFnZV9pZDogbmV4dFN0YWdlSWQgfTtcclxuICBtb2NrRGVhbHNbaWR4XSA9IG5leHQ7XHJcblxyXG4gIC8vIFN5c3RlbSBhY3Rpdml0eSBpbnNlcnQgKG1vY2spXHJcbiAgbW9ja0FjdGl2aXRpZXMucHVzaCh7XHJcbiAgICBpZDogYGFfJHtEYXRlLm5vdygpfWAsXHJcbiAgICB0eXBlOiAnc3lzdGVtJyxcclxuICAgIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLFxyXG4gICAgcmVsYXRlZF9pZDogZGVhbElkLFxyXG4gICAgY29udGVudDogJ1N0YWdlIGNoYW5nZWQnLFxyXG4gICAgbWV0YV9qc29uOiB7IGZyb206IHByZXYuc3RhZ2VfaWQsIHRvOiBuZXh0U3RhZ2VJZCwgb2NjdXJyZWRfYXQ6IG9wdGlvbnM/Lm9jY3VycmVkQXRJU08gfSxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9KTtcclxuXHJcbiAgLy8gT3V0Ym91bmQgd2ViaG9vayAobG9nLW9ubHksIG1vY2spXHJcbiAgLy8gSW4gcmVhbCBpbXBsOiBmaXJlLWFuZC1mb3JnZXQgUE9TVCB0byBvdXRib3VuZCBlbmRwb2ludCB3aXRoIGV2ZW50X3R5cGU9ZGVhbF9zdGFnZV9jaGFuZ2VkXHJcblxyXG4gIHJldHVybiB7IG9rOiB0cnVlLCBkZWFsOiBuZXh0IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBvcnRpbmcgKE1WUCwgbW9jaylcclxuICogLSBvcGVuIGRlYWxzIGNvdW50XHJcbiAqIC0gbGFzdCA3IGRheXMgcmVwbHkgY291bnQgKGVtYWlsX2luKVxyXG4gKiAtIHNpbXBsZSBwaXBlbGluZSBjb252ZXJzaW9uIChzdGFnZS10by1zdGFnZSByYXRpb3Mgd2l0aGluIGN1cnJlbnQgbW9jayBzbmFwc2hvdClcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcGVuRGVhbHNDb3VudChwaXBlbGluZUlkPzogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGNvbnN0IGxpc3QgPSBwaXBlbGluZUlkID8gbW9ja0RlYWxzLmZpbHRlcihkID0+IGQucGlwZWxpbmVfaWQgPT09IHBpcGVsaW5lSWQpIDogbW9ja0RlYWxzO1xyXG4gIC8vIE9wZW4gPSBub3QgV29uIGFuZCBub3QgTG9zdFxyXG4gIHJldHVybiBsaXN0LmZpbHRlcihkID0+IGQuc3RhZ2VfaWQgIT09ICdzX3dvbicgJiYgZC5zdGFnZV9pZCAhPT0gJ3NfbG9zdCcpLmxlbmd0aDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExhc3Q3RGF5c1JlcGx5Q291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgY29uc3Qgc2V2ZW5EYXlzID0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcbiAgcmV0dXJuIG1vY2tBY3Rpdml0aWVzLmZpbHRlcihhID0+XHJcbiAgICBhLnR5cGUgPT09ICdlbWFpbF9pbicgJiYgKG5vdyAtICtuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpKSA8PSBzZXZlbkRheXNcclxuICApLmxlbmd0aDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUGlwZWxpbmVDb252ZXJzaW9uID0ge1xyXG4gIHN0YWdlX2lkOiBzdHJpbmc7XHJcbiAgc3RhZ2VfbmFtZTogc3RyaW5nO1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgY29udmVyc2lvbl90b19uZXh0PzogbnVtYmVyOyAvLyBwZXJjZW50IFswLi4xMDBdXHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGlwZWxpbmVDb252ZXJzaW9uKHBpcGVsaW5lSWQ6IHN0cmluZyA9ICdwX2RlZmF1bHQnKTogUHJvbWlzZTxQaXBlbGluZUNvbnZlcnNpb25bXT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3Qgc3RhZ2VzID0gbW9ja1N0YWdlc1xyXG4gICAgLmZpbHRlcihzID0+IHMucGlwZWxpbmVfaWQgPT09IHBpcGVsaW5lSWQpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpO1xyXG5cclxuICBjb25zdCBieVN0YWdlQ291bnQ6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICBmb3IgKGNvbnN0IHMgb2Ygc3RhZ2VzKSBieVN0YWdlQ291bnRbcy5pZF0gPSAwO1xyXG4gIGZvciAoY29uc3QgZCBvZiBtb2NrRGVhbHMpIHtcclxuICAgIGlmIChkLnBpcGVsaW5lX2lkICE9PSBwaXBlbGluZUlkKSBjb250aW51ZTtcclxuICAgIGlmIChieVN0YWdlQ291bnRbZC5zdGFnZV9pZF0gIT09IHVuZGVmaW5lZCkgYnlTdGFnZUNvdW50W2Quc3RhZ2VfaWRdICs9IDE7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXN1bHQ6IFBpcGVsaW5lQ29udmVyc2lvbltdID0gc3RhZ2VzLm1hcCgocywgaWR4KSA9PiB7XHJcbiAgICBjb25zdCBjb3VudCA9IGJ5U3RhZ2VDb3VudFtzLmlkXSB8fCAwO1xyXG4gICAgbGV0IGNvbnZlcnNpb246IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChpZHggPCBzdGFnZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICBjb25zdCBuZXh0U3RhZ2UgPSBzdGFnZXNbaWR4ICsgMV07XHJcbiAgICAgIGNvbnN0IG5leHRDb3VudCA9IGJ5U3RhZ2VDb3VudFtuZXh0U3RhZ2UuaWRdIHx8IDA7XHJcbiAgICAgIC8vIG5haXZlIHJhdGlvIHVzaW5nIHNuYXBzaG90IGNvdW50cyAobm90IGNvaG9ydC1iYXNlZClcclxuICAgICAgY29udmVyc2lvbiA9IGNvdW50ID4gMCA/IE1hdGgucm91bmQoKG5leHRDb3VudCAvIGNvdW50KSAqIDEwMCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdGFnZV9pZDogcy5pZCwgc3RhZ2VfbmFtZTogcy5uYW1lLCBjb3VudCwgY29udmVyc2lvbl90b19uZXh0OiBjb252ZXJzaW9uIH07XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbIk1PQ0tfREVMQVkiLCJzbGVlcCIsIm1zIiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJtb2NrU3RhZ2VzIiwiaWQiLCJuYW1lIiwib3JkZXJfaW5kZXgiLCJwcm9iYWJpbGl0eSIsInBpcGVsaW5lX2lkIiwibW9ja0RlYWxzIiwidGl0bGUiLCJzdGFnZV9pZCIsImFtb3VudCIsImN1cnJlbmN5Iiwic291cmNlIiwibW9ja0NvbnRhY3RzIiwiYzEiLCJmdWxsX25hbWUiLCJlbWFpbCIsImxpbmtlZGluX3VybCIsIndlYnNpdGUiLCJjMiIsInJlcGx5X3N0YXR1cyIsInJlcGx5X3N1bW1hcnkiLCJtb2NrQWN0aXZpdGllcyIsInR5cGUiLCJyZWxhdGVkX3R5cGUiLCJyZWxhdGVkX2lkIiwiY29udGVudCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJkZWFsVG9Db250YWN0IiwiZDEiLCJkMiIsImQzIiwiZ2V0UGlwZWxpbmVTdGFnZXMiLCJwaXBlbGluZUlkIiwiZmlsdGVyIiwicyIsInNvcnQiLCJhIiwiYiIsImdldERlYWxzQnlQaXBlbGluZSIsImQiLCJnZXREZWFsRGV0YWlsIiwiZGVhbCIsImZpbmQiLCJFcnJvciIsImdldEFjdGl2aXRpZXNGb3IiLCJyZWxhdGVkVHlwZSIsInJlbGF0ZWRJZCIsImdldENvbnRhY3QiLCJjIiwidXBkYXRlQ29udGFjdFN0YXR1cyIsImNvbnRhY3RJZCIsInN0YXR1cyIsIm9rIiwiZXJyb3IiLCJwcmV2IiwicHVzaCIsIm1ldGFfanNvbiIsImZyb20iLCJ0byIsImNvbnRhY3QiLCJnZXRDYWxlbmRhckxpbmsiLCJiYXNlIiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0U3RhZ2VOYW1lIiwic3RhZ2VJZCIsInN0YWdlcyIsImdldENvbnRhY3RGb3JEZWFsIiwiZGVhbElkIiwidW5kZWZpbmVkIiwidXBkYXRlRGVhbCIsImlucHV0Iiwib3B0aW9ucyIsInNpbXVsYXRlRXJyb3IiLCJpZHgiLCJmaW5kSW5kZXgiLCJOdW1iZXIiLCJpc05hTiIsImNsb3NlX2RhdGUiLCJ0IiwicGFyc2UiLCJuZXh0IiwiY2hhbmdlZCIsImsiLCJ1cGRhdGVEZWFsU3RhZ2UiLCJuZXh0U3RhZ2VJZCIsIm9jY3VycmVkX2F0Iiwib2NjdXJyZWRBdElTTyIsImdldE9wZW5EZWFsc0NvdW50IiwibGlzdCIsImxlbmd0aCIsImdldExhc3Q3RGF5c1JlcGx5Q291bnQiLCJzZXZlbkRheXMiLCJnZXRQaXBlbGluZUNvbnZlcnNpb24iLCJieVN0YWdlQ291bnQiLCJyZXN1bHQiLCJtYXAiLCJjb3VudCIsImNvbnZlcnNpb24iLCJuZXh0U3RhZ2UiLCJuZXh0Q291bnQiLCJNYXRoIiwicm91bmQiLCJzdGFnZV9uYW1lIiwiY29udmVyc2lvbl90b19uZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});