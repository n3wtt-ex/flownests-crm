"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   isSupabaseConfigured: function() { return /* binding */ isSupabaseConfigured; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// Supabase-backed CRM API helpers (SSR/RLS friendly)\n// Falls back to mock when env is missing. Types from supabase.types.ts\n\n// Exported\nconst SUPABASE_URL = \"https://jkrxflynplzczpkzhygs.supabase.co\";\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImprcnhmbHlucGx6Y3pwa3poeWdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzNDczOTksImV4cCI6MjA2OTkyMzM5OX0.QYOOVOK4cI44IsSQz1MGdSQbUKJwI4frO-YdNv8hvpU\";\nlet supabase = null;\nfunction getClient() {\n    if (supabase) return supabase;\n    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) return null;\n    supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            persistSession: false\n        }\n    });\n    return supabase;\n}\n// Mock fallback for dev without env configured\nconst mock = {\n    stages: [\n        {\n            id: \"s1\",\n            name: \"New\",\n            order_index: 10,\n            probability: 10\n        },\n        {\n            id: \"s2\",\n            name: \"Contacted\",\n            order_index: 20,\n            probability: 25\n        },\n        {\n            id: \"s3\",\n            name: \"Qualified\",\n            order_index: 30,\n            probability: 45\n        }\n    ],\n    dealsByStage: {\n        s1: [\n            {\n                id: \"d1\",\n                title: \"Acme - Pilot\",\n                stage_id: \"s1\",\n                amount: 2500,\n                currency: \"USD\"\n            }\n        ],\n        s2: [],\n        s3: []\n    },\n    activities: [\n        {\n            id: \"a1\",\n            type: \"system\",\n            related_type: \"deal\",\n            related_id: \"d1\",\n            content: \"Seed: deal created\",\n            meta_json: null,\n            created_by: null,\n            created_at: new Date().toISOString()\n        }\n    ],\n    contact: {\n        id: \"c1\",\n        email: \"john@acme.com\",\n        full_name: \"John Doe\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/johndoe\",\n        website: \"https://acme.com\",\n        phone: null,\n        company_id: null,\n        owner_id: null,\n        lifecycle_stage: \"lead\",\n        reply_status: null,\n        reply_summary: null,\n        generated_body_step1: null,\n        generated_body_step2: null,\n        generated_body_step3: null,\n        latest_email_sent_at: null,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    }\n};\nasync function getPipelineStages(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.stages;\n    // default pipeline resolve\n    const pipeline = pipelineId && pipelineId !== \"p_default\" ? {\n        id: pipelineId\n    } : await (async ()=>{\n        const { data, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        return data;\n    })();\n    if (!(pipeline === null || pipeline === void 0 ? void 0 : pipeline.id)) return [];\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"id,name,order_index,probability\").eq(\"pipeline_id\", pipeline.id).order(\"order_index\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getDealsByPipeline(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.dealsByStage;\n    // resolve pipeline id\n    let pid = pipelineId && pipelineId !== \"p_default\" ? pipelineId : undefined;\n    if (!pid) {\n        const { data, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        pid = data === null || data === void 0 ? void 0 : data.id;\n    }\n    if (!pid) return {};\n    // fetch deals + join names\n    const { data: deals, error } = await supabase.from(\"deals\").select(\"id,title,amount,currency,stage_id,company_id,contact_id\").eq(\"pipeline_id\", pid);\n    if (error) throw error;\n    // fetch related names in one go\n    const companyIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.company_id).filter(Boolean)));\n    const contactIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.contact_id).filter(Boolean)));\n    const [companiesRes, contactsRes] = await Promise.all([\n        companyIds.length ? supabase.from(\"companies\").select(\"id,name\").in(\"id\", companyIds) : Promise.resolve({\n            data: [],\n            error: null\n        }),\n        contactIds.length ? supabase.from(\"contacts\").select(\"id,full_name\").in(\"id\", contactIds) : Promise.resolve({\n            data: [],\n            error: null\n        })\n    ]);\n    if (companiesRes.error) throw companiesRes.error;\n    if (contactsRes.error) throw contactsRes.error;\n    var _companiesRes_data;\n    const companyMap = new Map(((_companiesRes_data = companiesRes.data) !== null && _companiesRes_data !== void 0 ? _companiesRes_data : []).map((c)=>[\n            c.id,\n            c.name\n        ]));\n    var _contactsRes_data;\n    const contactMap = new Map(((_contactsRes_data = contactsRes.data) !== null && _contactsRes_data !== void 0 ? _contactsRes_data : []).map((c)=>[\n            c.id,\n            c.full_name\n        ]));\n    const grouped = {};\n    for (const d of deals !== null && deals !== void 0 ? deals : []){\n        var _d_amount, _d_currency, _companyMap_get, _contactMap_get;\n        const card = {\n            id: d.id,\n            title: d.title,\n            amount: (_d_amount = d.amount) !== null && _d_amount !== void 0 ? _d_amount : null,\n            currency: (_d_currency = d.currency) !== null && _d_currency !== void 0 ? _d_currency : null,\n            stage_id: d.stage_id,\n            company: d.company_id ? (_companyMap_get = companyMap.get(d.company_id)) !== null && _companyMap_get !== void 0 ? _companyMap_get : null : null,\n            contact: d.contact_id ? (_contactMap_get = contactMap.get(d.contact_id)) !== null && _contactMap_get !== void 0 ? _contactMap_get : null : null\n        };\n        if (!grouped[d.stage_id]) grouped[d.stage_id] = [];\n        grouped[d.stage_id].push(card);\n    }\n    return grouped;\n}\nasync function getDealDetail(id) {\n    const supabase = getClient();\n    if (!supabase) {\n        const anyDeal = Object.values(mock.dealsByStage).flat()[0];\n        if (!anyDeal) return null;\n        var _anyDeal_amount, _anyDeal_currency;\n        // minimal mock cast\n        return {\n            id: anyDeal.id,\n            title: anyDeal.title,\n            amount: (_anyDeal_amount = anyDeal.amount) !== null && _anyDeal_amount !== void 0 ? _anyDeal_amount : null,\n            currency: (_anyDeal_currency = anyDeal.currency) !== null && _anyDeal_currency !== void 0 ? _anyDeal_currency : null,\n            company_id: null,\n            contact_id: null,\n            pipeline_id: \"default\",\n            stage_id: anyDeal.stage_id,\n            status: \"open\",\n            source: \"inbound\",\n            notes: \"Mock\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n            close_date: null\n        };\n    }\n    const { data, error } = await supabase.from(\"deals\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    const supabase = getClient();\n    if (!supabase) return mock.activities;\n    const { data, error } = await supabase.from(\"activities\").select(\"*\").eq(\"related_type\", relatedType).eq(\"related_id\", relatedId).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getContact(id) {\n    const supabase = getClient();\n    if (!supabase) return mock.contact;\n    const { data, error } = await supabase.from(\"contacts\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\n// Added to resolve a build error where 'getContactForDeal' was reported as missing,\n// even though it's not explicitly imported in the relevant files.\n// It simply delegates to getContact, as that's the intended logic.\nasync function getContactForDeal(contactId) {\n    return getContact(contactId);\n}\n// Added to resolve a build error where 'getStageName' was reported as missing.\nasync function getStageName(stageId) {\n    var _mock_stages_find;\n    const supabase = getClient();\n    if (!supabase) return (_mock_stages_find = mock.stages.find((s)=>s.id === stageId)) === null || _mock_stages_find === void 0 ? void 0 : _mock_stages_find.name;\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"name\").eq(\"id\", stageId).maybeSingle();\n    if (error) throw error;\n    return data === null || data === void 0 ? void 0 : data.name;\n}\n// Actions (write) — protected by RLS; expect JWT in frontend context.\n// For SSR/Edge secure writes, prefer server-only key or edge function proxy.\nasync function updateDealStage(dealId, nextStageId) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"deals\").update({\n        stage_id: nextStageId\n    }).eq(\"id\", dealId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function updateContactStatus(contactId, status) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"contacts\").update({\n        reply_status: status\n    }).eq(\"id\", contactId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function getCalendarLink(contactId) {\n    // This is a mock implementation. In a real app, you'd generate a unique link\n    // or fetch it from a calendar service.\n    return {\n        ok: true,\n        url: \"https://cal.com/your-username/\".concat(contactId)\n    };\n}\n// Helper to detect env presence\nfunction isSupabaseConfigured() {\n    return Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);\n}\nasync function getOpenDealsCount(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return 42; // Mock data\n    let query = supabase.from(\"deals\").select(\"id\", {\n        count: \"exact\"\n    }).eq(\"status\", \"open\");\n    if (pipelineId && pipelineId !== \"p_default\") {\n        query = query.eq(\"pipeline_id\", pipelineId);\n    }\n    const { count, error } = await query;\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getLast7DaysReplyCount() {\n    const supabase = getClient();\n    if (!supabase) return 15; // Mock data\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    const { count, error } = await supabase.from(\"contacts\").select(\"id\", {\n        count: \"exact\"\n    }).not(\"reply_status\", \"is\", null).gte(\"updated_at\", sevenDaysAgo.toISOString()); // Assuming updated_at reflects reply status changes\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getPipelineConversion(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) {\n        return [\n            {\n                stage_id: \"s1\",\n                stage_name: \"New\",\n                count: 10,\n                conversion_to_next: 50\n            },\n            {\n                stage_id: \"s2\",\n                stage_name: \"Contacted\",\n                count: 5,\n                conversion_to_next: 80\n            },\n            {\n                stage_id: \"s3\",\n                stage_name: \"Qualified\",\n                count: 4,\n                conversion_to_next: undefined\n            }\n        ];\n    }\n    // This is a simplified mock for conversion. A real implementation would involve\n    // more complex SQL queries or a materialized view to calculate conversions between stages.\n    const stages = await getPipelineStages(pipelineId);\n    const dealsByStage = await getDealsByPipeline(pipelineId);\n    const stageCounts = {};\n    for (const stage of stages){\n        var _dealsByStage_stage_id;\n        stageCounts[stage.id] = ((_dealsByStage_stage_id = dealsByStage[stage.id]) === null || _dealsByStage_stage_id === void 0 ? void 0 : _dealsByStage_stage_id.length) || 0;\n    }\n    const conversionData = [];\n    for(let i = 0; i < stages.length; i++){\n        const currentStage = stages[i];\n        const currentCount = stageCounts[currentStage.id];\n        let conversionToNext = undefined;\n        if (i < stages.length - 1) {\n            const nextStage = stages[i + 1];\n            const nextCount = stageCounts[nextStage.id];\n            if (currentCount > 0) {\n                conversionToNext = Math.round(nextCount / currentCount * 100);\n            }\n        }\n        conversionData.push({\n            stage_id: currentStage.id,\n            stage_name: currentStage.name,\n            count: currentCount,\n            conversion_to_next: conversionToNext\n        });\n    }\n    return conversionData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEO0FBQ3JELHVFQUF1RTtBQUVuQjtBQXNCWCxXQUFXO0FBRXBELE1BQU1DLGVBQWVDLDBDQUFvQztBQUN6RCxNQUFNRyxvQkFBb0JILGtOQUF5QztBQUVuRSxJQUFJSyxXQUE2RDtBQUVqRSxTQUFTQztJQUNQLElBQUlELFVBQVUsT0FBT0E7SUFDckIsSUFBSSxDQUFDTixnQkFBZ0IsQ0FBQ0ksbUJBQW1CLE9BQU87SUFDaERFLFdBQVdQLG1FQUFZQSxDQUFXQyxjQUFjSSxtQkFBbUI7UUFDakVJLE1BQU07WUFDSkMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBRUEsK0NBQStDO0FBQy9DLE1BQU1JLE9BQU87SUFDWEMsUUFBUTtRQUNOO1lBQUVDLElBQUk7WUFBTUMsTUFBTTtZQUFPQyxhQUFhO1lBQUlDLGFBQWE7UUFBRztRQUMxRDtZQUFFSCxJQUFJO1lBQU1DLE1BQU07WUFBYUMsYUFBYTtZQUFJQyxhQUFhO1FBQUc7UUFDaEU7WUFBRUgsSUFBSTtZQUFNQyxNQUFNO1lBQWFDLGFBQWE7WUFBSUMsYUFBYTtRQUFHO0tBQ2pFO0lBQ0RDLGNBQWM7UUFDWkMsSUFBSTtZQUFDO2dCQUFFTCxJQUFJO2dCQUFNTSxPQUFPO2dCQUFnQkMsVUFBVTtnQkFBTUMsUUFBUTtnQkFBTUMsVUFBVTtZQUFNO1NBQUU7UUFDeEZDLElBQUksRUFBRTtRQUNOQyxJQUFJLEVBQUU7SUFDUjtJQUNBQyxZQUFZO1FBQ1Y7WUFBRVosSUFBSTtZQUFNYSxNQUFNO1lBQVVDLGNBQWM7WUFBUUMsWUFBWTtZQUFNQyxTQUFTO1lBQXNCQyxXQUFXO1lBQU1DLFlBQVk7WUFBTUMsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO1FBQUc7S0FDNUs7SUFDREMsU0FBUztRQUNQdEIsSUFBSTtRQUFNdUIsT0FBTztRQUFpQkMsV0FB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Q0FBQ0ksYUFBYTdILEVBQUUsQ0FBQztRQUNqRCxJQUFJK0gsbUJBQXVDM0U7UUFFM0MsSUFBSXdFLElBQUk3SCxPQUFPb0UsTUFBTSxHQUFHLEdBQUc7WUFDekIsTUFBTTZELFlBQVlqSSxNQUFNLENBQUM2SCxJQUFJLEVBQUU7WUFDL0IsTUFBTUssWUFBWVIsV0FBVyxDQUFDTyxVQUFVaEksRUFBRSxDQUFDO1lBQzNDLElBQUk4SCxlQUFlLEdBQUc7Z0JBQ3BCQyxtQkFBbUJHLEtBQUtDLEtBQUssQ0FBQyxZQUFhTCxlQUFnQjtZQUM3RDtRQUNGO1FBRUFILGVBQWU3QyxJQUFJLENBQUM7WUFDbEJ2RSxVQUFVc0gsYUFBYTdILEVBQUU7WUFDekJ1SCxZQUFZTSxhQUFhNUgsSUFBSTtZQUM3QjhHLE9BQU9lO1lBQ1BOLG9CQUFvQk87UUFDdEI7SUFDRjtJQUVBLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3NlcnZpY2VzL2NybUFwaS50cz84MWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFN1cGFiYXNlLWJhY2tlZCBDUk0gQVBJIGhlbHBlcnMgKFNTUi9STFMgZnJpZW5kbHkpXHJcbi8vIEZhbGxzIGJhY2sgdG8gbW9jayB3aGVuIGVudiBpcyBtaXNzaW5nLiBUeXBlcyBmcm9tIHN1cGFiYXNlLnR5cGVzLnRzXHJcblxyXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXHJcbmltcG9ydCB0eXBlIHsgRGF0YWJhc2UsIFRhYmxlcyB9IGZyb20gJy4vc3VwYWJhc2UudHlwZXMnXHJcblxyXG5leHBvcnQgdHlwZSBEZWFsQ2FyZCA9IHsgLy8gRXhwb3J0ZWRcclxuICBpZDogc3RyaW5nXHJcbiAgdGl0bGU6IHN0cmluZ1xyXG4gIGNvbXBhbnk/OiBzdHJpbmcgfCBudWxsXHJcbiAgY29udGFjdD86IHN0cmluZyB8IG51bGxcclxuICBhbW91bnQ/OiBudW1iZXIgfCBudWxsXHJcbiAgY3VycmVuY3k/OiBzdHJpbmcgfCBudWxsXHJcbiAgc3RhZ2VfaWQ6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGFnZSA9IHsgLy8gRXhwb3J0ZWRcclxuICBpZDogc3RyaW5nXHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgb3JkZXJfaW5kZXg6IG51bWJlclxyXG4gIHByb2JhYmlsaXR5OiBudW1iZXIgfCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEFjdGl2aXR5ID0gVGFibGVzPCdhY3Rpdml0aWVzJz4gLy8gRXhwb3J0ZWRcclxuZXhwb3J0IHR5cGUgRGVhbCA9IFRhYmxlczwnZGVhbHMnPiAvLyBFeHBvcnRlZFxyXG5leHBvcnQgdHlwZSBDb250YWN0ID0gVGFibGVzPCdjb250YWN0cyc+IC8vIEV4cG9ydGVkXHJcblxyXG5jb25zdCBTVVBBQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkxcclxuY29uc3QgU1VQQUJBU0VfQU5PTl9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxyXG5cclxubGV0IHN1cGFiYXNlOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVDbGllbnQ8RGF0YWJhc2U+PiB8IG51bGwgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xyXG4gIGlmIChzdXBhYmFzZSkgcmV0dXJuIHN1cGFiYXNlO1xyXG4gIGlmICghU1VQQUJBU0VfVVJMIHx8ICFTVVBBQkFTRV9BTk9OX0tFWSkgcmV0dXJuIG51bGxcclxuICBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudDxEYXRhYmFzZT4oU1VQQUJBU0VfVVJMLCBTVVBBQkFTRV9BTk9OX0tFWSwge1xyXG4gICAgYXV0aDoge1xyXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2VcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gc3VwYWJhc2U7XHJcbn1cclxuXHJcbi8vIE1vY2sgZmFsbGJhY2sgZm9yIGRldiB3aXRob3V0IGVudiBjb25maWd1cmVkXHJcbmNvbnN0IG1vY2sgPSB7XHJcbiAgc3RhZ2VzOiBbXHJcbiAgICB7IGlkOiAnczEnLCBuYW1lOiAnTmV3Jywgb3JkZXJfaW5kZXg6IDEwLCBwcm9iYWJpbGl0eTogMTAgfSxcclxuICAgIHsgaWQ6ICdzMicsIG5hbWU6ICdDb250YWN0ZWQnLCBvcmRlcl9pbmRleDogMjAsIHByb2JhYmlsaXR5OiAyNSB9LFxyXG4gICAgeyBpZDogJ3MzJywgbmFtZTogJ1F1YWxpZmllZCcsIG9yZGVyX2luZGV4OiAzMCwgcHJvYmFiaWxpdHk6IDQ1IH1cclxuICBdIGFzIFN0YWdlW10sXHJcbiAgZGVhbHNCeVN0YWdlOiB7XHJcbiAgICBzMTogW3sgaWQ6ICdkMScsIHRpdGxlOiAnQWNtZSAtIFBpbG90Jywgc3RhZ2VfaWQ6ICdzMScsIGFtb3VudDogMjUwMCwgY3VycmVuY3k6ICdVU0QnIH1dLFxyXG4gICAgczI6IFtdLFxyXG4gICAgczM6IFtdXHJcbiAgfSBhcyBSZWNvcmQ8c3RyaW5nLCBEZWFsQ2FyZFtdPixcclxuICBhY3Rpdml0aWVzOiBbXHJcbiAgICB7IGlkOiAnYTEnLCB0eXBlOiAnc3lzdGVtJywgcmVsYXRlZF90eXBlOiAnZGVhbCcsIHJlbGF0ZWRfaWQ6ICdkMScsIGNvbnRlbnQ6ICdTZWVkOiBkZWFsIGNyZWF0ZWQnLCBtZXRhX2pzb246IG51bGwsIGNyZWF0ZWRfYnk6IG51bGwsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgXSBhcyBBY3Rpdml0eVtdLFxyXG4gIGNvbnRhY3Q6IHtcclxuICAgIGlkOiAnYzEnLCBlbWFpbDogJ2pvaG5AYWNtZS5jb20nLCBmdWxsX25hbWU6ICdKb2huIERvZScsIHRpdGxlOiAnVlAgU2FsZXMnLFxyXG4gICAgbGlua2VkaW5fdXJsOiAnaHR0cHM6Ly9saW5rZWRpbi5jb20vaW4vam9obmRvZScsIHdlYnNpdGU6ICdodHRwczovL2FjbWUuY29tJyxcclxuICAgIHBob25lOiBudWxsLCBjb21wYW55X2lkOiBudWxsLCBvd25lcl9pZDogbnVsbCwgbGlmZWN5Y2xlX3N0YWdlOiAnbGVhZCcsXHJcbiAgICByZXBseV9zdGF0dXM6IG51bGwsIHJlcGx5X3N1bW1hcnk6IG51bGwsIGdlbmVyYXRlZF9ib2R5X3N0ZXAxOiBudWxsLCBnZW5lcmF0ZWRfYm9keV9zdGVwMjogbnVsbCwgZ2VuZXJhdGVkX2JvZHlfc3RlcDM6IG51bGwsXHJcbiAgICBsYXRlc3RfZW1haWxfc2VudF9hdDogbnVsbCwgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICB9IGFzIENvbnRhY3RcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBpcGVsaW5lU3RhZ2VzKHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPFN0YWdlW10+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpXHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suc3RhZ2VzXHJcblxyXG4gIC8vIGRlZmF1bHQgcGlwZWxpbmUgcmVzb2x2ZVxyXG4gIGNvbnN0IHBpcGVsaW5lID0gKHBpcGVsaW5lSWQgJiYgcGlwZWxpbmVJZCAhPT0gJ3BfZGVmYXVsdCcpXHJcbiAgICA/IHsgaWQ6IHBpcGVsaW5lSWQgfVxyXG4gICAgOiBhd2FpdCAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3BpcGVsaW5lcycpLnNlbGVjdCgnaWQnKS5lcSgnaXNfZGVmYXVsdCcsIHRydWUpLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSkubGltaXQoMSkubWF5YmVTaW5nbGUoKVxyXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICAgICAgICByZXR1cm4gZGF0YVxyXG4gICAgICB9KSgpXHJcblxyXG4gIGlmICghcGlwZWxpbmU/LmlkKSByZXR1cm4gW11cclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdwaXBlbGluZV9zdGFnZXMnKVxyXG4gICAgLnNlbGVjdCgnaWQsbmFtZSxvcmRlcl9pbmRleCxwcm9iYWJpbGl0eScpXHJcbiAgICAuZXEoJ3BpcGVsaW5lX2lkJywgcGlwZWxpbmUuaWQpXHJcbiAgICAub3JkZXIoJ29yZGVyX2luZGV4JywgeyBhc2NlbmRpbmc6IHRydWUgfSlcclxuXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gIHJldHVybiAoZGF0YSA/PyBbXSkgYXMgU3RhZ2VbXVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbHNCeVBpcGVsaW5lKHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIERlYWxDYXJkW10+PiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLmRlYWxzQnlTdGFnZVxyXG5cclxuICAvLyByZXNvbHZlIHBpcGVsaW5lIGlkXHJcbiAgbGV0IHBpZCA9IChwaXBlbGluZUlkICYmIHBpcGVsaW5lSWQgIT09ICdwX2RlZmF1bHQnKSA/IHBpcGVsaW5lSWQgOiB1bmRlZmluZWQ7XHJcbiAgaWYgKCFwaWQpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3BpcGVsaW5lcycpLnNlbGVjdCgnaWQnKS5lcSgnaXNfZGVmYXVsdCcsIHRydWUpLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSkubGltaXQoMSkubWF5YmVTaW5nbGUoKVxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcGlkID0gKGRhdGEgYXMgeyBpZDogc3RyaW5nIH0gfCBudWxsKT8uaWRcclxuICB9XHJcbiAgaWYgKCFwaWQpIHJldHVybiB7fVxyXG5cclxuICAvLyBmZXRjaCBkZWFscyArIGpvaW4gbmFtZXNcclxuICBjb25zdCB7IGRhdGE6IGRlYWxzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdkZWFscycpXHJcbiAgICAuc2VsZWN0KCdpZCx0aXRsZSxhbW91bnQsY3VycmVuY3ksc3RhZ2VfaWQsY29tcGFueV9pZCxjb250YWN0X2lkJylcclxuICAgIC5lcSgncGlwZWxpbmVfaWQnLCBwaWQpXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG5cclxuICAvLyBmZXRjaCByZWxhdGVkIG5hbWVzIGluIG9uZSBnb1xyXG4gIGNvbnN0IGNvbXBhbnlJZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoKGRlYWxzID8/IFtdKS5tYXAoKGQ6IGFueSkgPT4gZC5jb21wYW55X2lkKS5maWx0ZXIoQm9vbGVhbikpKSBhcyBzdHJpbmdbXVxyXG4gIGNvbnN0IGNvbnRhY3RJZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoKGRlYWxzID8/IFtdKS5tYXAoKGQ6IGFueSkgPT4gZC5jb250YWN0X2lkKS5maWx0ZXIoQm9vbGVhbikpKSBhcyBzdHJpbmdbXVxyXG5cclxuICBjb25zdCBbY29tcGFuaWVzUmVzLCBjb250YWN0c1Jlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICBjb21wYW55SWRzLmxlbmd0aCA/IHN1cGFiYXNlLmZyb20oJ2NvbXBhbmllcycpLnNlbGVjdCgnaWQsbmFtZScpLmluKCdpZCcsIGNvbXBhbnlJZHMpIDogUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogW10gYXMgeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfVtdLCBlcnJvcjogbnVsbCB9KSxcclxuICAgIGNvbnRhY3RJZHMubGVuZ3RoID8gc3VwYWJhc2UuZnJvbSgnY29udGFjdHMnKS5zZWxlY3QoJ2lkLGZ1bGxfbmFtZScpLmluKCdpZCcsIGNvbnRhY3RJZHMpIDogUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogW10gYXMgeyBpZDogc3RyaW5nOyBmdWxsX25hbWU6IHN0cmluZyB8IG51bGwgfVtdLCBlcnJvcjogbnVsbCB9KVxyXG4gIF0pXHJcblxyXG4gIGlmIChjb21wYW5pZXNSZXMuZXJyb3IpIHRocm93IGNvbXBhbmllc1Jlcy5lcnJvclxyXG4gIGlmIChjb250YWN0c1Jlcy5lcnJvcikgdGhyb3cgY29udGFjdHNSZXMuZXJyb3JcclxuXHJcbiAgY29uc3QgY29tcGFueU1hcCA9IG5ldyBNYXAoKGNvbXBhbmllc1Jlcy5kYXRhID8/IFtdKS5tYXAoKGM6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0pID0+IFtjLmlkLCBjLm5hbWVdKSlcclxuICBjb25zdCBjb250YWN0TWFwID0gbmV3IE1hcCgoY29udGFjdHNSZXMuZGF0YSA/PyBbXSkubWFwKChjOiB7IGlkOiBzdHJpbmc7IGZ1bGxfbmFtZTogc3RyaW5nIHwgbnVsbCB9KSA9PiBbYy5pZCwgYy5mdWxsX25hbWVdKSlcclxuXHJcbiAgY29uc3QgZ3JvdXBlZDogUmVjb3JkPHN0cmluZywgRGVhbENhcmRbXT4gPSB7fVxyXG4gIGZvciAoY29uc3QgZCBvZiAoZGVhbHMgPz8gW10pIGFzIEFycmF5PHtcclxuICAgIGlkOiBzdHJpbmc7IHRpdGxlOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyIHwgbnVsbDsgY3VycmVuY3k6IHN0cmluZyB8IG51bGw7IHN0YWdlX2lkOiBzdHJpbmc7IGNvbXBhbnlfaWQ6IHN0cmluZyB8IG51bGw7IGNvbnRhY3RfaWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgfT4pIHtcclxuICAgIGNvbnN0IGNhcmQ6IERlYWxDYXJkID0ge1xyXG4gICAgICBpZDogZC5pZCxcclxuICAgICAgdGl0bGU6IGQudGl0bGUsXHJcbiAgICAgIGFtb3VudDogZC5hbW91bnQgPz8gbnVsbCxcclxuICAgICAgY3VycmVuY3k6IGQuY3VycmVuY3kgPz8gbnVsbCxcclxuICAgICAgc3RhZ2VfaWQ6IGQuc3RhZ2VfaWQsXHJcbiAgICAgIGNvbXBhbnk6IGQuY29tcGFueV9pZCA/IChjb21wYW55TWFwLmdldChkLmNvbXBhbnlfaWQpID8/IG51bGwpIDogbnVsbCxcclxuICAgICAgY29udGFjdDogZC5jb250YWN0X2lkID8gKGNvbnRhY3RNYXAuZ2V0KGQuY29udGFjdF9pZCkgPz8gbnVsbCkgOiBudWxsXHJcbiAgICB9XHJcbiAgICBpZiAoIWdyb3VwZWRbZC5zdGFnZV9pZF0pIGdyb3VwZWRbZC5zdGFnZV9pZF0gPSBbXVxyXG4gICAgZ3JvdXBlZFtkLnN0YWdlX2lkXS5wdXNoKGNhcmQpXHJcbiAgfVxyXG4gIHJldHVybiBncm91cGVkXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsRGV0YWlsKGlkOiBzdHJpbmcpOiBQcm9taXNlPERlYWwgfCBudWxsPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHtcclxuICAgIGNvbnN0IGFueURlYWwgPSAoT2JqZWN0LnZhbHVlcyhtb2NrLmRlYWxzQnlTdGFnZSkuZmxhdCgpWzBdIGFzIERlYWxDYXJkIHwgdW5kZWZpbmVkKVxyXG4gICAgaWYgKCFhbnlEZWFsKSByZXR1cm4gbnVsbFxyXG4gICAgLy8gbWluaW1hbCBtb2NrIGNhc3RcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBhbnlEZWFsLmlkLFxyXG4gICAgICB0aXRsZTogYW55RGVhbC50aXRsZSxcclxuICAgICAgYW1vdW50OiBhbnlEZWFsLmFtb3VudCA/PyBudWxsLFxyXG4gICAgICBjdXJyZW5jeTogYW55RGVhbC5jdXJyZW5jeSA/PyBudWxsLFxyXG4gICAgICBjb21wYW55X2lkOiBudWxsLFxyXG4gICAgICBjb250YWN0X2lkOiBudWxsLFxyXG4gICAgICBwaXBlbGluZV9pZDogJ2RlZmF1bHQnLFxyXG4gICAgICBzdGFnZV9pZDogYW55RGVhbC5zdGFnZV9pZCxcclxuICAgICAgc3RhdHVzOiAnb3BlbicsXHJcbiAgICAgIHNvdXJjZTogJ2luYm91bmQnLFxyXG4gICAgICBub3RlczogJ01vY2snLFxyXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgY2xvc2VfZGF0ZTogbnVsbFxyXG4gICAgfSBhcyB1bmtub3duIGFzIERlYWxcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2RlYWxzJykuc2VsZWN0KCcqJykuZXEoJ2lkJywgaWQpLm1heWJlU2luZ2xlKClcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhIGFzIERlYWwgfCBudWxsKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWN0aXZpdGllc0ZvcihyZWxhdGVkVHlwZTogJ2RlYWwnfCdjb250YWN0J3wnY29tcGFueScsIHJlbGF0ZWRJZDogc3RyaW5nKTogUHJvbWlzZTxBY3Rpdml0eVtdPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLmFjdGl2aXRpZXNcclxuXHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdhY3Rpdml0aWVzJylcclxuICAgIC5zZWxlY3QoJyonKVxyXG4gICAgLmVxKCdyZWxhdGVkX3R5cGUnLCByZWxhdGVkVHlwZSlcclxuICAgIC5lcSgncmVsYXRlZF9pZCcsIHJlbGF0ZWRJZClcclxuICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICByZXR1cm4gKGRhdGEgPz8gW10pIGFzIEFjdGl2aXR5W11cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnRhY3QoaWQ6IHN0cmluZyk6IFByb21pc2U8Q29udGFjdCB8IG51bGw+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpXHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suY29udGFjdFxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2NvbnRhY3RzJykuc2VsZWN0KCcqJykuZXEoJ2lkJywgaWQpLm1heWJlU2luZ2xlKClcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhIGFzIENvbnRhY3QgfCBudWxsKVxyXG59XHJcblxyXG4vLyBBZGRlZCB0byByZXNvbHZlIGEgYnVpbGQgZXJyb3Igd2hlcmUgJ2dldENvbnRhY3RGb3JEZWFsJyB3YXMgcmVwb3J0ZWQgYXMgbWlzc2luZyxcclxuLy8gZXZlbiB0aG91Z2ggaXQncyBub3QgZXhwbGljaXRseSBpbXBvcnRlZCBpbiB0aGUgcmVsZXZhbnQgZmlsZXMuXHJcbi8vIEl0IHNpbXBseSBkZWxlZ2F0ZXMgdG8gZ2V0Q29udGFjdCwgYXMgdGhhdCdzIHRoZSBpbnRlbmRlZCBsb2dpYy5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnRhY3RGb3JEZWFsKGNvbnRhY3RJZDogc3RyaW5nKTogUHJvbWlzZTxDb250YWN0IHwgbnVsbD4ge1xyXG4gIHJldHVybiBnZXRDb250YWN0KGNvbnRhY3RJZCk7XHJcbn1cclxuXHJcbi8vIEFkZGVkIHRvIHJlc29sdmUgYSBidWlsZCBlcnJvciB3aGVyZSAnZ2V0U3RhZ2VOYW1lJyB3YXMgcmVwb3J0ZWQgYXMgbWlzc2luZy5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0YWdlTmFtZShzdGFnZUlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIG1vY2suc3RhZ2VzLmZpbmQocyA9PiBzLmlkID09PSBzdGFnZUlkKT8ubmFtZTtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwaXBlbGluZV9zdGFnZXMnKS5zZWxlY3QoJ25hbWUnKS5lcSgnaWQnLCBzdGFnZUlkKS5tYXliZVNpbmdsZSgpO1xyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgcmV0dXJuIGRhdGE/Lm5hbWU7XHJcbn1cclxuXHJcbi8vIEFjdGlvbnMgKHdyaXRlKSDigJQgcHJvdGVjdGVkIGJ5IFJMUzsgZXhwZWN0IEpXVCBpbiBmcm9udGVuZCBjb250ZXh0LlxyXG4vLyBGb3IgU1NSL0VkZ2Ugc2VjdXJlIHdyaXRlcywgcHJlZmVyIHNlcnZlci1vbmx5IGtleSBvciBlZGdlIGZ1bmN0aW9uIHByb3h5LlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVhbFN0YWdlKGRlYWxJZDogc3RyaW5nLCBuZXh0U3RhZ2VJZDogc3RyaW5nKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiB7IG9rOiB0cnVlIH1cclxuXHJcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgnZGVhbHMnKS51cGRhdGUoeyBzdGFnZV9pZDogbmV4dFN0YWdlSWQgfSkuZXEoJ2lkJywgZGVhbElkKVxyXG4gIGlmIChlcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29udGFjdFN0YXR1cyhjb250YWN0SWQ6IHN0cmluZywgc3RhdHVzOiAnaW50ZXJlc3RlZCcgfCAnbm90X2ludGVyZXN0ZWQnKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKTtcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG5cclxuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdjb250YWN0cycpLnVwZGF0ZSh7IHJlcGx5X3N0YXR1czogc3RhdHVzIH0pLmVxKCdpZCcsIGNvbnRhY3RJZCk7XHJcbiAgaWYgKGVycm9yKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGVuZGFyTGluayhjb250YWN0SWQ6IHN0cmluZyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgdXJsPzogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgLy8gVGhpcyBpcyBhIG1vY2sgaW1wbGVtZW50YXRpb24uIEluIGEgcmVhbCBhcHAsIHlvdSdkIGdlbmVyYXRlIGEgdW5pcXVlIGxpbmtcclxuICAvLyBvciBmZXRjaCBpdCBmcm9tIGEgY2FsZW5kYXIgc2VydmljZS5cclxuICByZXR1cm4geyBvazogdHJ1ZSwgdXJsOiBgaHR0cHM6Ly9jYWwuY29tL3lvdXItdXNlcm5hbWUvJHtjb250YWN0SWR9YCB9O1xyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gZGV0ZWN0IGVudiBwcmVzZW5jZVxyXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBhYmFzZUNvbmZpZ3VyZWQoKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIEJvb2xlYW4oU1VQQUJBU0VfVVJMICYmIFNVUEFCQVNFX0FOT05fS0VZKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0T3BlbkRlYWxzQ291bnQocGlwZWxpbmVJZD86IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKTtcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gNDI7IC8vIE1vY2sgZGF0YVxyXG5cclxuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKCdkZWFscycpLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnIH0pLmVxKCdzdGF0dXMnLCAnb3BlbicpO1xyXG4gIGlmIChwaXBlbGluZUlkICYmIHBpcGVsaW5lSWQgIT09ICdwX2RlZmF1bHQnKSB7XHJcbiAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwaXBlbGluZV9pZCcsIHBpcGVsaW5lSWQpO1xyXG4gIH1cclxuICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICByZXR1cm4gY291bnQgPz8gMDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExhc3Q3RGF5c1JlcGx5Q291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpO1xyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiAxNTsgLy8gTW9jayBkYXRhXHJcblxyXG4gIGNvbnN0IHNldmVuRGF5c0FnbyA9IG5ldyBEYXRlKCk7XHJcbiAgc2V2ZW5EYXlzQWdvLnNldERhdGUoc2V2ZW5EYXlzQWdvLmdldERhdGUoKSAtIDcpO1xyXG5cclxuICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdjb250YWN0cycpXHJcbiAgICAuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcgfSlcclxuICAgIC5ub3QoJ3JlcGx5X3N0YXR1cycsICdpcycsIG51bGwpXHJcbiAgICAuZ3RlKCd1cGRhdGVkX2F0Jywgc2V2ZW5EYXlzQWdvLnRvSVNPU3RyaW5nKCkpOyAvLyBBc3N1bWluZyB1cGRhdGVkX2F0IHJlZmxlY3RzIHJlcGx5IHN0YXR1cyBjaGFuZ2VzXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICByZXR1cm4gY291bnQgPz8gMDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBpcGVsaW5lQ29udmVyc2lvbihwaXBlbGluZUlkPzogc3RyaW5nKTogUHJvbWlzZTxQaXBlbGluZUNvbnZlcnNpb25bXT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkge1xyXG4gICAgcmV0dXJuIFsgLy8gTW9jayBkYXRhXHJcbiAgICAgIHsgc3RhZ2VfaWQ6ICdzMScsIHN0YWdlX25hbWU6ICdOZXcnLCBjb3VudDogMTAsIGNvbnZlcnNpb25fdG9fbmV4dDogNTAgfSxcclxuICAgICAgeyBzdGFnZV9pZDogJ3MyJywgc3RhZ2VfbmFtZTogJ0NvbnRhY3RlZCcsIGNvdW50OiA1LCBjb252ZXJzaW9uX3RvX25leHQ6IDgwIH0sXHJcbiAgICAgIHsgc3RhZ2VfaWQ6ICdzMycsIHN0YWdlX25hbWU6ICdRdWFsaWZpZWQnLCBjb3VudDogNCwgY29udmVyc2lvbl90b19uZXh0OiB1bmRlZmluZWQgfSxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBtb2NrIGZvciBjb252ZXJzaW9uLiBBIHJlYWwgaW1wbGVtZW50YXRpb24gd291bGQgaW52b2x2ZVxyXG4gIC8vIG1vcmUgY29tcGxleCBTUUwgcXVlcmllcyBvciBhIG1hdGVyaWFsaXplZCB2aWV3IHRvIGNhbGN1bGF0ZSBjb252ZXJzaW9ucyBiZXR3ZWVuIHN0YWdlcy5cclxuICBjb25zdCBzdGFnZXMgPSBhd2FpdCBnZXRQaXBlbGluZVN0YWdlcyhwaXBlbGluZUlkKTtcclxuICBjb25zdCBkZWFsc0J5U3RhZ2UgPSBhd2FpdCBnZXREZWFsc0J5UGlwZWxpbmUocGlwZWxpbmVJZCk7XHJcblxyXG4gIGNvbnN0IHN0YWdlQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgZm9yIChjb25zdCBzdGFnZSBvZiBzdGFnZXMpIHtcclxuICAgIHN0YWdlQ291bnRzW3N0YWdlLmlkXSA9IGRlYWxzQnlTdGFnZVtzdGFnZS5pZF0/Lmxlbmd0aCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY29udmVyc2lvbkRhdGE6IFBpcGVsaW5lQ29udmVyc2lvbltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGN1cnJlbnRTdGFnZSA9IHN0YWdlc1tpXTtcclxuICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IHN0YWdlQ291bnRzW2N1cnJlbnRTdGFnZS5pZF07XHJcbiAgICBsZXQgY29udmVyc2lvblRvTmV4dDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmIChpIDwgc3RhZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgY29uc3QgbmV4dFN0YWdlID0gc3RhZ2VzW2kgKyAxXTtcclxuICAgICAgY29uc3QgbmV4dENvdW50ID0gc3RhZ2VDb3VudHNbbmV4dFN0YWdlLmlkXTtcclxuICAgICAgaWYgKGN1cnJlbnRDb3VudCA+IDApIHtcclxuICAgICAgICBjb252ZXJzaW9uVG9OZXh0ID0gTWF0aC5yb3VuZCgobmV4dENvdW50IC8gY3VycmVudENvdW50KSAqIDEwMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb252ZXJzaW9uRGF0YS5wdXNoKHtcclxuICAgICAgc3RhZ2VfaWQ6IGN1cnJlbnRTdGFnZS5pZCxcclxuICAgICAgc3RhZ2VfbmFtZTogY3VycmVudFN0YWdlLm5hbWUsXHJcbiAgICAgIGNvdW50OiBjdXJyZW50Q291bnQsXHJcbiAgICAgIGNvbnZlcnNpb25fdG9fbmV4dDogY29udmVyc2lvblRvTmV4dCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnZlcnNpb25EYXRhO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQaXBlbGluZUNvbnZlcnNpb24gPSB7XHJcbiAgc3RhZ2VfaWQ6IHN0cmluZztcclxuICBzdGFnZV9uYW1lOiBzdHJpbmc7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICBjb252ZXJzaW9uX3RvX25leHQ/OiBudW1iZXI7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJTVVBBQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiU1VQQUJBU0VfQU5PTl9LRVkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1cGFiYXNlIiwiZ2V0Q2xpZW50IiwiYXV0aCIsInBlcnNpc3RTZXNzaW9uIiwibW9jayIsInN0YWdlcyIsImlkIiwibmFtZSIsIm9yZGVyX2luZGV4IiwicHJvYmFiaWxpdHkiLCJkZWFsc0J5U3RhZ2UiLCJzMSIsInRpdGxlIiwic3RhZ2VfaWQiLCJhbW91bnQiLCJjdXJyZW5jeSIsInMyIiwiczMiLCJhY3Rpdml0aWVzIiwidHlwZSIsInJlbGF0ZWRfdHlwZSIsInJlbGF0ZWRfaWQiLCJjb250ZW50IiwibWV0YV9qc29uIiwiY3JlYXRlZF9ieSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb250YWN0IiwiZW1haWwiLCJmdWxsX25hbWUiLCJsaW5rZWRpbl91cmwiLCJ3ZWJzaXRlIiwicGhvbmUiLCJjb21wYW55X2lkIiwib3duZXJfaWQiLCJsaWZlY3ljbGVfc3RhZ2UiLCJyZXBseV9zdGF0dXMiLCJyZXBseV9zdW1tYXJ5IiwiZ2VuZXJhdGVkX2JvZHlfc3RlcDEiLCJnZW5lcmF0ZWRfYm9keV9zdGVwMiIsImdlbmVyYXRlZF9ib2R5X3N0ZXAzIiwibGF0ZXN0X2VtYWlsX3NlbnRfYXQiLCJ1cGRhdGVkX2F0IiwiZ2V0UGlwZWxpbmVTdGFnZXMiLCJwaXBlbGluZUlkIiwicGlwZWxpbmUiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvcmRlciIsImFzY2VuZGluZyIsImxpbWl0IiwibWF5YmVTaW5nbGUiLCJnZXREZWFsc0J5UGlwZWxpbmUiLCJwaWQiLCJ1bmRlZmluZWQiLCJkZWFscyIsImNvbXBhbnlJZHMiLCJBcnJheSIsIlNldCIsIm1hcCIsImQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY29udGFjdElkcyIsImNvbnRhY3RfaWQiLCJjb21wYW5pZXNSZXMiLCJjb250YWN0c1JlcyIsIlByb21pc2UiLCJhbGwiLCJsZW5ndGgiLCJpbiIsInJlc29sdmUiLCJjb21wYW55TWFwIiwiTWFwIiwiYyIsImNvbnRhY3RNYXAiLCJncm91cGVkIiwiY2FyZCIsImNvbXBhbnkiLCJnZXQiLCJwdXNoIiwiZ2V0RGVhbERldGFpbCIsImFueURlYWwiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmbGF0IiwicGlwZWxpbmVfaWQiLCJzdGF0dXMiLCJzb3VyY2UiLCJub3RlcyIsImNsb3NlX2RhdGUiLCJnZXRBY3Rpdml0aWVzRm9yIiwicmVsYXRlZFR5cGUiLCJyZWxhdGVkSWQiLCJnZXRDb250YWN0IiwiZ2V0Q29udGFjdEZvckRlYWwiLCJjb250YWN0SWQiLCJnZXRTdGFnZU5hbWUiLCJzdGFnZUlkIiwiZmluZCIsInMiLCJ1cGRhdGVEZWFsU3RhZ2UiLCJkZWFsSWQiLCJuZXh0U3RhZ2VJZCIsIm9rIiwidXBkYXRlIiwibWVzc2FnZSIsInVwZGF0ZUNvbnRhY3RTdGF0dXMiLCJnZXRDYWxlbmRhckxpbmsiLCJ1cmwiLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsImdldE9wZW5EZWFsc0NvdW50IiwicXVlcnkiLCJjb3VudCIsImdldExhc3Q3RGF5c1JlcGx5Q291bnQiLCJzZXZlbkRheXNBZ28iLCJzZXREYXRlIiwiZ2V0RGF0ZSIsIm5vdCIsImd0ZSIsImdldFBpcGVsaW5lQ29udmVyc2lvbiIsInN0YWdlX25hbWUiLCJjb252ZXJzaW9uX3RvX25leHQiLCJzdGFnZUNvdW50cyIsInN0YWdlIiwiY29udmVyc2lvbkRhdGEiLCJpIiwiY3VycmVudFN0YWdlIiwiY3VycmVudENvdW50IiwiY29udmVyc2lvblRvTmV4dCIsIm5leHRTdGFnZSIsIm5leHRDb3VudCIsIk1hdGgiLCJyb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});