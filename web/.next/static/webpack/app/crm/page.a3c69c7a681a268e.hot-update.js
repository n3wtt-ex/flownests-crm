"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   isSupabaseConfigured: function() { return /* binding */ isSupabaseConfigured; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n// Supabase-backed CRM API helpers (SSR/RLS friendly)\n// Falls back to mock when env is missing. Types from supabase.types.ts\n\n// Exported\nconst SUPABASE_URL = \"https://jkrxflynplzczpkzhygs.supabase.co\";\nconst SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImprcnhmbHlucGx6Y3pwa3poeWdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzNDczOTksImV4cCI6MjA2OTkyMzM5OX0.QYOOVOK4cI44IsSQz1MGdSQbUKJwI4frO-YdNv8hvpU\";\nlet supabase = null;\nfunction getClient() {\n    if (supabase) return supabase;\n    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) return null;\n    supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(SUPABASE_URL, SUPABASE_ANON_KEY, {\n        auth: {\n            persistSession: false\n        }\n    });\n    return supabase;\n}\n// Mock fallback for dev without env configured\nconst mock = {\n    stages: [\n        {\n            id: \"s1\",\n            name: \"New\",\n            order_index: 10,\n            probability: 10\n        },\n        {\n            id: \"s2\",\n            name: \"Contacted\",\n            order_index: 20,\n            probability: 25\n        },\n        {\n            id: \"s3\",\n            name: \"Qualified\",\n            order_index: 30,\n            probability: 45\n        }\n    ],\n    dealsByStage: {\n        s1: [\n            {\n                id: \"d1\",\n                title: \"Acme - Pilot\",\n                stage_id: \"s1\",\n                amount: 2500,\n                currency: \"USD\"\n            }\n        ],\n        s2: [],\n        s3: []\n    },\n    activities: [\n        {\n            id: \"a1\",\n            type: \"system\",\n            related_type: \"deal\",\n            related_id: \"d1\",\n            content: \"Seed: deal created\",\n            meta_json: null,\n            created_by: null,\n            created_at: new Date().toISOString()\n        }\n    ],\n    contact: {\n        id: \"c1\",\n        email: \"john@acme.com\",\n        full_name: \"John Doe\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/johndoe\",\n        website: \"https://acme.com\",\n        phone: null,\n        company_id: null,\n        owner_id: null,\n        lifecycle_stage: \"lead\",\n        reply_status: null,\n        reply_summary: null,\n        generated_body_step1: null,\n        generated_body_step2: null,\n        generated_body_step3: null,\n        latest_email_sent_at: null,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    }\n};\nasync function getPipelineStages(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.stages;\n    let effectivePipelineId = pipelineId;\n    if (!effectivePipelineId || effectivePipelineId === \"p_default\") {\n        const { data: defaultPipeline, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        if (!defaultPipeline) return [];\n        effectivePipelineId = defaultPipeline.id;\n    }\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"id,name,order_index,probability\").eq(\"pipeline_id\", effectivePipelineId).order(\"order_index\", {\n        ascending: true\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getDealsByPipeline(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return mock.dealsByStage;\n    // resolve pipeline id\n    let effectivePipelineId = pipelineId;\n    if (!effectivePipelineId || effectivePipelineId === \"p_default\") {\n        const { data: defaultPipeline, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        if (!defaultPipeline) return {};\n        effectivePipelineId = defaultPipeline.id;\n    }\n    // fetch deals + join names\n    const { data: deals, error } = await supabase.from(\"deals\").select(\"id,title,amount,currency,stage_id,company_id,contact_id\").eq(\"pipeline_id\", effectivePipelineId);\n    if (error) throw error;\n    // fetch related names in one go\n    const companyIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.company_id).filter(Boolean)));\n    const contactIds = Array.from(new Set((deals !== null && deals !== void 0 ? deals : []).map((d)=>d.contact_id).filter(Boolean)));\n    const [companiesRes, contactsRes] = await Promise.all([\n        companyIds.length ? supabase.from(\"companies\").select(\"id,name\").in(\"id\", companyIds) : Promise.resolve({\n            data: [],\n            error: null\n        }),\n        contactIds.length ? supabase.from(\"contacts\").select(\"id,full_name\").in(\"id\", contactIds) : Promise.resolve({\n            data: [],\n            error: null\n        })\n    ]);\n    if (companiesRes.error) throw companiesRes.error;\n    if (contactsRes.error) throw contactsRes.error;\n    var _companiesRes_data;\n    const companyMap = new Map(((_companiesRes_data = companiesRes.data) !== null && _companiesRes_data !== void 0 ? _companiesRes_data : []).map((c)=>[\n            c.id,\n            c.name\n        ]));\n    var _contactsRes_data;\n    const contactMap = new Map(((_contactsRes_data = contactsRes.data) !== null && _contactsRes_data !== void 0 ? _contactsRes_data : []).map((c)=>[\n            c.id,\n            c.full_name\n        ]));\n    const grouped = {};\n    for (const d of deals !== null && deals !== void 0 ? deals : []){\n        var _d_amount, _d_currency, _companyMap_get, _contactMap_get;\n        const card = {\n            id: d.id,\n            title: d.title,\n            amount: (_d_amount = d.amount) !== null && _d_amount !== void 0 ? _d_amount : null,\n            currency: (_d_currency = d.currency) !== null && _d_currency !== void 0 ? _d_currency : null,\n            stage_id: d.stage_id,\n            company: d.company_id ? (_companyMap_get = companyMap.get(d.company_id)) !== null && _companyMap_get !== void 0 ? _companyMap_get : null : null,\n            contact: d.contact_id ? (_contactMap_get = contactMap.get(d.contact_id)) !== null && _contactMap_get !== void 0 ? _contactMap_get : null : null\n        };\n        if (!grouped[d.stage_id]) grouped[d.stage_id] = [];\n        grouped[d.stage_id].push(card);\n    }\n    return grouped;\n}\nasync function getDealDetail(id) {\n    const supabase = getClient();\n    if (!supabase) {\n        const anyDeal = Object.values(mock.dealsByStage).flat()[0];\n        if (!anyDeal) return null;\n        var _anyDeal_amount, _anyDeal_currency;\n        // minimal mock cast\n        return {\n            id: anyDeal.id,\n            title: anyDeal.title,\n            amount: (_anyDeal_amount = anyDeal.amount) !== null && _anyDeal_amount !== void 0 ? _anyDeal_amount : null,\n            currency: (_anyDeal_currency = anyDeal.currency) !== null && _anyDeal_currency !== void 0 ? _anyDeal_currency : null,\n            company_id: null,\n            contact_id: null,\n            pipeline_id: \"default\",\n            stage_id: anyDeal.stage_id,\n            status: \"open\",\n            source: \"inbound\",\n            notes: \"Mock\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n            close_date: null\n        };\n    }\n    const { data, error } = await supabase.from(\"deals\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    const supabase = getClient();\n    if (!supabase) return mock.activities;\n    const { data, error } = await supabase.from(\"activities\").select(\"*\").eq(\"related_type\", relatedType).eq(\"related_id\", relatedId).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) throw error;\n    return data !== null && data !== void 0 ? data : [];\n}\nasync function getContact(id) {\n    const supabase = getClient();\n    if (!supabase) return mock.contact;\n    const { data, error } = await supabase.from(\"contacts\").select(\"*\").eq(\"id\", id).maybeSingle();\n    if (error) throw error;\n    return data;\n}\n// Added to resolve a build error where 'getContactForDeal' was reported as missing,\n// even though it's not explicitly imported in the relevant files.\n// It simply delegates to getContact, as that's the intended logic.\nasync function getContactForDeal(contactId) {\n    return getContact(contactId);\n}\n// Added to resolve a build error where 'getStageName' was reported as missing.\nasync function getStageName(stageId) {\n    var _mock_stages_find;\n    const supabase = getClient();\n    if (!supabase) return (_mock_stages_find = mock.stages.find((s)=>s.id === stageId)) === null || _mock_stages_find === void 0 ? void 0 : _mock_stages_find.name;\n    const { data, error } = await supabase.from(\"pipeline_stages\").select(\"name\").eq(\"id\", stageId).maybeSingle();\n    if (error) throw error;\n    return data === null || data === void 0 ? void 0 : data.name;\n}\n// Actions (write) — protected by RLS; expect JWT in frontend context.\n// For SSR/Edge secure writes, prefer server-only key or edge function proxy.\nasync function updateDealStage(dealId, nextStageId) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"deals\").update({\n        stage_id: nextStageId\n    }).eq(\"id\", dealId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function updateContactStatus(contactId, status) {\n    const supabase = getClient();\n    if (!supabase) return {\n        ok: true\n    };\n    const { error } = await supabase.from(\"contacts\").update({\n        reply_status: status\n    }).eq(\"id\", contactId);\n    if (error) return {\n        ok: false,\n        error: error.message\n    };\n    return {\n        ok: true\n    };\n}\nasync function getCalendarLink(contactId) {\n    // This is a mock implementation. In a real app, you'd generate a unique link\n    // or fetch it from a calendar service.\n    return {\n        ok: true,\n        url: \"https://cal.com/your-username/\".concat(contactId)\n    };\n}\n// Helper to detect env presence\nfunction isSupabaseConfigured() {\n    return Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);\n}\nasync function getOpenDealsCount(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) return 42; // Mock data\n    let effectivePipelineId = pipelineId;\n    if (!effectivePipelineId || effectivePipelineId === \"p_default\") {\n        const { data: defaultPipeline, error } = await supabase.from(\"pipelines\").select(\"id\").eq(\"is_default\", true).order(\"created_at\", {\n            ascending: true\n        }).limit(1).maybeSingle();\n        if (error) throw error;\n        if (!defaultPipeline) return 0;\n        effectivePipelineId = defaultPipeline.id;\n    }\n    let query = supabase.from(\"deals\").select(\"id\", {\n        count: \"exact\"\n    }).eq(\"status\", \"open\");\n    if (effectivePipelineId) {\n        query = query.eq(\"pipeline_id\", effectivePipelineId);\n    }\n    const { count, error } = await query;\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getLast7DaysReplyCount() {\n    const supabase = getClient();\n    if (!supabase) return 15; // Mock data\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    const { count, error } = await supabase.from(\"contacts\").select(\"id\", {\n        count: \"exact\"\n    }).not(\"reply_status\", \"is\", null).gte(\"updated_at\", sevenDaysAgo.toISOString()); // Assuming updated_at reflects reply status changes\n    if (error) throw error;\n    return count !== null && count !== void 0 ? count : 0;\n}\nasync function getPipelineConversion(pipelineId) {\n    const supabase = getClient();\n    if (!supabase) {\n        return [\n            {\n                stage_id: \"s1\",\n                stage_name: \"New\",\n                count: 10,\n                conversion_to_next: 50\n            },\n            {\n                stage_id: \"s2\",\n                stage_name: \"Contacted\",\n                count: 5,\n                conversion_to_next: 80\n            },\n            {\n                stage_id: \"s3\",\n                stage_name: \"Qualified\",\n                count: 4,\n                conversion_to_next: undefined\n            }\n        ];\n    }\n    // This is a simplified mock for conversion. A real implementation would involve\n    // more complex SQL queries or a materialized view to calculate conversions between stages.\n    const stages = await getPipelineStages(pipelineId);\n    const dealsByStage = await getDealsByPipeline(pipelineId);\n    const stageCounts = {};\n    for (const stage of stages){\n        var _dealsByStage_stage_id;\n        stageCounts[stage.id] = ((_dealsByStage_stage_id = dealsByStage[stage.id]) === null || _dealsByStage_stage_id === void 0 ? void 0 : _dealsByStage_stage_id.length) || 0;\n    }\n    const conversionData = [];\n    for(let i = 0; i < stages.length; i++){\n        const currentStage = stages[i];\n        const currentCount = stageCounts[currentStage.id];\n        let conversionToNext = undefined;\n        if (i < stages.length - 1) {\n            const nextStage = stages[i + 1];\n            const nextCount = stageCounts[nextStage.id];\n            if (currentCount > 0) {\n                conversionToNext = Math.round(nextCount / currentCount * 100);\n            }\n        }\n        conversionData.push({\n            stage_id: currentStage.id,\n            stage_name: currentStage.name,\n            count: currentCount,\n            conversion_to_next: conversionToNext\n        });\n    }\n    return conversionData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEO0FBQ3JELHVFQUF1RTtBQUVuQjtBQXNCWCxXQUFXO0FBRXBELE1BQU1DLGVBQWVDLDBDQUFvQztBQUN6RCxNQUFNRyxvQkFBb0JILGtOQUF5QztBQUVuRSxJQUFJSyxXQUE2RDtBQUVqRSxTQUFTQztJQUNQLElBQUlELFVBQVUsT0FBT0E7SUFDckIsSUFBSSxDQUFDTixnQkFBZ0IsQ0FBQ0ksbUJBQW1CLE9BQU87SUFDaERFLFdBQVdQLG1FQUFZQSxDQUFXQyxjQUFjSSxtQkFBbUI7UUFDakVJLE1BQU07WUFDSkMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBRUEsK0NBQStDO0FBQy9DLE1BQU1JLE9BQU87SUFDWEMsUUFBUTtRQUNOO1lBQUVDLElBQUk7WUFBTUMsTUFBTTtZQUFPQyxhQUFhO1lBQUlDLGFBQWE7UUFBRztRQUMxRDtZQUFFSCxJQUFJO1lBQU1DLE1BQU07WUFBYUMsYUFBYTtZQUFJQyxhQUFhO1FBQUc7UUFDaEU7WUFBRUgsSUFBSTtZQUFNQyxNQUFNO1lBQWFDLGFBQWE7WUFBSUMsYUFBYTtRQUFHO0tBQ2pFO0lBQ0RDLGNBQWM7UUFDWkMsSUFBSTtZQUFDO2dCQUFFTCxJQUFJO2dCQUFNTSxPQUFPO2dCQUFnQkMsVUFBVTtnQkFBTUMsUUFBUTtnQkFBTUMsVUFBVTtZQUFNO1NBQUU7UUFDeEZDLElBQUksRUFBRTtRQUNOQyxJQUFJLEVBQUU7SUFDUjtJQUNBQyxZQUFZO1FBQ1Y7WUFBRVosSUFBSTtZQUFNYSxNQUFNO1lBQVVDLGNBQWM7WUFBUUMsWUFBWTtZQUFNQyxTQUFTO1lBQXNCQyxXQUFXO1lBQU1DLFlBQVk7WUFBTUMsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO1FBQUc7S0FDNUs7SUFDREMsU0FBUztRQUNQdEIsSUFBSTtRQUFNdUIsT0FBTztRQUFpQkMsV0FBVztRQUFZbEIsT0FBTztRQUNoRW1CLGNBQWM7UUFBbUNDLFNBQVM7UUFDMURDLE9BQU87UUFBTUMsWUFBWTtRQUFNQyxVQUFVO1FBQU1DLGlCQUFpQjtRQUNoRUMsY0FBYztRQUFNQyxlQUFlO1FBQU1DLHNCQUFzQjtRQUFNQyxzQkFBc0I7UUFBTUMsc0JBQXNCO1FBQ3ZIQyxzQkFBc0I7UUFBTWpCLFlBQVksSUFBSUMsT0FBT0MsV0FBVztRQUFJZ0IsWUFBWSxJQUFJakIsT0FBT0MsV0FBVztJQUN0RztBQUNGO0FBRU8sZUFBZWlCLGtCQUFrQkMsVUFBbUI7SUFDekQsTUFBTTdDLFdBQVdDO0lBQ2pCLElBQUksQ0FBQ0QsVUFBVSxPQUFPSSxLQUFLQyxNQUFNO0lBRWpDLElBQUl5QyxzQkFBc0JEO0lBQzFCLElBQUksQ0FBQ0MsdUJBQXVCQSx3QkFBd0IsYUFBYTtRQUMvRCxNQUFNLEVBQUVDLE1BQU1DLGVBQWUsRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWpELFNBQVNrRCxJQUFJLENBQUMsYUFBYUMsTUFBTSxDQUFDLE1BQU1DLEVBQUUsQ0FBQyxjQUFjLE1BQU1DLEtBQUssQ0FBQyxjQUFjO1lBQUVDLFdBQVc7UUFBSyxHQUFHQyxLQUFLLENBQUMsR0FBR0MsV0FBVztRQUMzSyxJQUFJUCxPQUFPLE1BQU1BO1FBQ2pCLElBQUksQ0FBQ0QsaUJBQWlCLE9BQU8sRUFBRTtRQUMvQkYsc0JBQXNCRSxnQkFBZ0IxQyxFQUFFO0lBQzFDO0lBRUEsTUFBTSxFQUFFeUMsSUFBSSxFQUFFRSxLQUFLLEVBQUUsR0FBRyxNQUFNakQsU0FDM0JrRCxJQUFJLENBQUMsbUJBQ0xDLE1BQU0sQ0FBQyxtQ0FDUEMsRUFBRSxDQUFDLGVBQWVOLHFCQUNsQk8sS0FBSyxDQUFDLGVBQWU7UUFBRUMsV0FBVztJQUFLO0lBRTFDLElBQUlMLE9BQU8sTUFBTUE7SUFDakIsT0FBUUYsaUJBQUFBLGtCQUFBQSxPQUFRLEVBQUU7QUFDcEI7QUFFTyxlQUFlVSxtQkFBbUJaLFVBQW1CO0lBQzFELE1BQU03QyxXQUFXQztJQUNqQixJQUFJLENBQUNELFVBQVUsT0FBT0ksS0FBS00sWUFBWTtJQUV2QyxzQkFBc0I7SUFDdEIsSUFBSW9DLHNCQUFzQkQ7SUFDMUIsSUFBSSxDQUFDQyx1QkFBdUJBLHdCQUF3QixhQUFhO1FBQy9ELE1BQU0sRUFBRUMsTUFBTUMsZUFBZSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNakQsU0FBU2tELElBQUksQ0FBQyxhQUFhQyxNQUFNLENBQUMsTUFBTUMsRUFBRSxDQUFDLGNBQWMsTUFBTUMsS0FBSyxDQUFDLGNBQWM7WUFBRUMsV0FBVztRQUFLLEdBQUdDLEtBQUssQ0FBQyxHQUFHQyxXQUFXO1FBQzNLLElBQUlQLE9BQU8sTUFBTUE7UUFDakIsSUFBSSxDQUFDRCxpQkFBaUIsT0FBTyxDQUFDO1FBQzlCRixzQkFBc0JFLGdCQUFnQjFDLEVBQUU7SUFDMUM7SUFFQSwyQkFBMkI7SUFDM0IsTUFBTSxFQUFFeUMsTUFBTVcsS0FBSyxFQUFFVCxLQUFLLEVBQUUsR0FBRyxNQUFNakQsU0FDbENrRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLDJEQUNQQyxFQUFFLENBQUMsZUFBZU47SUFDckIsSUFBSUcsT0FBTyxNQUFNQTtJQUVqQixnQ0FBZ0M7SUFDaEMsTUFBTVUsYUFBYUMsTUFBTVYsSUFBSSxDQUFDLElBQUlXLElBQUksQ0FBQ0gsa0JBQUFBLG1CQUFBQSxRQUFTLEVBQUUsRUFBRUksR0FBRyxDQUFDLENBQUNDLElBQVdBLEVBQUU3QixVQUFVLEVBQUU4QixNQUFNLENBQUNDO0lBQ3pGLE1BQU1DLGFBQWFOLE1BQU1WLElBQUksQ0FBQyxJQUFJVyxJQUFJLENBQUNILGtCQUFBQSxtQkFBQUEsUUFBUyxFQUFFLEVBQUVJLEdBQUcsQ0FBQyxDQUFDQyxJQUFXQSxFQUFFSSxVQUFVLEVBQUVILE1BQU0sQ0FBQ0M7SUFFekYsTUFBTSxDQUFDRyxjQUFjQyxZQUFZLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO1FBQ3BEWixXQUFXYSxNQUFNLEdBQUd4RSxTQUFTa0QsSUFBSSxDQUFDLGFBQWFDLE1BQU0sQ0FBQyxXQUFXc0IsRUFBRSxDQUFDLE1BQU1kLGNBQWNXLFFBQVFJLE9BQU8sQ0FBQztZQUFFM0IsTUFBTSxFQUFFO1lBQW9DRSxPQUFPO1FBQUs7UUFDbEtpQixXQUFXTSxNQUFNLEdBQUd4RSxTQUFTa0QsSUFBSSxDQUFDLFlBQVlDLE1BQU0sQ0FBQyxnQkFBZ0JzQixFQUFFLENBQUMsTUFBTVAsY0FBY0ksUUFBUUksT0FBTyxDQUFDO1lBQUUzQixNQUFNLEVBQUU7WUFBZ0RFLE9BQU87UUFBSztLQUNuTDtJQUVELElBQUltQixhQUFhbkIsS0FBSyxFQUFFLE1BQU1tQixhQUFhbkIsS0FBSztJQUNoRCxJQUFJb0IsWUFBWXBCLEtBQUssRUFBRSxNQUFNb0IsWUFBWXBCLEtBQUs7UUFFbEJtQjtJQUE1QixNQUFNTyxhQUFhLElBQUlDLElBQUksQ0FBQ1IsQ0FBQUEscUJBQUFBLGFBQWFyQixJQUFJLGNBQWpCcUIsZ0NBQUFBLHFCQUFxQixFQUFFLEVBQUVOLEdBQUcsQ0FBQyxDQUFDZSxJQUFvQztZQUFDQSxFQUFFdkUsRUFBRTtZQUFFdUUsRUFBRXRFLElBQUk7U0FBQztRQUNoRjhEO0lBQTVCLE1BQU1TLGFBQWEsSUFBSUYsSUFBSSxDQUFDUCxDQUFBQSxvQkFBQUEsWUFBWXRCLElBQUksY0FBaEJzQiwrQkFBQUEsb0JBQW9CLEVBQUUsRUFBRVAsR0FBRyxDQUFDLENBQUNlLElBQWdEO1lBQUNBLEVBQUV2RSxFQUFFO1lBQUV1RSxFQUFFL0MsU0FBUztTQUFDO0lBRTVILE1BQU1pRCxVQUFzQyxDQUFDO0lBQzdDLEtBQUssTUFBTWhCLEtBQU1MLGtCQUFBQSxtQkFBQUEsUUFBUyxFQUFFLENBRXhCO1lBSVFLLFdBQ0VBLGFBRWVZLGlCQUNBRztRQVAzQixNQUFNRSxPQUFpQjtZQUNyQjFFLElBQUl5RCxFQUFFekQsRUFBRTtZQUNSTSxPQUFPbUQsRUFBRW5ELEtBQUs7WUFDZEUsUUFBUWlELENBQUFBLFlBQUFBLEVBQUVqRCxNQUFNLGNBQVJpRCx1QkFBQUEsWUFBWTtZQUNwQmhELFVBQVVnRCxDQUFBQSxjQUFBQSxFQUFFaEQsUUFBUSxjQUFWZ0QseUJBQUFBLGNBQWM7WUFDeEJsRCxVQUFVa0QsRUFBRWxELFFBQVE7WUFDcEJvRSxTQUFTbEIsRUFBRTdCLFVBQVUsR0FBSXlDLENBQUFBLGtCQUFBQSxXQUFXTyxHQUFHLENBQUNuQixFQUFFN0IsVUFBVSxlQUEzQnlDLDZCQUFBQSxrQkFBZ0MsT0FBUTtZQUNqRS9DLFNBQVNtQyxFQUFFSSxVQUFVLEdBQUlXLENBQUFBLGtCQUFBQSxXQUFXSSxHQUFHLENBQUNuQixFQUFFSSxVQUFVLGVBQTNCVyw2QkFBQUEsa0JBQWdDLE9BQVE7UUFDbkU7UUFDQSxJQUFJLENBQUNDLE9BQU8sQ0FBQ2hCLEVBQUVsRCxRQUFRLENBQUMsRUFBRWtFLE9BQU8sQ0FBQ2hCLEVBQUVsRCxRQUFRLENBQUMsR0FBRyxFQUFFO1FBQ2xEa0UsT0FBTyxDQUFDaEIsRUFBRWxELFFBQVEsQ0FBQyxDQUFDc0UsSUFBSSxDQUFDSDtJQUMzQjtJQUNBLE9BQU9EO0FBQ1Q7QUFFTyxlQUFlSyxjQUFjOUUsRUFBVTtJQUM1QyxNQUFNTixXQUFXQztJQUNqQixJQUFJLENBQUNELFVBQVU7UUFDYixNQUFNcUYsVUFBV0MsT0FBT0MsTUFBTSxDQUFDbkYsS0FBS00sWUFBWSxFQUFFOEUsSUFBSSxFQUFFLENBQUMsRUFBRTtRQUMzRCxJQUFJLENBQUNILFNBQVMsT0FBTztZQUtYQSxpQkFDRUE7UUFMWixvQkFBb0I7UUFDcEIsT0FBTztZQUNML0UsSUFBSStFLFFBQVEvRSxFQUFFO1lBQ2RNLE9BQU95RSxRQUFRekUsS0FBSztZQUNwQkUsUUFBUXVFLENBQUFBLGtCQUFBQSxRQUFRdkUsTUFBTSxjQUFkdUUsNkJBQUFBLGtCQUFrQjtZQUMxQnRFLFVBQVVzRSxDQUFBQSxvQkFBQUEsUUFBUXRFLFFBQVEsY0FBaEJzRSwrQkFBQUEsb0JBQW9CO1lBQzlCbkQsWUFBWTtZQUNaaUMsWUFBWTtZQUNac0IsYUFBYTtZQUNiNUUsVUFBVXdFLFFBQVF4RSxRQUFRO1lBQzFCNkUsUUFBUTtZQUNSQyxRQUFRO1lBQ1JDLE9BQU87WUFDUG5FLFlBQVksSUFBSUMsT0FBT0MsV0FBVztZQUNsQ2dCLFlBQVksSUFBSWpCLE9BQU9DLFdBQVc7WUFDbENrRSxZQUFZO1FBQ2Q7SUFDRjtJQUVBLE1BQU0sRUFBRTlDLElBQUksRUFBRUUsS0FBSyxFQUFFLEdBQUcsTUFBTWpELFNBQVNrRCxJQUFJLENBQUMsU0FBU0MsTUFBTSxDQUFDLEtBQUtDLEVBQUUsQ0FBQyxNQUFNOUMsSUFBSWtELFdBQVc7SUFDekYsSUFBSVAsT0FBTyxNQUFNQTtJQUNqQixPQUFRRjtBQUNWO0FBRU8sZUFBZStDLGlCQUFpQkMsV0FBdUMsRUFBRUMsU0FBaUI7SUFDL0YsTUFBTWhHLFdBQVdDO0lBQ2pCLElBQUksQ0FBQ0QsVUFBVSxPQUFPSSxLQUFLYyxVQUFVO0lBRXJDLE1BQU0sRUFBRTZCLElBQUksRUFBRUUsS0FBSyxFQUFFLEdBQUcsTUFBTWpELFNBQzNCa0QsSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxFQUFFLENBQUMsZ0JBQWdCMkMsYUFDbkIzQyxFQUFFLENBQUMsY0FBYzRDLFdBQ2pCM0MsS0FBSyxDQUFDLGNBQWM7UUFBRUMsV0FBVztJQUFNO0lBQzFDLElBQUlMLE9BQU8sTUFBTUE7SUFDakIsT0FBUUYsaUJBQUFBLGtCQUFBQSxPQUFRLEVBQUU7QUFDcEI7QUFFTyxlQUFla0QsV0FBVzNGLEVBQVU7SUFDekMsTUFBTU4sV0FBV0M7SUFDakIsSUFBSSxDQUFDRCxVQUFVLE9BQU9JLEtBQUt3QixPQUFPO0lBQ2xDLE1BQU0sRUFBRW1CLElBQUksRUFBRUUsS0FBSyxFQUFFLEdBQUcsTUFBTWpELFNBQVNrRCxJQUFJLENBQUMsWUFBWUMsTUFBTSxDQUFDLEtBQUtDLEVBQUUsQ0FBQyxNQUFNOUMsSUFBSWtELFdBQVc7SUFDNUYsSUFBSVAsT0FBTyxNQUFNQTtJQUNqQixPQUFRRjtBQUNWO0FBRUEsb0ZBQW9GO0FBQ3BGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDNUQsZUFBZW1ELGtCQUFrQkMsU0FBaUI7SUFDdkQsT0FBT0YsV0FBV0U7QUFDcEI7QUFFQSwrRUFBK0U7QUFDeEUsZUFBZUMsYUFBYUMsT0FBZTtRQUUxQmpHO0lBRHRCLE1BQU1KLFdBQVdDO0lBQ2pCLElBQUksQ0FBQ0QsVUFBVSxRQUFPSSxvQkFBQUEsS0FBS0MsTUFBTSxDQUFDaUcsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFakcsRUFBRSxLQUFLK0Ysc0JBQS9Cakcsd0NBQUFBLGtCQUF5Q0csSUFBSTtJQUNuRSxNQUFNLEVBQUV3QyxJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU1qRCxTQUFTa0QsSUFBSSxDQUFDLG1CQUFtQkMsTUFBTSxDQUFDLFFBQVFDLEVBQUUsQ0FBQyxNQUFNaUQsU0FBUzdDLFdBQVc7SUFDM0csSUFBSVAsT0FBTyxNQUFNQTtJQUNqQixPQUFPRixpQkFBQUEsMkJBQUFBLEtBQU14QyxJQUFJO0FBQ25CO0FBRUEsc0VBQXNFO0FBQ3RFLDZFQUE2RTtBQUN0RSxlQUFlaUcsZ0JBQWdCQyxNQUFjLEVBQUVDLFdBQW1CO0lBQ3ZFLE1BQU0xRyxXQUFXQztJQUNqQixJQUFJLENBQUNELFVBQVUsT0FBTztRQUFFMkcsSUFBSTtJQUFLO0lBRWpDLE1BQU0sRUFBRTFELEtBQUssRUFBRSxHQUFHLE1BQU1qRCxTQUFTa0QsSUFBSSxDQUFDLFNBQVMwRCxNQUFNLENBQUM7UUFBRS9GLFVBQVU2RjtJQUFZLEdBQUd0RCxFQUFFLENBQUMsTUFBTXFEO0lBQzFGLElBQUl4RCxPQUFPLE9BQU87UUFBRTBELElBQUk7UUFBTzFELE9BQU9BLE1BQU00RCxPQUFPO0lBQUM7SUFDcEQsT0FBTztRQUFFRixJQUFJO0lBQUs7QUFDcEI7QUFFTyxlQUFlRyxvQkFBb0JYLFNBQWlCLEVBQUVULE1BQXVDO0lBQ2xHLE1BQU0xRixXQUFXQztJQUNqQixJQUFJLENBQUNELFVBQVUsT0FBTztRQUFFMkcsSUFBSTtJQUFLO0lBRWpDLE1BQU0sRUFBRTFELEtBQUssRUFBRSxHQUFHLE1BQU1qRCxTQUFTa0QsSUFBSSxDQUFDLFlBQVkwRCxNQUFNLENBQUM7UUFBRXZFLGNBQWNxRDtJQUFPLEdBQUd0QyxFQUFFLENBQUMsTUFBTStDO0lBQzVGLElBQUlsRCxPQUFPLE9BQU87UUFBRTBELElBQUk7UUFBTzFELE9BQU9BLE1BQU00RCxPQUFPO0lBQUM7SUFDcEQsT0FBTztRQUFFRixJQUFJO0lBQUs7QUFDcEI7QUFFTyxlQUFlSSxnQkFBZ0JaLFNBQWlCO0lBQ3JELDZFQUE2RTtJQUM3RSx1Q0FBdUM7SUFDdkMsT0FBTztRQUFFUSxJQUFJO1FBQU1LLEtBQUssaUNBQTJDLE9BQVZiO0lBQVk7QUFDdkU7QUFFQSxnQ0FBZ0M7QUFDekIsU0FBU2M7SUFDZCxPQUFPaEQsUUFBUXZFLGdCQUFnQkk7QUFDakM7QUFFTyxlQUFlb0gsa0JBQWtCckUsVUFBbUI7SUFDekQsTUFBTTdDLFdBQVdDO0lBQ2pCLElBQUksQ0FBQ0QsVUFBVSxPQUFPLElBQUksWUFBWTtJQUV0QyxJQUFJOEMsc0JBQXNCRDtJQUMxQixJQUFJLENBQUNDLHVCQUF1QkEsd0JBQXdCLGFBQWE7UUFDL0QsTUFBTSxFQUFFQyxNQUFNQyxlQUFlLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1qRCxTQUFTa0QsSUFBSSxDQUFDLGFBQWFDLE1BQU0sQ0FBQyxNQUFNQyxFQUFFLENBQUMsY0FBYyxNQUFNQyxLQUFLLENBQUMsY0FBYztZQUFFQyxXQUFXO1FBQUssR0FBR0MsS0FBSyxDQUFDLEdBQUdDLFdBQVc7UUFDM0ssSUFBSVAsT0FBTyxNQUFNQTtRQUNqQixJQUFJLENBQUNELGlCQUFpQixPQUFPO1FBQzdCRixzQkFBc0JFLGdCQUFnQjFDLEVBQUU7SUFDMUM7SUFFQSxJQUFJNkcsUUFBUW5ILFNBQVNrRCxJQUFJLENBQUMsU0FBU0MsTUFBTSxDQUFDLE1BQU07UUFBRWlFLE9BQU87SUFBUSxHQUFHaEUsRUFBRSxDQUFDLFVBQVU7SUFDakYsSUFBSU4scUJBQXFCO1FBQ3ZCcUUsUUFBUUEsTUFBTS9ELEVBQUUsQ0FBQyxlQUFlTjtJQUNsQztJQUNBLE1BQU0sRUFBRXNFLEtBQUssRUFBRW5FLEtBQUssRUFBRSxHQUFHLE1BQU1rRTtJQUMvQixJQUFJbEUsT0FBTyxNQUFNQTtJQUNqQixPQUFPbUUsa0JBQUFBLG1CQUFBQSxRQUFTO0FBQ2xCO0FBRU8sZUFBZUM7SUFDcEIsTUFBTXJILFdBQVdDO0lBQ2pCLElBQUksQ0FBQ0QsVUFBVSxPQUFPLElBQUksWUFBWTtJQUV0QyxNQUFNc0gsZUFBZSxJQUFJNUY7SUFDekI0RixhQUFhQyxPQUFPLENBQUNELGFBQWFFLE9BQU8sS0FBSztJQUU5QyxNQUFNLEVBQUVKLEtBQUssRUFBRW5FLEtBQUssRUFBRSxHQUFHLE1BQU1qRCxTQUM1QmtELElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMsTUFBTTtRQUFFaUUsT0FBTztJQUFRLEdBQzlCSyxHQUFHLENBQUMsZ0JBQWdCLE1BQU0sTUFDMUJDLEdBQUcsQ0FBQyxjQUFjSixhQUFhM0YsV0FBVyxLQUFLLG9EQUFvRDtJQUN0RyxJQUFJc0IsT0FBTyxNQUFNQTtJQUNqQixPQUFPbUUsa0JBQUFBLG1CQUFBQSxRQUFTO0FBQ2xCO0FBRU8sZUFBZU8sc0JBQXNCOUUsVUFBbUI7SUFDN0QsTUFBTTdDLFdBQVdDO0lBQ2pCLElBQUksQ0FBQ0QsVUFBVTtRQUNiLE9BQU87WUFDTDtnQkFBRWEsVUFBVTtnQkFBTStHLFlBQVk7Z0JBQU9SLE9BQU87Z0JBQUlTLG9CQUFvQjtZQUFHO1lBQ3ZFO2dCQUFFaEgsVUFBVTtnQkFBTStHLFlBQVk7Z0JBQWFSLE9BQU87Z0JBQUdTLG9CQUFvQjtZQUFHO1lBQzVFO2dCQUFFaEgsVUFBVTtnQkFBTStHLFlBQVk7Z0JBQWFSLE9BQU87Z0JBQUdTLG9CQUFvQkM7WUFBVTtTQUNwRjtJQUNIO0lBRUEsZ0ZBQWdGO0lBQ2hGLDJGQUEyRjtJQUMzRixNQUFNekgsU0FBUyxNQUFNdUMsa0JBQWtCQztJQUN2QyxNQUFNbkMsZUFBZSxNQUFNK0MsbUJBQW1CWjtJQUU5QyxNQUFNa0YsY0FBc0MsQ0FBQztJQUM3QyxLQUFLLE1BQU1DLFNBQVMzSCxPQUFRO1lBQ0ZLO1FBQXhCcUgsV0FBVyxDQUFDQyxNQUFNMUgsRUFBRSxDQUFDLEdBQUdJLEVBQUFBLHlCQUFBQSxZQUFZLENBQUNzSCxNQUFNMUgsRUFBRSxDQUFDLGNBQXRCSSw2Q0FBQUEsdUJBQXdCOEQsTUFBTSxLQUFJO0lBQzVEO0lBRUEsTUFBTXlELGlCQUF1QyxFQUFFO0lBQy9DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJN0gsT0FBT21FLE1BQU0sRUFBRTBELElBQUs7UUFDdEMsTUFBTUMsZUFBZTlILE1BQU0sQ0FBQzZILEVBQUU7UUFDOUIsTUFBTUUsZUFBZUwsV0FBVyxDQUFDSSxhQUFhN0gsRUFBRSxDQUFDO1FBQ2pELElBQUkrSCxtQkFBdUNQO1FBRTNDLElBQUlJLElBQUk3SCxPQUFPbUUsTUFBTSxHQUFHLEdBQUc7WUFDekIsTUFBTThELFlBQVlqSSxNQUFNLENBQUM2SCxJQUFJLEVBQUU7WUFDL0IsTUFBTUssWUFBWVIsV0FBVyxDQUFDTyxVQUFVaEksRUFBRSxDQUFDO1lBQzNDLElBQUk4SCxlQUFlLEdBQUc7Z0JBQ3BCQyxtQkFBbUJHLEtBQUtDLEtBQUssQ0FBQyxZQUFhTCxlQUFnQjtZQUM3RDtRQUNGO1FBRUFILGVBQWU5QyxJQUFJLENBQUM7WUFDbEJ0RSxVQUFVc0gsYUFBYTdILEVBQUU7WUFDekJzSCxZQUFZTyxhQUFhNUgsSUFBSTtZQUM3QjZHLE9BQU9nQjtZQUNQUCxvQkFBb0JRO1FBQ3RCO0lBQ0Y7SUFFQSxPQUFPSjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHM/ODFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTdXBhYmFzZS1iYWNrZWQgQ1JNIEFQSSBoZWxwZXJzIChTU1IvUkxTIGZyaWVuZGx5KVxyXG4vLyBGYWxscyBiYWNrIHRvIG1vY2sgd2hlbiBlbnYgaXMgbWlzc2luZy4gVHlwZXMgZnJvbSBzdXBhYmFzZS50eXBlcy50c1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xyXG5pbXBvcnQgdHlwZSB7IERhdGFiYXNlLCBUYWJsZXMgfSBmcm9tICcuL3N1cGFiYXNlLnR5cGVzJ1xyXG5cclxuZXhwb3J0IHR5cGUgRGVhbENhcmQgPSB7IC8vIEV4cG9ydGVkXHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHRpdGxlOiBzdHJpbmdcclxuICBjb21wYW55Pzogc3RyaW5nIHwgbnVsbFxyXG4gIGNvbnRhY3Q/OiBzdHJpbmcgfCBudWxsXHJcbiAgYW1vdW50PzogbnVtYmVyIHwgbnVsbFxyXG4gIGN1cnJlbmN5Pzogc3RyaW5nIHwgbnVsbFxyXG4gIHN0YWdlX2lkOiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhZ2UgPSB7IC8vIEV4cG9ydGVkXHJcbiAgaWQ6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIG9yZGVyX2luZGV4OiBudW1iZXJcclxuICBwcm9iYWJpbGl0eTogbnVtYmVyIHwgbnVsbFxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBBY3Rpdml0eSA9IFRhYmxlczwnYWN0aXZpdGllcyc+IC8vIEV4cG9ydGVkXHJcbmV4cG9ydCB0eXBlIERlYWwgPSBUYWJsZXM8J2RlYWxzJz4gLy8gRXhwb3J0ZWRcclxuZXhwb3J0IHR5cGUgQ29udGFjdCA9IFRhYmxlczwnY29udGFjdHMnPiAvLyBFeHBvcnRlZFxyXG5cclxuY29uc3QgU1VQQUJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMXHJcbmNvbnN0IFNVUEFCQVNFX0FOT05fS0VZID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVlcclxuXHJcbmxldCBzdXBhYmFzZTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlQ2xpZW50PERhdGFiYXNlPj4gfCBudWxsID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGdldENsaWVudCgpIHtcclxuICBpZiAoc3VwYWJhc2UpIHJldHVybiBzdXBhYmFzZTtcclxuICBpZiAoIVNVUEFCQVNFX1VSTCB8fCAhU1VQQUJBU0VfQU5PTl9LRVkpIHJldHVybiBudWxsXHJcbiAgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQ8RGF0YWJhc2U+KFNVUEFCQVNFX1VSTCwgU1VQQUJBU0VfQU5PTl9LRVksIHtcclxuICAgIGF1dGg6IHtcclxuICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHN1cGFiYXNlO1xyXG59XHJcblxyXG4vLyBNb2NrIGZhbGxiYWNrIGZvciBkZXYgd2l0aG91dCBlbnYgY29uZmlndXJlZFxyXG5jb25zdCBtb2NrID0ge1xyXG4gIHN0YWdlczogW1xyXG4gICAgeyBpZDogJ3MxJywgbmFtZTogJ05ldycsIG9yZGVyX2luZGV4OiAxMCwgcHJvYmFiaWxpdHk6IDEwIH0sXHJcbiAgICB7IGlkOiAnczInLCBuYW1lOiAnQ29udGFjdGVkJywgb3JkZXJfaW5kZXg6IDIwLCBwcm9iYWJpbGl0eTogMjUgfSxcclxuICAgIHsgaWQ6ICdzMycsIG5hbWU6ICdRdWFsaWZpZWQnLCBvcmRlcl9pbmRleDogMzAsIHByb2JhYmlsaXR5OiA0NSB9XHJcbiAgXSBhcyBTdGFnZVtdLFxyXG4gIGRlYWxzQnlTdGFnZToge1xyXG4gICAgczE6IFt7IGlkOiAnZDEnLCB0aXRsZTogJ0FjbWUgLSBQaWxvdCcsIHN0YWdlX2lkOiAnczEnLCBhbW91bnQ6IDI1MDAsIGN1cnJlbmN5OiAnVVNEJyB9XSxcclxuICAgIHMyOiBbXSxcclxuICAgIHMzOiBbXVxyXG4gIH0gYXMgUmVjb3JkPHN0cmluZywgRGVhbENhcmRbXT4sXHJcbiAgYWN0aXZpdGllczogW1xyXG4gICAgeyBpZDogJ2ExJywgdHlwZTogJ3N5c3RlbScsIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLCByZWxhdGVkX2lkOiAnZDEnLCBjb250ZW50OiAnU2VlZDogZGVhbCBjcmVhdGVkJywgbWV0YV9qc29uOiBudWxsLCBjcmVhdGVkX2J5OiBudWxsLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfVxyXG4gIF0gYXMgQWN0aXZpdHlbXSxcclxuICBjb250YWN0OiB7XHJcbiAgICBpZDogJ2MxJywgZW1haWw6ICdqb2huQGFjbWUuY29tJywgZnVsbF9uYW1lOiAnSm9obiBEb2UnLCB0aXRsZTogJ1ZQIFNhbGVzJyxcclxuICAgIGxpbmtlZGluX3VybDogJ2h0dHBzOi8vbGlua2VkaW4uY29tL2luL2pvaG5kb2UnLCB3ZWJzaXRlOiAnaHR0cHM6Ly9hY21lLmNvbScsXHJcbiAgICBwaG9uZTogbnVsbCwgY29tcGFueV9pZDogbnVsbCwgb3duZXJfaWQ6IG51bGwsIGxpZmVjeWNsZV9zdGFnZTogJ2xlYWQnLFxyXG4gICAgcmVwbHlfc3RhdHVzOiBudWxsLCByZXBseV9zdW1tYXJ5OiBudWxsLCBnZW5lcmF0ZWRfYm9keV9zdGVwMTogbnVsbCwgZ2VuZXJhdGVkX2JvZHlfc3RlcDI6IG51bGwsIGdlbmVyYXRlZF9ib2R5X3N0ZXAzOiBudWxsLFxyXG4gICAgbGF0ZXN0X2VtYWlsX3NlbnRfYXQ6IG51bGwsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgfSBhcyBDb250YWN0XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQaXBlbGluZVN0YWdlcyhwaXBlbGluZUlkPzogc3RyaW5nKTogUHJvbWlzZTxTdGFnZVtdPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLnN0YWdlc1xyXG5cclxuICBsZXQgZWZmZWN0aXZlUGlwZWxpbmVJZCA9IHBpcGVsaW5lSWQ7XHJcbiAgaWYgKCFlZmZlY3RpdmVQaXBlbGluZUlkIHx8IGVmZmVjdGl2ZVBpcGVsaW5lSWQgPT09ICdwX2RlZmF1bHQnKSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IGRlZmF1bHRQaXBlbGluZSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3BpcGVsaW5lcycpLnNlbGVjdCgnaWQnKS5lcSgnaXNfZGVmYXVsdCcsIHRydWUpLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSkubGltaXQoMSkubWF5YmVTaW5nbGUoKTtcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICBpZiAoIWRlZmF1bHRQaXBlbGluZSkgcmV0dXJuIFtdO1xyXG4gICAgZWZmZWN0aXZlUGlwZWxpbmVJZCA9IGRlZmF1bHRQaXBlbGluZS5pZDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgncGlwZWxpbmVfc3RhZ2VzJylcclxuICAgIC5zZWxlY3QoJ2lkLG5hbWUsb3JkZXJfaW5kZXgscHJvYmFiaWxpdHknKVxyXG4gICAgLmVxKCdwaXBlbGluZV9pZCcsIGVmZmVjdGl2ZVBpcGVsaW5lSWQpXHJcbiAgICAub3JkZXIoJ29yZGVyX2luZGV4JywgeyBhc2NlbmRpbmc6IHRydWUgfSlcclxuXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gIHJldHVybiAoZGF0YSA/PyBbXSkgYXMgU3RhZ2VbXVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbHNCeVBpcGVsaW5lKHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIERlYWxDYXJkW10+PiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLmRlYWxzQnlTdGFnZVxyXG5cclxuICAvLyByZXNvbHZlIHBpcGVsaW5lIGlkXHJcbiAgbGV0IGVmZmVjdGl2ZVBpcGVsaW5lSWQgPSBwaXBlbGluZUlkO1xyXG4gIGlmICghZWZmZWN0aXZlUGlwZWxpbmVJZCB8fCBlZmZlY3RpdmVQaXBlbGluZUlkID09PSAncF9kZWZhdWx0Jykge1xyXG4gICAgY29uc3QgeyBkYXRhOiBkZWZhdWx0UGlwZWxpbmUsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwaXBlbGluZXMnKS5zZWxlY3QoJ2lkJykuZXEoJ2lzX2RlZmF1bHQnLCB0cnVlKS5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pLmxpbWl0KDEpLm1heWJlU2luZ2xlKCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgaWYgKCFkZWZhdWx0UGlwZWxpbmUpIHJldHVybiB7fTtcclxuICAgIGVmZmVjdGl2ZVBpcGVsaW5lSWQgPSBkZWZhdWx0UGlwZWxpbmUuaWQ7XHJcbiAgfVxyXG5cclxuICAvLyBmZXRjaCBkZWFscyArIGpvaW4gbmFtZXNcclxuICBjb25zdCB7IGRhdGE6IGRlYWxzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgIC5mcm9tKCdkZWFscycpXHJcbiAgICAuc2VsZWN0KCdpZCx0aXRsZSxhbW91bnQsY3VycmVuY3ksc3RhZ2VfaWQsY29tcGFueV9pZCxjb250YWN0X2lkJylcclxuICAgIC5lcSgncGlwZWxpbmVfaWQnLCBlZmZlY3RpdmVQaXBlbGluZUlkKVxyXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgLy8gZmV0Y2ggcmVsYXRlZCBuYW1lcyBpbiBvbmUgZ29cclxuICBjb25zdCBjb21wYW55SWRzID0gQXJyYXkuZnJvbShuZXcgU2V0KChkZWFscyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGQuY29tcGFueV9pZCkuZmlsdGVyKEJvb2xlYW4pKSkgYXMgc3RyaW5nW11cclxuICBjb25zdCBjb250YWN0SWRzID0gQXJyYXkuZnJvbShuZXcgU2V0KChkZWFscyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGQuY29udGFjdF9pZCkuZmlsdGVyKEJvb2xlYW4pKSkgYXMgc3RyaW5nW11cclxuXHJcbiAgY29uc3QgW2NvbXBhbmllc1JlcywgY29udGFjdHNSZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgY29tcGFueUlkcy5sZW5ndGggPyBzdXBhYmFzZS5mcm9tKCdjb21wYW5pZXMnKS5zZWxlY3QoJ2lkLG5hbWUnKS5pbignaWQnLCBjb21wYW55SWRzKSA6IFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IFtdIGFzIHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1bXSwgZXJyb3I6IG51bGwgfSksXHJcbiAgICBjb250YWN0SWRzLmxlbmd0aCA/IHN1cGFiYXNlLmZyb20oJ2NvbnRhY3RzJykuc2VsZWN0KCdpZCxmdWxsX25hbWUnKS5pbignaWQnLCBjb250YWN0SWRzKSA6IFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IFtdIGFzIHsgaWQ6IHN0cmluZzsgZnVsbF9uYW1lOiBzdHJpbmcgfCBudWxsIH1bXSwgZXJyb3I6IG51bGwgfSlcclxuICBdKVxyXG5cclxuICBpZiAoY29tcGFuaWVzUmVzLmVycm9yKSB0aHJvdyBjb21wYW5pZXNSZXMuZXJyb3JcclxuICBpZiAoY29udGFjdHNSZXMuZXJyb3IpIHRocm93IGNvbnRhY3RzUmVzLmVycm9yXHJcblxyXG4gIGNvbnN0IGNvbXBhbnlNYXAgPSBuZXcgTWFwKChjb21wYW5pZXNSZXMuZGF0YSA/PyBbXSkubWFwKChjOiB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9KSA9PiBbYy5pZCwgYy5uYW1lXSkpXHJcbiAgY29uc3QgY29udGFjdE1hcCA9IG5ldyBNYXAoKGNvbnRhY3RzUmVzLmRhdGEgPz8gW10pLm1hcCgoYzogeyBpZDogc3RyaW5nOyBmdWxsX25hbWU6IHN0cmluZyB8IG51bGwgfSkgPT4gW2MuaWQsIGMuZnVsbF9uYW1lXSkpXHJcblxyXG4gIGNvbnN0IGdyb3VwZWQ6IFJlY29yZDxzdHJpbmcsIERlYWxDYXJkW10+ID0ge31cclxuICBmb3IgKGNvbnN0IGQgb2YgKGRlYWxzID8/IFtdKSBhcyBBcnJheTx7XHJcbiAgICBpZDogc3RyaW5nOyB0aXRsZTogc3RyaW5nOyBhbW91bnQ6IG51bWJlciB8IG51bGw7IGN1cnJlbmN5OiBzdHJpbmcgfCBudWxsOyBzdGFnZV9pZDogc3RyaW5nOyBjb21wYW55X2lkOiBzdHJpbmcgfCBudWxsOyBjb250YWN0X2lkOiBzdHJpbmcgfCBudWxsO1xyXG4gIH0+KSB7XHJcbiAgICBjb25zdCBjYXJkOiBEZWFsQ2FyZCA9IHtcclxuICAgICAgaWQ6IGQuaWQsXHJcbiAgICAgIHRpdGxlOiBkLnRpdGxlLFxyXG4gICAgICBhbW91bnQ6IGQuYW1vdW50ID8/IG51bGwsXHJcbiAgICAgIGN1cnJlbmN5OiBkLmN1cnJlbmN5ID8/IG51bGwsXHJcbiAgICAgIHN0YWdlX2lkOiBkLnN0YWdlX2lkLFxyXG4gICAgICBjb21wYW55OiBkLmNvbXBhbnlfaWQgPyAoY29tcGFueU1hcC5nZXQoZC5jb21wYW55X2lkKSA/PyBudWxsKSA6IG51bGwsXHJcbiAgICAgIGNvbnRhY3Q6IGQuY29udGFjdF9pZCA/IChjb250YWN0TWFwLmdldChkLmNvbnRhY3RfaWQpID8/IG51bGwpIDogbnVsbFxyXG4gICAgfVxyXG4gICAgaWYgKCFncm91cGVkW2Quc3RhZ2VfaWRdKSBncm91cGVkW2Quc3RhZ2VfaWRdID0gW11cclxuICAgIGdyb3VwZWRbZC5zdGFnZV9pZF0ucHVzaChjYXJkKVxyXG4gIH1cclxuICByZXR1cm4gZ3JvdXBlZFxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVhbERldGFpbChpZDogc3RyaW5nKTogUHJvbWlzZTxEZWFsIHwgbnVsbD4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSB7XHJcbiAgICBjb25zdCBhbnlEZWFsID0gKE9iamVjdC52YWx1ZXMobW9jay5kZWFsc0J5U3RhZ2UpLmZsYXQoKVswXSBhcyBEZWFsQ2FyZCB8IHVuZGVmaW5lZClcclxuICAgIGlmICghYW55RGVhbCkgcmV0dXJuIG51bGxcclxuICAgIC8vIG1pbmltYWwgbW9jayBjYXN0XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogYW55RGVhbC5pZCxcclxuICAgICAgdGl0bGU6IGFueURlYWwudGl0bGUsXHJcbiAgICAgIGFtb3VudDogYW55RGVhbC5hbW91bnQgPz8gbnVsbCxcclxuICAgICAgY3VycmVuY3k6IGFueURlYWwuY3VycmVuY3kgPz8gbnVsbCxcclxuICAgICAgY29tcGFueV9pZDogbnVsbCxcclxuICAgICAgY29udGFjdF9pZDogbnVsbCxcclxuICAgICAgcGlwZWxpbmVfaWQ6ICdkZWZhdWx0JyxcclxuICAgICAgc3RhZ2VfaWQ6IGFueURlYWwuc3RhZ2VfaWQsXHJcbiAgICAgIHN0YXR1czogJ29wZW4nLFxyXG4gICAgICBzb3VyY2U6ICdpbmJvdW5kJyxcclxuICAgICAgbm90ZXM6ICdNb2NrJyxcclxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIGNsb3NlX2RhdGU6IG51bGxcclxuICAgIH0gYXMgdW5rbm93biBhcyBEZWFsXHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdkZWFscycpLnNlbGVjdCgnKicpLmVxKCdpZCcsIGlkKS5tYXliZVNpbmdsZSgpXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gIHJldHVybiAoZGF0YSBhcyBEZWFsIHwgbnVsbClcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2aXRpZXNGb3IocmVsYXRlZFR5cGU6ICdkZWFsJ3wnY29udGFjdCd8J2NvbXBhbnknLCByZWxhdGVkSWQ6IHN0cmluZyk6IFByb21pc2U8QWN0aXZpdHlbXT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4gbW9jay5hY3Rpdml0aWVzXHJcblxyXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgnYWN0aXZpdGllcycpXHJcbiAgICAuc2VsZWN0KCcqJylcclxuICAgIC5lcSgncmVsYXRlZF90eXBlJywgcmVsYXRlZFR5cGUpXHJcbiAgICAuZXEoJ3JlbGF0ZWRfaWQnLCByZWxhdGVkSWQpXHJcbiAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgcmV0dXJuIChkYXRhID8/IFtdKSBhcyBBY3Rpdml0eVtdXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPENvbnRhY3QgfCBudWxsPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKVxyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLmNvbnRhY3RcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdjb250YWN0cycpLnNlbGVjdCgnKicpLmVxKCdpZCcsIGlkKS5tYXliZVNpbmdsZSgpXHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gIHJldHVybiAoZGF0YSBhcyBDb250YWN0IHwgbnVsbClcclxufVxyXG5cclxuLy8gQWRkZWQgdG8gcmVzb2x2ZSBhIGJ1aWxkIGVycm9yIHdoZXJlICdnZXRDb250YWN0Rm9yRGVhbCcgd2FzIHJlcG9ydGVkIGFzIG1pc3NpbmcsXHJcbi8vIGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGV4cGxpY2l0bHkgaW1wb3J0ZWQgaW4gdGhlIHJlbGV2YW50IGZpbGVzLlxyXG4vLyBJdCBzaW1wbHkgZGVsZWdhdGVzIHRvIGdldENvbnRhY3QsIGFzIHRoYXQncyB0aGUgaW50ZW5kZWQgbG9naWMuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250YWN0Rm9yRGVhbChjb250YWN0SWQ6IHN0cmluZyk6IFByb21pc2U8Q29udGFjdCB8IG51bGw+IHtcclxuICByZXR1cm4gZ2V0Q29udGFjdChjb250YWN0SWQpO1xyXG59XHJcblxyXG4vLyBBZGRlZCB0byByZXNvbHZlIGEgYnVpbGQgZXJyb3Igd2hlcmUgJ2dldFN0YWdlTmFtZScgd2FzIHJlcG9ydGVkIGFzIG1pc3NpbmcuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGFnZU5hbWUoc3RhZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldENsaWVudCgpO1xyXG4gIGlmICghc3VwYWJhc2UpIHJldHVybiBtb2NrLnN0YWdlcy5maW5kKHMgPT4gcy5pZCA9PT0gc3RhZ2VJZCk/Lm5hbWU7XHJcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncGlwZWxpbmVfc3RhZ2VzJykuc2VsZWN0KCduYW1lJykuZXEoJ2lkJywgc3RhZ2VJZCkubWF5YmVTaW5nbGUoKTtcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIHJldHVybiBkYXRhPy5uYW1lO1xyXG59XHJcblxyXG4vLyBBY3Rpb25zICh3cml0ZSkg4oCUIHByb3RlY3RlZCBieSBSTFM7IGV4cGVjdCBKV1QgaW4gZnJvbnRlbmQgY29udGV4dC5cclxuLy8gRm9yIFNTUi9FZGdlIHNlY3VyZSB3cml0ZXMsIHByZWZlciBzZXJ2ZXItb25seSBrZXkgb3IgZWRnZSBmdW5jdGlvbiBwcm94eS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURlYWxTdGFnZShkZWFsSWQ6IHN0cmluZywgbmV4dFN0YWdlSWQ6IHN0cmluZyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KClcclxuICBpZiAoIXN1cGFiYXNlKSByZXR1cm4geyBvazogdHJ1ZSB9XHJcblxyXG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2RlYWxzJykudXBkYXRlKHsgc3RhZ2VfaWQ6IG5leHRTdGFnZUlkIH0pLmVxKCdpZCcsIGRlYWxJZClcclxuICBpZiAoZXJyb3IpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfVxyXG4gIHJldHVybiB7IG9rOiB0cnVlIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhY3RTdGF0dXMoY29udGFjdElkOiBzdHJpbmcsIHN0YXR1czogJ2ludGVyZXN0ZWQnIHwgJ25vdF9pbnRlcmVzdGVkJyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxuXHJcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgnY29udGFjdHMnKS51cGRhdGUoeyByZXBseV9zdGF0dXM6IHN0YXR1cyB9KS5lcSgnaWQnLCBjb250YWN0SWQpO1xyXG4gIGlmIChlcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xyXG4gIHJldHVybiB7IG9rOiB0cnVlIH07XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxlbmRhckxpbmsoY29udGFjdElkOiBzdHJpbmcpOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IHVybD86IHN0cmluZzsgZXJyb3I/OiBzdHJpbmcgfT4ge1xyXG4gIC8vIFRoaXMgaXMgYSBtb2NrIGltcGxlbWVudGF0aW9uLiBJbiBhIHJlYWwgYXBwLCB5b3UnZCBnZW5lcmF0ZSBhIHVuaXF1ZSBsaW5rXHJcbiAgLy8gb3IgZmV0Y2ggaXQgZnJvbSBhIGNhbGVuZGFyIHNlcnZpY2UuXHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIHVybDogYGh0dHBzOi8vY2FsLmNvbS95b3VyLXVzZXJuYW1lLyR7Y29udGFjdElkfWAgfTtcclxufVxyXG5cclxuLy8gSGVscGVyIHRvIGRldGVjdCBlbnYgcHJlc2VuY2VcclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwYWJhc2VDb25maWd1cmVkKCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBCb29sZWFuKFNVUEFCQVNFX1VSTCAmJiBTVVBBQkFTRV9BTk9OX0tFWSlcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9wZW5EZWFsc0NvdW50KHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIDQyOyAvLyBNb2NrIGRhdGFcclxuXHJcbiAgbGV0IGVmZmVjdGl2ZVBpcGVsaW5lSWQgPSBwaXBlbGluZUlkO1xyXG4gIGlmICghZWZmZWN0aXZlUGlwZWxpbmVJZCB8fCBlZmZlY3RpdmVQaXBlbGluZUlkID09PSAncF9kZWZhdWx0Jykge1xyXG4gICAgY29uc3QgeyBkYXRhOiBkZWZhdWx0UGlwZWxpbmUsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwaXBlbGluZXMnKS5zZWxlY3QoJ2lkJykuZXEoJ2lzX2RlZmF1bHQnLCB0cnVlKS5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pLmxpbWl0KDEpLm1heWJlU2luZ2xlKCk7XHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgaWYgKCFkZWZhdWx0UGlwZWxpbmUpIHJldHVybiAwO1xyXG4gICAgZWZmZWN0aXZlUGlwZWxpbmVJZCA9IGRlZmF1bHRQaXBlbGluZS5pZDtcclxuICB9XHJcblxyXG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlLmZyb20oJ2RlYWxzJykuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcgfSkuZXEoJ3N0YXR1cycsICdvcGVuJyk7XHJcbiAgaWYgKGVmZmVjdGl2ZVBpcGVsaW5lSWQpIHtcclxuICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3BpcGVsaW5lX2lkJywgZWZmZWN0aXZlUGlwZWxpbmVJZCk7XHJcbiAgfVxyXG4gIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIHJldHVybiBjb3VudCA/PyAwO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGFzdDdEYXlzUmVwbHlDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0Q2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkgcmV0dXJuIDE1OyAvLyBNb2NrIGRhdGFcclxuXHJcbiAgY29uc3Qgc2V2ZW5EYXlzQWdvID0gbmV3IERhdGUoKTtcclxuICBzZXZlbkRheXNBZ28uc2V0RGF0ZShzZXZlbkRheXNBZ28uZ2V0RGF0ZSgpIC0gNyk7XHJcblxyXG4gIGNvbnN0IHsgY291bnQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oJ2NvbnRhY3RzJylcclxuICAgIC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JyB9KVxyXG4gICAgLm5vdCgncmVwbHlfc3RhdHVzJywgJ2lzJywgbnVsbClcclxuICAgIC5ndGUoJ3VwZGF0ZWRfYXQnLCBzZXZlbkRheXNBZ28udG9JU09TdHJpbmcoKSk7IC8vIEFzc3VtaW5nIHVwZGF0ZWRfYXQgcmVmbGVjdHMgcmVwbHkgc3RhdHVzIGNoYW5nZXNcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIHJldHVybiBjb3VudCA/PyAwO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGlwZWxpbmVDb252ZXJzaW9uKHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPFBpcGVsaW5lQ29udmVyc2lvbltdPiB7XHJcbiAgY29uc3Qgc3VwYWJhc2UgPSBnZXRDbGllbnQoKTtcclxuICBpZiAoIXN1cGFiYXNlKSB7XHJcbiAgICByZXR1cm4gWyAvLyBNb2NrIGRhdGFcclxuICAgICAgeyBzdGFnZV9pZDogJ3MxJywgc3RhZ2VfbmFtZTogJ05ldycsIGNvdW50OiAxMCwgY29udmVyc2lvbl90b19uZXh0OiA1MCB9LFxyXG4gICAgICB7IHN0YWdlX2lkOiAnczInLCBzdGFnZV9uYW1lOiAnQ29udGFjdGVkJywgY291bnQ6IDUsIGNvbnZlcnNpb25fdG9fbmV4dDogODAgfSxcclxuICAgICAgeyBzdGFnZV9pZDogJ3MzJywgc3RhZ2VfbmFtZTogJ1F1YWxpZmllZCcsIGNvdW50OiA0LCBjb252ZXJzaW9uX3RvX25leHQ6IHVuZGVmaW5lZCB9LFxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIG1vY2sgZm9yIGNvbnZlcnNpb24uIEEgcmVhbCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBpbnZvbHZlXHJcbiAgLy8gbW9yZSBjb21wbGV4IFNRTCBxdWVyaWVzIG9yIGEgbWF0ZXJpYWxpemVkIHZpZXcgdG8gY2FsY3VsYXRlIGNvbnZlcnNpb25zIGJldHdlZW4gc3RhZ2VzLlxyXG4gIGNvbnN0IHN0YWdlcyA9IGF3YWl0IGdldFBpcGVsaW5lU3RhZ2VzKHBpcGVsaW5lSWQpO1xyXG4gIGNvbnN0IGRlYWxzQnlTdGFnZSA9IGF3YWl0IGdldERlYWxzQnlQaXBlbGluZShwaXBlbGluZUlkKTtcclxuXHJcbiAgY29uc3Qgc3RhZ2VDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICBmb3IgKGNvbnN0IHN0YWdlIG9mIHN0YWdlcykge1xyXG4gICAgc3RhZ2VDb3VudHNbc3RhZ2UuaWRdID0gZGVhbHNCeVN0YWdlW3N0YWdlLmlkXT8ubGVuZ3RoIHx8IDA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb252ZXJzaW9uRGF0YTogUGlwZWxpbmVDb252ZXJzaW9uW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgY3VycmVudFN0YWdlID0gc3RhZ2VzW2ldO1xyXG4gICAgY29uc3QgY3VycmVudENvdW50ID0gc3RhZ2VDb3VudHNbY3VycmVudFN0YWdlLmlkXTtcclxuICAgIGxldCBjb252ZXJzaW9uVG9OZXh0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKGkgPCBzdGFnZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICBjb25zdCBuZXh0U3RhZ2UgPSBzdGFnZXNbaSArIDFdO1xyXG4gICAgICBjb25zdCBuZXh0Q291bnQgPSBzdGFnZUNvdW50c1tuZXh0U3RhZ2UuaWRdO1xyXG4gICAgICBpZiAoY3VycmVudENvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnZlcnNpb25Ub05leHQgPSBNYXRoLnJvdW5kKChuZXh0Q291bnQgLyBjdXJyZW50Q291bnQpICogMTAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnZlcnNpb25EYXRhLnB1c2goe1xyXG4gICAgICBzdGFnZV9pZDogY3VycmVudFN0YWdlLmlkLFxyXG4gICAgICBzdGFnZV9uYW1lOiBjdXJyZW50U3RhZ2UubmFtZSxcclxuICAgICAgY291bnQ6IGN1cnJlbnRDb3VudCxcclxuICAgICAgY29udmVyc2lvbl90b19uZXh0OiBjb252ZXJzaW9uVG9OZXh0LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29udmVyc2lvbkRhdGE7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFBpcGVsaW5lQ29udmVyc2lvbiA9IHtcclxuICBzdGFnZV9pZDogc3RyaW5nO1xyXG4gIHN0YWdlX25hbWU6IHN0cmluZztcclxuICBjb3VudDogbnVtYmVyO1xyXG4gIGNvbnZlcnNpb25fdG9fbmV4dD86IG51bWJlcjtcclxufTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsIlNVUEFCQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJTVVBBQkFTRV9BTk9OX0tFWSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2UiLCJnZXRDbGllbnQiLCJhdXRoIiwicGVyc2lzdFNlc3Npb24iLCJtb2NrIiwic3RhZ2VzIiwiaWQiLCJuYW1lIiwib3JkZXJfaW5kZXgiLCJwcm9iYWJpbGl0eSIsImRlYWxzQnlTdGFnZSIsInMxIiwidGl0bGUiLCJzdGFnZV9pZCIsImFtb3VudCIsImN1cnJlbmN5IiwiczIiLCJzMyIsImFjdGl2aXRpZXMiLCJ0eXBlIiwicmVsYXRlZF90eXBlIiwicmVsYXRlZF9pZCIsImNvbnRlbnQiLCJtZXRhX2pzb24iLCJjcmVhdGVkX2J5IiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbnRhY3QiLCJlbWFpbCIsImZ1bGxfbmFtZSIsImxpbmtlZGluX3VybCIsIndlYnNpdGUiLCJwaG9uZSIsImNvbXBhbnlfaWQiLCJvd25lcl9pZCIsImxpZmVjeWNsZV9zdGFnZSIsInJlcGx5X3N0YXR1cyIsInJlcGx5X3N1bW1hcnkiLCJnZW5lcmF0ZWRfYm9keV9zdGVwMSIsImdlbmVyYXRlZF9ib2R5X3N0ZXAyIiwiZ2VuZXJhdGVkX2JvZHlfc3RlcDMiLCJsYXRlc3RfZW1haWxfc2VudF9hdCIsInVwZGF0ZWRfYXQiLCJnZXRQaXBlbGluZVN0YWdlcyIsInBpcGVsaW5lSWQiLCJlZmZlY3RpdmVQaXBlbGluZUlkIiwiZGF0YSIsImRlZmF1bHRQaXBlbGluZSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJsaW1pdCIsIm1heWJlU2luZ2xlIiwiZ2V0RGVhbHNCeVBpcGVsaW5lIiwiZGVhbHMiLCJjb21wYW55SWRzIiwiQXJyYXkiLCJTZXQiLCJtYXAiLCJkIiwiZmlsdGVyIiwiQm9vbGVhbiIsImNvbnRhY3RJZHMiLCJjb250YWN0X2lkIiwiY29tcGFuaWVzUmVzIiwiY29udGFjdHNSZXMiLCJQcm9taXNlIiwiYWxsIiwibGVuZ3RoIiwiaW4iLCJyZXNvbHZlIiwiY29tcGFueU1hcCIsIk1hcCIsImMiLCJjb250YWN0TWFwIiwiZ3JvdXBlZCIsImNhcmQiLCJjb21wYW55IiwiZ2V0IiwicHVzaCIsImdldERlYWxEZXRhaWwiLCJhbnlEZWFsIiwiT2JqZWN0IiwidmFsdWVzIiwiZmxhdCIsInBpcGVsaW5lX2lkIiwic3RhdHVzIiwic291cmNlIiwibm90ZXMiLCJjbG9zZV9kYXRlIiwiZ2V0QWN0aXZpdGllc0ZvciIsInJlbGF0ZWRUeXBlIiwicmVsYXRlZElkIiwiZ2V0Q29udGFjdCIsImdldENvbnRhY3RGb3JEZWFsIiwiY29udGFjdElkIiwiZ2V0U3RhZ2VOYW1lIiwic3RhZ2VJZCIsImZpbmQiLCJzIiwidXBkYXRlRGVhbFN0YWdlIiwiZGVhbElkIiwibmV4dFN0YWdlSWQiLCJvayIsInVwZGF0ZSIsIm1lc3NhZ2UiLCJ1cGRhdGVDb250YWN0U3RhdHVzIiwiZ2V0Q2FsZW5kYXJMaW5rIiwidXJsIiwiaXNTdXBhYmFzZUNvbmZpZ3VyZWQiLCJnZXRPcGVuRGVhbHNDb3VudCIsInF1ZXJ5IiwiY291bnQiLCJnZXRMYXN0N0RheXNSZXBseUNvdW50Iiwic2V2ZW5EYXlzQWdvIiwic2V0RGF0ZSIsImdldERhdGUiLCJub3QiLCJndGUiLCJnZXRQaXBlbGluZUNvbnZlcnNpb24iLCJzdGFnZV9uYW1lIiwiY29udmVyc2lvbl90b19uZXh0IiwidW5kZWZpbmVkIiwic3RhZ2VDb3VudHMiLCJzdGFnZSIsImNvbnZlcnNpb25EYXRhIiwiaSIsImN1cnJlbnRTdGFnZSIsImN1cnJlbnRDb3VudCIsImNvbnZlcnNpb25Ub05leHQiLCJuZXh0U3RhZ2UiLCJuZXh0Q291bnQiLCJNYXRoIiwicm91bmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});