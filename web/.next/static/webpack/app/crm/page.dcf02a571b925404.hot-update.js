"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/crm/page",{

/***/ "(app-pages-browser)/./app/services/crmApi.ts":
/*!********************************!*\
  !*** ./app/services/crmApi.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActivitiesFor: function() { return /* binding */ getActivitiesFor; },\n/* harmony export */   getCalendarLink: function() { return /* binding */ getCalendarLink; },\n/* harmony export */   getContact: function() { return /* binding */ getContact; },\n/* harmony export */   getContactForDeal: function() { return /* binding */ getContactForDeal; },\n/* harmony export */   getDealDetail: function() { return /* binding */ getDealDetail; },\n/* harmony export */   getDealsByPipeline: function() { return /* binding */ getDealsByPipeline; },\n/* harmony export */   getLast7DaysReplyCount: function() { return /* binding */ getLast7DaysReplyCount; },\n/* harmony export */   getOpenDealsCount: function() { return /* binding */ getOpenDealsCount; },\n/* harmony export */   getPipelineConversion: function() { return /* binding */ getPipelineConversion; },\n/* harmony export */   getPipelineStages: function() { return /* binding */ getPipelineStages; },\n/* harmony export */   getRepliesLast7d: function() { return /* binding */ getRepliesLast7d; },\n/* harmony export */   getSimpleConversion: function() { return /* binding */ getSimpleConversion; },\n/* harmony export */   getStageDistribution: function() { return /* binding */ getStageDistribution; },\n/* harmony export */   getStageName: function() { return /* binding */ getStageName; },\n/* harmony export */   updateContactStatus: function() { return /* binding */ updateContactStatus; },\n/* harmony export */   updateDeal: function() { return /* binding */ updateDeal; },\n/* harmony export */   updateDealStage: function() { return /* binding */ updateDealStage; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\r\n * Read-only CRM API helpers (MVP skeleton).\r\n * Implementation note:\r\n * - Start with mock/placeholder implementations.\r\n * - Replace with Supabase client or backend proxy once auth/RLS strategy is set.\r\n */ const MOCK_DELAY = 150;\nfunction sleep() {\n    let ms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MOCK_DELAY;\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\r\n * Edge Actions HTTP helpers (MVP)\r\n * Switchable via NEXT_PUBLIC_CRM_API_BASE:\r\n * - If defined: real Edge endpoint calls\r\n * - If not defined: fallback to mock in-memory behavior\r\n */ function getApiBase() {\n    var _process_env;\n    // e.g. http://localhost:8000 or / (if proxied)\n    if (typeof process !== \"undefined\" && ((_process_env = process.env) === null || _process_env === void 0 ? void 0 : _process_env.NEXT_PUBLIC_CRM_API_BASE)) {\n        return process.env.NEXT_PUBLIC_CRM_API_BASE;\n    }\n    return null;\n}\nasync function getAuthToken() {\n    // TODO: integrate with Supabase/NextAuth. For now, return null (no Authorization header).\n    return null;\n}\nasync function apiRequest(path) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const base = getApiBase();\n    if (!base) {\n        // no base configured â†’ fallback inform caller to use mocks\n        return {\n            ok: false,\n            status: 0,\n            error: \"API base not configured (using mock fallback)\"\n        };\n    }\n    const url = path.startsWith(\"http\") ? path : \"\".concat(base.replace(/\\/+$/, \"\"), \"/\").concat(path.replace(/^\\/+/, \"\"));\n    const token = await getAuthToken();\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        ...opts.headers || {}\n    };\n    if (token) headers[\"Authorization\"] = \"Bearer \".concat(token);\n    if (opts.idempotencyKey) headers[\"Idempotency-Key\"] = opts.idempotencyKey;\n    const res = await fetch(url, {\n        method: opts.method || \"POST\",\n        headers,\n        body: typeof opts.body !== \"undefined\" ? JSON.stringify(opts.body) : undefined\n    });\n    let payload = undefined;\n    try {\n        payload = await res.json();\n    } catch (e) {\n    // ignore body parse errors\n    }\n    if (!res.ok) {\n        const msg = typeof (payload === null || payload === void 0 ? void 0 : payload.error) === \"string\" ? payload.error : \"HTTP \".concat(res.status);\n        return {\n            ok: false,\n            status: res.status,\n            error: msg\n        };\n    }\n    return {\n        ok: true,\n        status: res.status,\n        data: payload\n    };\n}\n// In-memory mock\nconst mockStages = [\n    {\n        id: \"s_new\",\n        name: \"New\",\n        order_index: 0,\n        probability: 0.05,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_contacted\",\n        name: \"Contacted\",\n        order_index: 1,\n        probability: 0.15,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_qualified\",\n        name: \"Qualified\",\n        order_index: 2,\n        probability: 0.35,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_meeting\",\n        name: \"Meeting Scheduled\",\n        order_index: 3,\n        probability: 0.5,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_proposal\",\n        name: \"Proposal Sent\",\n        order_index: 4,\n        probability: 0.7,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_won\",\n        name: \"Won\",\n        order_index: 5,\n        probability: 1.0,\n        pipeline_id: \"p_default\"\n    },\n    {\n        id: \"s_lost\",\n        name: \"Lost\",\n        order_index: 6,\n        probability: 0,\n        pipeline_id: \"p_default\"\n    }\n];\nconst mockDeals = [\n    {\n        id: \"d1\",\n        title: \"Acme - Pilot\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_new\",\n        amount: 2500,\n        currency: \"USD\",\n        source: \"outbound\"\n    },\n    {\n        id: \"d2\",\n        title: \"Globex - Discovery\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_contacted\",\n        amount: 5000,\n        currency: \"USD\",\n        source: \"reply\"\n    },\n    {\n        id: \"d3\",\n        title: \"Initech - Expansion\",\n        pipeline_id: \"p_default\",\n        stage_id: \"s_meeting\",\n        amount: 12000,\n        currency: \"USD\",\n        source: \"booking\"\n    }\n];\nconst mockContacts = {\n    c1: {\n        id: \"c1\",\n        full_name: \"John Doe\",\n        email: \"john@acme.com\",\n        title: \"VP Sales\",\n        linkedin_url: \"https://linkedin.com/in/john\",\n        website: \"https://acme.com\"\n    },\n    c2: {\n        id: \"c2\",\n        full_name: \"Mike Neo\",\n        email: \"mike@globex.com\",\n        title: \"Head of Ops\",\n        linkedin_url: \"https://linkedin.com/in/mike\",\n        website: \"https://globex.example\",\n        reply_status: \"question\",\n        reply_summary: \"Asked about pricing\"\n    }\n};\nconst mockActivities = [\n    {\n        id: \"a1\",\n        type: \"email_in\",\n        related_type: \"deal\",\n        related_id: \"d2\",\n        content: \"pricing details?\",\n        created_at: new Date(Date.now() - 86400000).toISOString()\n    },\n    {\n        id: \"a2\",\n        type: \"meeting\",\n        related_type: \"deal\",\n        related_id: \"d3\",\n        content: \"Discovery Call scheduled\",\n        created_at: new Date(Date.now() - 3600000).toISOString()\n    },\n    {\n        id: \"a3\",\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: \"d1\",\n        content: \"Deal created\",\n        created_at: new Date(Date.now() - 1800000).toISOString()\n    }\n];\n// Map one contact to deals for demo\nconst dealToContact = {\n    d1: \"c1\",\n    d2: \"c2\",\n    d3: \"c2\"\n};\nasync function getPipelineStages(pipelineId) {\n    // TODO: Replace with Supabase select from pipeline_stages where pipeline_id = pipelineId order by order_index\n    await sleep();\n    return mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n}\nasync function getDealsByPipeline(pipelineId) {\n    // TODO: Replace with Supabase select from deals where pipeline_id = pipelineId\n    await sleep();\n    return mockDeals.filter((d)=>d.pipeline_id === pipelineId);\n}\nasync function getDealDetail(id) {\n    // TODO: Replace with Supabase select deals by id\n    await sleep();\n    const deal = mockDeals.find((d)=>d.id === id);\n    if (!deal) throw new Error(\"Deal not found\");\n    return deal;\n}\nasync function getActivitiesFor(relatedType, relatedId) {\n    // TODO: Replace with Supabase select activities where related_type = relatedType and related_id = relatedId order by created_at desc\n    await sleep();\n    return mockActivities.filter((a)=>a.related_type === relatedType && a.related_id === relatedId).sort((a, b)=>+new Date(b.created_at) - +new Date(a.created_at));\n}\nasync function getContact(id) {\n    // TODO: Replace with Supabase select contacts by id\n    await sleep();\n    const c = mockContacts[id];\n    if (!c) throw new Error(\"Contact not found\");\n    return c;\n}\n/**\r\n * Sprint 2 â€” ContactQuick actions: interested / not_interested toggle\r\n * GerÃ§ek entegrasyonda POST /crm/actions/contacts Ã§aÄŸrÄ±sÄ±na dÃ¶nÃ¼ÅŸecektir.\r\n */ async function updateContactStatus(contactId, status) {\n    const base = getApiBase();\n    if (base) {\n        var _res_data;\n        // Real Edge call\n        const res = await apiRequest(\"crm/actions/contacts\", {\n            method: \"POST\",\n            body: {\n                id: contactId,\n                reply_status: status\n            },\n            idempotencyKey: \"contact-status:\".concat(contactId, \":\").concat(status, \":\").concat(new Date().toISOString())\n        });\n        if (!res.ok) return {\n            ok: false,\n            error: res.error || \"Contact update failed\"\n        };\n        return {\n            ok: true,\n            contact: (_res_data = res.data) === null || _res_data === void 0 ? void 0 : _res_data.contact\n        };\n    }\n    // Mock fallback\n    await sleep();\n    const c = mockContacts[contactId];\n    if (!c) return {\n        ok: false,\n        error: \"Contact not found\"\n    };\n    const prev = {\n        ...c\n    };\n    c.reply_status = status;\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"contact\",\n        related_id: contactId,\n        content: \"Contact status changed\",\n        meta_json: {\n            from: prev.reply_status,\n            to: status\n        },\n        created_at: new Date().toISOString()\n    });\n    return {\n        ok: true,\n        contact: c\n    };\n}\n/**\r\n * Sprint 2 â€” ContactQuick actions: send calendar link (placeholder)\r\n * S2: yalnÄ±zca link Ã¼retip dÃ¶ndÃ¼rÃ¼r; S3: gerÃ§ek e-posta/mesaj otomasyonu.\r\n */ async function getCalendarLink(contactId) {\n    var _mockContacts_contactId;\n    await sleep();\n    const base = \"https://cal.com/your-team/30min\";\n    // basitÃ§e kiÅŸi e-postasÄ±nÄ± query olarak iliÅŸtir\n    const email = ((_mockContacts_contactId = mockContacts[contactId]) === null || _mockContacts_contactId === void 0 ? void 0 : _mockContacts_contactId.email) || \"prospect@example.com\";\n    const url = \"\".concat(base, \"?email=\").concat(encodeURIComponent(email));\n    return {\n        ok: true,\n        url\n    };\n}\n// Helper to compute stage name for a given stage_id (useful for UI)\nasync function getStageName(pipelineId, stageId) {\n    var _stages_find;\n    const stages = await getPipelineStages(pipelineId);\n    return (_stages_find = stages.find((s)=>s.id === stageId)) === null || _stages_find === void 0 ? void 0 : _stages_find.name;\n}\n// Demo-only helpers to bridge mock relations\nasync function getContactForDeal(dealId) {\n    const contactId = dealToContact[dealId];\n    if (!contactId) return undefined;\n    return getContact(contactId);\n}\n/**\r\n * Reporting helpers (Snapshot MVP)\r\n * Note: Mock implementation using in-memory data; replace with Supabase/Edge queries later.\r\n */ async function getRepliesLast7d() {\n    await sleep();\n    const since = Date.now() - 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && +new Date(a.created_at) >= since).length;\n}\nasync function getStageDistribution(pipelineId) {\n    await sleep();\n    const dist = {};\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        dist[d.stage_id] = (dist[d.stage_id] || 0) + 1;\n    }\n    return dist;\n}\nasync function getSimpleConversion(pipelineId) {\n    await sleep();\n    // Basit bir oran: New -> Qualified\n    const from = \"s_new\";\n    const to = \"s_qualified\";\n    const inFrom = mockDeals.filter((d)=>d.pipeline_id === pipelineId && d.stage_id === from).length;\n    const inTo = mockDeals.filter((d)=>d.pipeline_id === pipelineId && d.stage_id === to).length;\n    const rate = inFrom > 0 ? Number((inTo / inFrom * 100).toFixed(0)) : null;\n    return {\n        from,\n        to,\n        rate\n    };\n}\nasync function updateDeal(input, options) {\n    const base = getApiBase();\n    if (base) {\n        var _res_data;\n        const res = await apiRequest(\"crm/actions/deals\", {\n            method: \"POST\",\n            body: input,\n            idempotencyKey: \"deal:\".concat(input.id, \":\").concat(new Date().toISOString())\n        });\n        if (!res.ok) return {\n            ok: false,\n            error: res.error || \"Deal update failed\"\n        };\n        return {\n            ok: true,\n            deal: (_res_data = res.data) === null || _res_data === void 0 ? void 0 : _res_data.deal\n        };\n    }\n    // Mock fallback\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) return {\n        ok: false,\n        error: \"Simulated update error\"\n    };\n    const idx = mockDeals.findIndex((d)=>d.id === input.id);\n    if (idx === -1) return {\n        ok: false,\n        error: \"Deal not found\"\n    };\n    const prev = mockDeals[idx];\n    if (typeof input.amount !== \"undefined\" && Number.isNaN(Number(input.amount))) {\n        return {\n            ok: false,\n            error: \"Amount must be numeric\"\n        };\n    }\n    if (typeof input.close_date !== \"undefined\") {\n        const t = Date.parse(input.close_date);\n        if (Number.isNaN(t)) return {\n            ok: false,\n            error: \"close_date must be ISO string\"\n        };\n    }\n    var _input_title, _input_currency, _input_close_date, _input_stage_id;\n    const next = {\n        ...prev,\n        title: (_input_title = input.title) !== null && _input_title !== void 0 ? _input_title : prev.title,\n        amount: typeof input.amount !== \"undefined\" ? Number(input.amount) : prev.amount,\n        currency: (_input_currency = input.currency) !== null && _input_currency !== void 0 ? _input_currency : prev.currency,\n        close_date: (_input_close_date = input.close_date) !== null && _input_close_date !== void 0 ? _input_close_date : prev.close_date,\n        stage_id: (_input_stage_id = input.stage_id) !== null && _input_stage_id !== void 0 ? _input_stage_id : prev.stage_id\n    };\n    mockDeals[idx] = next;\n    const changed = {};\n    for (const k of [\n        \"title\",\n        \"amount\",\n        \"currency\",\n        \"close_date\",\n        \"stage_id\"\n    ]){\n        if (prev[k] !== next[k]) changed[k] = {\n            from: prev[k],\n            to: next[k]\n        };\n    }\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: input.id,\n        content: \"Deal updated\",\n        meta_json: {\n            changed\n        },\n        created_at: new Date().toISOString()\n    });\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Sprint 2 - Ä°lk GÃ¶rev: Kanban Drag & Drop â†’ Stage Change\r\n * Mock ortamda optimistic UI akÄ±ÅŸÄ±nÄ± doÄŸrulamak iÃ§in stage gÃ¼ncelleme helper'Ä±.\r\n * GerÃ§ek entegrasyonda bu fonksiyon, Edge Function'a (POST /crm/actions/deals/:id/stage) Ã§aÄŸrÄ± yapacak.\r\n */ async function updateDealStage(dealId, nextStageId, options) {\n    const base = getApiBase();\n    if (base) {\n        var _res_data;\n        const res = await apiRequest(\"crm/actions/deals/\".concat(encodeURIComponent(dealId), \"/stage\"), {\n            method: \"POST\",\n            body: {\n                next_stage_id: nextStageId,\n                occurred_at: (options === null || options === void 0 ? void 0 : options.occurredAtISO) || new Date().toISOString()\n            },\n            idempotencyKey: (options === null || options === void 0 ? void 0 : options.idempotencyKey) || \"deal-stage:\".concat(dealId, \":\").concat(nextStageId, \":\").concat(new Date().toISOString())\n        });\n        if (!res.ok) return {\n            ok: false,\n            error: res.error || \"Stage update failed\"\n        };\n        return {\n            ok: true,\n            deal: (_res_data = res.data) === null || _res_data === void 0 ? void 0 : _res_data.deal\n        };\n    }\n    // Mock fallback\n    await sleep();\n    if (options === null || options === void 0 ? void 0 : options.simulateError) {\n        return {\n            ok: false,\n            error: \"Simulated network/server error\"\n        };\n    }\n    const idx = mockDeals.findIndex((d)=>d.id === dealId);\n    if (idx === -1) {\n        return {\n            ok: false,\n            error: \"Deal not found\"\n        };\n    }\n    const prev = mockDeals[idx];\n    const next = {\n        ...prev,\n        stage_id: nextStageId\n    };\n    mockDeals[idx] = next;\n    mockActivities.push({\n        id: \"a_\".concat(Date.now()),\n        type: \"system\",\n        related_type: \"deal\",\n        related_id: dealId,\n        content: \"Stage changed\",\n        meta_json: {\n            from: prev.stage_id,\n            to: nextStageId,\n            occurred_at: options === null || options === void 0 ? void 0 : options.occurredAtISO\n        },\n        created_at: new Date().toISOString()\n    });\n    return {\n        ok: true,\n        deal: next\n    };\n}\n/**\r\n * Reporting (MVP, mock)\r\n * - open deals count\r\n * - last 7 days reply count (email_in)\r\n * - simple pipeline conversion (stage-to-stage ratios within current mock snapshot)\r\n */ async function getOpenDealsCount(pipelineId) {\n    await sleep();\n    const list = pipelineId ? mockDeals.filter((d)=>d.pipeline_id === pipelineId) : mockDeals;\n    // Open = not Won and not Lost\n    return list.filter((d)=>d.stage_id !== \"s_won\" && d.stage_id !== \"s_lost\").length;\n}\nasync function getLast7DaysReplyCount() {\n    await sleep();\n    const now = Date.now();\n    const sevenDays = 7 * 24 * 60 * 60 * 1000;\n    return mockActivities.filter((a)=>a.type === \"email_in\" && now - +new Date(a.created_at) <= sevenDays).length;\n}\nasync function getPipelineConversion() {\n    let pipelineId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"p_default\";\n    await sleep();\n    const stages = mockStages.filter((s)=>s.pipeline_id === pipelineId).sort((a, b)=>a.order_index - b.order_index);\n    const byStageCount = {};\n    for (const s of stages)byStageCount[s.id] = 0;\n    for (const d of mockDeals){\n        if (d.pipeline_id !== pipelineId) continue;\n        if (byStageCount[d.stage_id] !== undefined) byStageCount[d.stage_id] += 1;\n    }\n    const result = stages.map((s, idx)=>{\n        const count = byStageCount[s.id] || 0;\n        let conversion = undefined;\n        if (idx < stages.length - 1) {\n            const nextStage = stages[idx + 1];\n            const nextCount = byStageCount[nextStage.id] || 0;\n            // naive ratio using snapshot counts (not cohort-based)\n            conversion = count > 0 ? Math.round(nextCount / count * 100) : undefined;\n        }\n        return {\n            stage_id: s.id,\n            stage_name: s.name,\n            count,\n            conversion_to_next: conversion\n        };\n    });\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9jcm1BcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FzQ0QsTUFBTUEsYUFBYTtBQUVuQixTQUFTQztRQUFNQyxLQUFBQSxpRUFBS0Y7SUFDbEIsT0FBTyxJQUFJRyxRQUFRLENBQUNDLE1BQVFDLFdBQVdELEtBQUtGO0FBQzlDO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTSTtRQUUrQkM7SUFEdEMsK0NBQStDO0lBQy9DLElBQUksT0FBT0EsT0FBT0EsS0FBSyxpQkFBZUEsZUFBQUEsUUFBUUMsR0FBRyxjQUFYRCxtQ0FBQUEsYUFBYUUsd0JBQXdCLEdBQUU7UUFDM0UsT0FBT0YsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx3QkFBd0I7SUFDN0M7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxlQUFlQztJQUNiLDBGQUEwRjtJQUMxRixPQUFPO0FBQ1Q7QUFTQSxlQUFlQyxXQUFvQkMsSUFBWTtRQUFFQyxPQUFBQSxpRUFBdUIsQ0FBQztJQUN2RSxNQUFNQyxPQUFPUjtJQUNiLElBQUksQ0FBQ1EsTUFBTTtRQUNULDJEQUEyRDtRQUMzRCxPQUFPO1lBQUVDLElBQUk7WUFBT0MsUUFBUTtZQUFHQyxPQUFPO1FBQWdEO0lBQ3hGO0lBQ0EsTUFBTUMsTUFBTU4sS0FBS08sVUFBVSxDQUFDLFVBQVVQLE9BQU8sR0FBK0JBLE9BQTVCRSxLQUFLTSxPQUFPLENBQUMsUUFBUSxLQUFJLEtBQTRCLE9BQXpCUixLQUFLUSxPQUFPLENBQUMsUUFBUTtJQUNqRyxNQUFNQyxRQUFRLE1BQU1YO0lBQ3BCLE1BQU1ZLFVBQWtDO1FBQ3RDLGdCQUFnQjtRQUNoQixHQUFJVCxLQUFLUyxPQUFPLElBQUksQ0FBQyxDQUFDO0lBQ3hCO0lBQ0EsSUFBSUQsT0FBT0MsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5EO0lBQ2hELElBQUlSLEtBQUtVLGNBQWMsRUFBRUQsT0FBTyxD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QyxLQUFLLE1BQU1oRSxLQUFLMkIsT0FBUXFDLFlBQVksQ0FBQ2hFLEVBQUVwQyxFQUFFLENBQUMsR0FBRztJQUM3QyxLQUFLLE1BQU15QyxLQUFLcEMsVUFBVztRQUN6QixJQUFJb0MsRUFBRXJDLFdBQVcsS0FBSzhCLFlBQVk7UUFDbEMsSUFBSWtFLFlBQVksQ0FBQzNELEVBQUVsQyxRQUFRLENBQUMsS0FBS2IsV0FBVzBHLFlBQVksQ0FBQzNELEVBQUVsQyxRQUFRLENBQUMsSUFBSTtJQUMxRTtJQUVBLE1BQU04RixTQUErQnRDLE9BQU91QyxHQUFHLENBQUMsQ0FBQ2xFLEdBQUc2QztRQUNsRCxNQUFNc0IsUUFBUUgsWUFBWSxDQUFDaEUsRUFBRXBDLEVBQUUsQ0FBQyxJQUFJO1FBQ3BDLElBQUl3RyxhQUFpQzlHO1FBQ3JDLElBQUl1RixNQUFNbEIsT0FBT0ssTUFBTSxHQUFHLEdBQUc7WUFDM0IsTUFBTXFDLFlBQVkxQyxNQUFNLENBQUNrQixNQUFNLEVBQUU7WUFDakMsTUFBTXlCLFlBQVlOLFlBQVksQ0FBQ0ssVUFBVXpHLEVBQUUsQ0FBQyxJQUFJO1lBQ2hELHVEQUF1RDtZQUN2RHdHLGFBQWFELFFBQVEsSUFBSUksS0FBS0MsS0FBSyxDQUFDLFlBQWFMLFFBQVMsT0FBTzdHO1FBQ25FO1FBQ0EsT0FBTztZQUFFYSxVQUFVNkIsRUFBRXBDLEVBQUU7WUFBRTZHLFlBQVl6RSxFQUFFbkMsSUFBSTtZQUFFc0c7WUFBT08sb0JBQW9CTjtRQUFXO0lBQ3JGO0lBRUEsT0FBT0g7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc2VydmljZXMvY3JtQXBpLnRzPzgxZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJlYWQtb25seSBDUk0gQVBJIGhlbHBlcnMgKE1WUCBza2VsZXRvbikuXHJcbiAqIEltcGxlbWVudGF0aW9uIG5vdGU6XHJcbiAqIC0gU3RhcnQgd2l0aCBtb2NrL3BsYWNlaG9sZGVyIGltcGxlbWVudGF0aW9ucy5cclxuICogLSBSZXBsYWNlIHdpdGggU3VwYWJhc2UgY2xpZW50IG9yIGJhY2tlbmQgcHJveHkgb25jZSBhdXRoL1JMUyBzdHJhdGVneSBpcyBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHR5cGUgU3RhZ2UgPSB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgb3JkZXJfaW5kZXg6IG51bWJlcjsgcGlwZWxpbmVfaWQ/OiBzdHJpbmc7IHByb2JhYmlsaXR5PzogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIERlYWwgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGNvbXBhbnlfaWQ/OiBzdHJpbmc7XHJcbiAgY29udGFjdF9pZD86IHN0cmluZztcclxuICBwaXBlbGluZV9pZDogc3RyaW5nO1xyXG4gIHN0YWdlX2lkOiBzdHJpbmc7XHJcbiAgYW1vdW50PzogbnVtYmVyO1xyXG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xyXG4gIGNsb3NlX2RhdGU/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIHNvdXJjZT86IHN0cmluZztcclxuICBub3Rlcz86IHN0cmluZztcclxuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xyXG59O1xyXG5leHBvcnQgdHlwZSBBY3Rpdml0eSA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHR5cGU6ICdlbWFpbF9pbicgfCAnZW1haWxfb3V0JyB8ICdjYWxsJyB8ICdtZWV0aW5nJyB8ICd0YXNrJyB8ICdub3RlJyB8ICdzeXN0ZW0nO1xyXG4gIHJlbGF0ZWRfdHlwZTogJ2RlYWwnIHwgJ2NvbnRhY3QnIHwgJ2NvbXBhbnknO1xyXG4gIHJlbGF0ZWRfaWQ6IHN0cmluZztcclxuICBjb250ZW50Pzogc3RyaW5nO1xyXG4gIG1ldGFfanNvbj86IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5leHBvcnQgdHlwZSBDb250YWN0ID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgZnVsbF9uYW1lPzogc3RyaW5nO1xyXG4gIGVtYWlsPzogc3RyaW5nO1xyXG4gIHRpdGxlPzogc3RyaW5nO1xyXG4gIGxpbmtlZGluX3VybD86IHN0cmluZztcclxuICB3ZWJzaXRlPzogc3RyaW5nO1xyXG4gIHJlcGx5X3N0YXR1cz86ICdpbnRlcmVzdGVkJyB8ICdub3RfaW50ZXJlc3RlZCcgfCAncXVlc3Rpb24nIHwgc3RyaW5nO1xyXG4gIHJlcGx5X3N1bW1hcnk/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5jb25zdCBNT0NLX0RFTEFZID0gMTUwO1xyXG5cclxuZnVuY3Rpb24gc2xlZXAobXMgPSBNT0NLX0RFTEFZKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xyXG59XHJcblxyXG4vKipcclxuICogRWRnZSBBY3Rpb25zIEhUVFAgaGVscGVycyAoTVZQKVxyXG4gKiBTd2l0Y2hhYmxlIHZpYSBORVhUX1BVQkxJQ19DUk1fQVBJX0JBU0U6XHJcbiAqIC0gSWYgZGVmaW5lZDogcmVhbCBFZGdlIGVuZHBvaW50IGNhbGxzXHJcbiAqIC0gSWYgbm90IGRlZmluZWQ6IGZhbGxiYWNrIHRvIG1vY2sgaW4tbWVtb3J5IGJlaGF2aW9yXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcGlCYXNlKCk6IHN0cmluZyB8IG51bGwge1xyXG4gIC8vIGUuZy4gaHR0cDovL2xvY2FsaG9zdDo4MDAwIG9yIC8gKGlmIHByb3hpZWQpXHJcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudj8uTkVYVF9QVUJMSUNfQ1JNX0FQSV9CQVNFKSB7XHJcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ1JNX0FQSV9CQVNFITtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEF1dGhUb2tlbigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAvLyBUT0RPOiBpbnRlZ3JhdGUgd2l0aCBTdXBhYmFzZS9OZXh0QXV0aC4gRm9yIG5vdywgcmV0dXJuIG51bGwgKG5vIEF1dGhvcml6YXRpb24gaGVhZGVyKS5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudHlwZSBSZXF1ZXN0T3B0aW9ucyA9IHtcclxuICBtZXRob2Q/OiAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ1BBVENIJyB8ICdERUxFVEUnO1xyXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG4gIGJvZHk/OiBhbnk7XHJcbiAgaWRlbXBvdGVuY3lLZXk/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5hc3luYyBmdW5jdGlvbiBhcGlSZXF1ZXN0PFQgPSBhbnk+KHBhdGg6IHN0cmluZywgb3B0czogUmVxdWVzdE9wdGlvbnMgPSB7fSk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgc3RhdHVzOiBudW1iZXI7IGRhdGE/OiBUOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgY29uc3QgYmFzZSA9IGdldEFwaUJhc2UoKTtcclxuICBpZiAoIWJhc2UpIHtcclxuICAgIC8vIG5vIGJhc2UgY29uZmlndXJlZCDihpIgZmFsbGJhY2sgaW5mb3JtIGNhbGxlciB0byB1c2UgbW9ja3NcclxuICAgIHJldHVybiB7IG9rOiBmYWxzZSwgc3RhdHVzOiAwLCBlcnJvcjogJ0FQSSBiYXNlIG5vdCBjb25maWd1cmVkICh1c2luZyBtb2NrIGZhbGxiYWNrKScgfTtcclxuICB9XHJcbiAgY29uc3QgdXJsID0gcGF0aC5zdGFydHNXaXRoKCdodHRwJykgPyBwYXRoIDogYCR7YmFzZS5yZXBsYWNlKC9cXC8rJC8sICcnKX0vJHtwYXRoLnJlcGxhY2UoL15cXC8rLywgJycpfWA7XHJcbiAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRBdXRoVG9rZW4oKTtcclxuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIC4uLihvcHRzLmhlYWRlcnMgfHwge30pLFxyXG4gIH07XHJcbiAgaWYgKHRva2VuKSBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICBpZiAob3B0cy5pZGVtcG90ZW5jeUtleSkgaGVhZGVyc1snSWRlbXBvdGVuY3ktS2V5J10gPSBvcHRzLmlkZW1wb3RlbmN5S2V5O1xyXG5cclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgJ1BPU1QnLFxyXG4gICAgaGVhZGVycyxcclxuICAgIGJvZHk6IHR5cGVvZiBvcHRzLmJvZHkgIT09ICd1bmRlZmluZWQnID8gSlNPTi5zdHJpbmdpZnkob3B0cy5ib2R5KSA6IHVuZGVmaW5lZCxcclxuICB9KTtcclxuXHJcbiAgbGV0IHBheWxvYWQ6IGFueSA9IHVuZGVmaW5lZDtcclxuICB0cnkge1xyXG4gICAgcGF5bG9hZCA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBpZ25vcmUgYm9keSBwYXJzZSBlcnJvcnNcclxuICB9XHJcbiAgaWYgKCFyZXMub2spIHtcclxuICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBwYXlsb2FkPy5lcnJvciA9PT0gJ3N0cmluZycgPyBwYXlsb2FkLmVycm9yIDogYEhUVFAgJHtyZXMuc3RhdHVzfWA7XHJcbiAgICByZXR1cm4geyBvazogZmFsc2UsIHN0YXR1czogcmVzLnN0YXR1cywgZXJyb3I6IG1zZyB9O1xyXG4gIH1cclxuICByZXR1cm4geyBvazogdHJ1ZSwgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiBwYXlsb2FkIH07XHJcbn1cclxuXHJcbi8vIEluLW1lbW9yeSBtb2NrXHJcbmNvbnN0IG1vY2tTdGFnZXM6IFN0YWdlW10gPSBbXHJcbiAgeyBpZDogJ3NfbmV3JywgbmFtZTogJ05ldycsIG9yZGVyX2luZGV4OiAwLCBwcm9iYWJpbGl0eTogMC4wNSwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbiAgeyBpZDogJ3NfY29udGFjdGVkJywgbmFtZTogJ0NvbnRhY3RlZCcsIG9yZGVyX2luZGV4OiAxLCBwcm9iYWJpbGl0eTogMC4xNSwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbiAgeyBpZDogJ3NfcXVhbGlmaWVkJywgbmFtZTogJ1F1YWxpZmllZCcsIG9yZGVyX2luZGV4OiAyLCBwcm9iYWJpbGl0eTogMC4zNSwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbiAgeyBpZDogJ3NfbWVldGluZycsIG5hbWU6ICdNZWV0aW5nIFNjaGVkdWxlZCcsIG9yZGVyX2luZGV4OiAzLCBwcm9iYWJpbGl0eTogMC41LCBwaXBlbGluZV9pZDogJ3BfZGVmYXVsdCcgfSxcclxuICB7IGlkOiAnc19wcm9wb3NhbCcsIG5hbWU6ICdQcm9wb3NhbCBTZW50Jywgb3JkZXJfaW5kZXg6IDQsIHByb2JhYmlsaXR5OiAwLjcsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0JyB9LFxyXG4gIHsgaWQ6ICdzX3dvbicsIG5hbWU6ICdXb24nLCBvcmRlcl9pbmRleDogNSwgcHJvYmFiaWxpdHk6IDEuMCwgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnIH0sXHJcbiAgeyBpZDogJ3NfbG9zdCcsIG5hbWU6ICdMb3N0Jywgb3JkZXJfaW5kZXg6IDYsIHByb2JhYmlsaXR5OiAwLCBwaXBlbGluZV9pZDogJ3BfZGVmYXVsdCcgfSxcclxuXTtcclxuXHJcbmNvbnN0IG1vY2tEZWFsczogRGVhbFtdID0gW1xyXG4gIHsgaWQ6ICdkMScsIHRpdGxlOiAnQWNtZSAtIFBpbG90JywgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnLCBzdGFnZV9pZDogJ3NfbmV3JywgYW1vdW50OiAyNTAwLCBjdXJyZW5jeTogJ1VTRCcsIHNvdXJjZTogJ291dGJvdW5kJyB9LFxyXG4gIHsgaWQ6ICdkMicsIHRpdGxlOiAnR2xvYmV4IC0gRGlzY292ZXJ5JywgcGlwZWxpbmVfaWQ6ICdwX2RlZmF1bHQnLCBzdGFnZV9pZDogJ3NfY29udGFjdGVkJywgYW1vdW50OiA1MDAwLCBjdXJyZW5jeTogJ1VTRCcsIHNvdXJjZTogJ3JlcGx5JyB9LFxyXG4gIHsgaWQ6ICdkMycsIHRpdGxlOiAnSW5pdGVjaCAtIEV4cGFuc2lvbicsIHBpcGVsaW5lX2lkOiAncF9kZWZhdWx0Jywgc3RhZ2VfaWQ6ICdzX21lZXRpbmcnLCBhbW91bnQ6IDEyMDAwLCBjdXJyZW5jeTogJ1VTRCcsIHNvdXJjZTogJ2Jvb2tpbmcnIH0sXHJcbl07XHJcblxyXG5jb25zdCBtb2NrQ29udGFjdHM6IFJlY29yZDxzdHJpbmcsIENvbnRhY3Q+ID0ge1xyXG4gIGMxOiB7IGlkOiAnYzEnLCBmdWxsX25hbWU6ICdKb2huIERvZScsIGVtYWlsOiAnam9obkBhY21lLmNvbScsIHRpdGxlOiAnVlAgU2FsZXMnLCBsaW5rZWRpbl91cmw6ICdodHRwczovL2xpbmtlZGluLmNvbS9pbi9qb2huJywgd2Vic2l0ZTogJ2h0dHBzOi8vYWNtZS5jb20nIH0sXHJcbiAgYzI6IHsgaWQ6ICdjMicsIGZ1bGxfbmFtZTogJ01pa2UgTmVvJywgZW1haWw6ICdtaWtlQGdsb2JleC5jb20nLCB0aXRsZTogJ0hlYWQgb2YgT3BzJywgbGlua2VkaW5fdXJsOiAnaHR0cHM6Ly9saW5rZWRpbi5jb20vaW4vbWlrZScsIHdlYnNpdGU6ICdodHRwczovL2dsb2JleC5leGFtcGxlJywgcmVwbHlfc3RhdHVzOiAncXVlc3Rpb24nLCByZXBseV9zdW1tYXJ5OiAnQXNrZWQgYWJvdXQgcHJpY2luZycgfSxcclxufTtcclxuXHJcbmNvbnN0IG1vY2tBY3Rpdml0aWVzOiBBY3Rpdml0eVtdID0gW1xyXG4gIHsgaWQ6ICdhMScsIHR5cGU6ICdlbWFpbF9pbicsIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLCByZWxhdGVkX2lkOiAnZDInLCBjb250ZW50OiAncHJpY2luZyBkZXRhaWxzPycsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSB9LFxyXG4gIHsgaWQ6ICdhMicsIHR5cGU6ICdtZWV0aW5nJywgcmVsYXRlZF90eXBlOiAnZGVhbCcsIHJlbGF0ZWRfaWQ6ICdkMycsIGNvbnRlbnQ6ICdEaXNjb3ZlcnkgQ2FsbCBzY2hlZHVsZWQnLCBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzYwMDAwMCkudG9JU09TdHJpbmcoKSB9LFxyXG4gIHsgaWQ6ICdhMycsIHR5cGU6ICdzeXN0ZW0nLCByZWxhdGVkX3R5cGU6ICdkZWFsJywgcmVsYXRlZF9pZDogJ2QxJywgY29udGVudDogJ0RlYWwgY3JlYXRlZCcsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxODAwMDAwKS50b0lTT1N0cmluZygpIH0sXHJcbl07XHJcblxyXG4vLyBNYXAgb25lIGNvbnRhY3QgdG8gZGVhbHMgZm9yIGRlbW9cclxuY29uc3QgZGVhbFRvQ29udGFjdDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICBkMTogJ2MxJyxcclxuICBkMjogJ2MyJyxcclxuICBkMzogJ2MyJyxcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQaXBlbGluZVN0YWdlcyhwaXBlbGluZUlkOiBzdHJpbmcpOiBQcm9taXNlPFN0YWdlW10+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGZyb20gcGlwZWxpbmVfc3RhZ2VzIHdoZXJlIHBpcGVsaW5lX2lkID0gcGlwZWxpbmVJZCBvcmRlciBieSBvcmRlcl9pbmRleFxyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgcmV0dXJuIG1vY2tTdGFnZXMuZmlsdGVyKChzKSA9PiBzLnBpcGVsaW5lX2lkID09PSBwaXBlbGluZUlkKS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsc0J5UGlwZWxpbmUocGlwZWxpbmVJZDogc3RyaW5nKTogUHJvbWlzZTxEZWFsW10+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGZyb20gZGVhbHMgd2hlcmUgcGlwZWxpbmVfaWQgPSBwaXBlbGluZUlkXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICByZXR1cm4gbW9ja0RlYWxzLmZpbHRlcigoZCkgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsRGV0YWlsKGlkOiBzdHJpbmcpOiBQcm9taXNlPERlYWw+IHtcclxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggU3VwYWJhc2Ugc2VsZWN0IGRlYWxzIGJ5IGlkXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBkZWFsID0gbW9ja0RlYWxzLmZpbmQoKGQpID0+IGQuaWQgPT09IGlkKTtcclxuICBpZiAoIWRlYWwpIHRocm93IG5ldyBFcnJvcignRGVhbCBub3QgZm91bmQnKTtcclxuICByZXR1cm4gZGVhbDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2aXRpZXNGb3IocmVsYXRlZFR5cGU6ICdkZWFsJ3wnY29udGFjdCd8J2NvbXBhbnknLCByZWxhdGVkSWQ6IHN0cmluZyk6IFByb21pc2U8QWN0aXZpdHlbXT4ge1xyXG4gIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBTdXBhYmFzZSBzZWxlY3QgYWN0aXZpdGllcyB3aGVyZSByZWxhdGVkX3R5cGUgPSByZWxhdGVkVHlwZSBhbmQgcmVsYXRlZF9pZCA9IHJlbGF0ZWRJZCBvcmRlciBieSBjcmVhdGVkX2F0IGRlc2NcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIHJldHVybiBtb2NrQWN0aXZpdGllcy5maWx0ZXIoKGEpID0+IGEucmVsYXRlZF90eXBlID09PSByZWxhdGVkVHlwZSAmJiBhLnJlbGF0ZWRfaWQgPT09IHJlbGF0ZWRJZClcclxuICAgIC5zb3J0KChhLCBiKSA9PiArbmV3IERhdGUoYi5jcmVhdGVkX2F0KSAtICtuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnRhY3QoaWQ6IHN0cmluZyk6IFByb21pc2U8Q29udGFjdD4ge1xyXG4gIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBTdXBhYmFzZSBzZWxlY3QgY29udGFjdHMgYnkgaWRcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGNvbnN0IGMgPSBtb2NrQ29udGFjdHNbaWRdO1xyXG4gIGlmICghYykgdGhyb3cgbmV3IEVycm9yKCdDb250YWN0IG5vdCBmb3VuZCcpO1xyXG4gIHJldHVybiBjO1xyXG59XHJcblxyXG4vKipcclxuICogU3ByaW50IDIg4oCUIENvbnRhY3RRdWljayBhY3Rpb25zOiBpbnRlcmVzdGVkIC8gbm90X2ludGVyZXN0ZWQgdG9nZ2xlXHJcbiAqIEdlcsOnZWsgZW50ZWdyYXN5b25kYSBQT1NUIC9jcm0vYWN0aW9ucy9jb250YWN0cyDDp2HEn3LEsXPEsW5hIGTDtm7DvMWfZWNla3Rpci5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVDb250YWN0U3RhdHVzKFxyXG4gIGNvbnRhY3RJZDogc3RyaW5nLFxyXG4gIHN0YXR1czogJ2ludGVyZXN0ZWQnIHwgJ25vdF9pbnRlcmVzdGVkJ1xyXG4pOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyBjb250YWN0PzogQ29udGFjdCB9PiB7XHJcbiAgY29uc3QgYmFzZSA9IGdldEFwaUJhc2UoKTtcclxuICBpZiAoYmFzZSkge1xyXG4gICAgLy8gUmVhbCBFZGdlIGNhbGxcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaVJlcXVlc3Q8eyBjb250YWN0OiBDb250YWN0IH0+KCdjcm0vYWN0aW9ucy9jb250YWN0cycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IHsgaWQ6IGNvbnRhY3RJZCwgcmVwbHlfc3RhdHVzOiBzdGF0dXMgfSxcclxuICAgICAgaWRlbXBvdGVuY3lLZXk6IGBjb250YWN0LXN0YXR1czoke2NvbnRhY3RJZH06JHtzdGF0dXN9OiR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiByZXMuZXJyb3IgfHwgJ0NvbnRhY3QgdXBkYXRlIGZhaWxlZCcgfTtcclxuICAgIHJldHVybiB7IG9rOiB0cnVlLCBjb250YWN0OiAocmVzLmRhdGEgYXMgYW55KT8uY29udGFjdCB9O1xyXG4gIH1cclxuXHJcbiAgLy8gTW9jayBmYWxsYmFja1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgYyA9IG1vY2tDb250YWN0c1tjb250YWN0SWRdO1xyXG4gIGlmICghYykgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0NvbnRhY3Qgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0geyAuLi5jIH07XHJcbiAgYy5yZXBseV9zdGF0dXMgPSBzdGF0dXM7XHJcblxyXG4gIG1vY2tBY3Rpdml0aWVzLnB1c2goe1xyXG4gICAgaWQ6IGBhXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgdHlwZTogJ3N5c3RlbScsXHJcbiAgICByZWxhdGVkX3R5cGU6ICdjb250YWN0JyxcclxuICAgIHJlbGF0ZWRfaWQ6IGNvbnRhY3RJZCxcclxuICAgIGNvbnRlbnQ6ICdDb250YWN0IHN0YXR1cyBjaGFuZ2VkJyxcclxuICAgIG1ldGFfanNvbjogeyBmcm9tOiBwcmV2LnJlcGx5X3N0YXR1cywgdG86IHN0YXR1cyB9LFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4geyBvazogdHJ1ZSwgY29udGFjdDogYyB9O1xyXG59XHJcblxyXG4vKipcclxuICogU3ByaW50IDIg4oCUIENvbnRhY3RRdWljayBhY3Rpb25zOiBzZW5kIGNhbGVuZGFyIGxpbmsgKHBsYWNlaG9sZGVyKVxyXG4gKiBTMjogeWFsbsSxemNhIGxpbmsgw7xyZXRpcCBkw7ZuZMO8csO8cjsgUzM6IGdlcsOnZWsgZS1wb3N0YS9tZXNhaiBvdG9tYXN5b251LlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhbGVuZGFyTGluayhjb250YWN0SWQ6IHN0cmluZyk6IFByb21pc2U8eyBvazogYm9vbGVhbjsgdXJsOiBzdHJpbmcgfT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgYmFzZSA9ICdodHRwczovL2NhbC5jb20veW91ci10ZWFtLzMwbWluJztcclxuICAvLyBiYXNpdMOnZSBracWfaSBlLXBvc3Rhc8SxbsSxIHF1ZXJ5IG9sYXJhayBpbGnFn3RpclxyXG4gIGNvbnN0IGVtYWlsID0gbW9ja0NvbnRhY3RzW2NvbnRhY3RJZF0/LmVtYWlsIHx8ICdwcm9zcGVjdEBleGFtcGxlLmNvbSc7XHJcbiAgY29uc3QgdXJsID0gYCR7YmFzZX0/ZW1haWw9JHtlbmNvZGVVUklDb21wb25lbnQoZW1haWwpfWA7XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIHVybCB9O1xyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gY29tcHV0ZSBzdGFnZSBuYW1lIGZvciBhIGdpdmVuIHN0YWdlX2lkICh1c2VmdWwgZm9yIFVJKVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhZ2VOYW1lKHBpcGVsaW5lSWQ6IHN0cmluZywgc3RhZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcclxuICBjb25zdCBzdGFnZXMgPSBhd2FpdCBnZXRQaXBlbGluZVN0YWdlcyhwaXBlbGluZUlkKTtcclxuICByZXR1cm4gc3RhZ2VzLmZpbmQoKHMpID0+IHMuaWQgPT09IHN0YWdlSWQpPy5uYW1lO1xyXG59XHJcblxyXG4vLyBEZW1vLW9ubHkgaGVscGVycyB0byBicmlkZ2UgbW9jayByZWxhdGlvbnNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnRhY3RGb3JEZWFsKGRlYWxJZDogc3RyaW5nKTogUHJvbWlzZTxDb250YWN0IHwgdW5kZWZpbmVkPiB7XHJcbiAgY29uc3QgY29udGFjdElkID0gZGVhbFRvQ29udGFjdFtkZWFsSWRdO1xyXG4gIGlmICghY29udGFjdElkKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIHJldHVybiBnZXRDb250YWN0KGNvbnRhY3RJZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBvcnRpbmcgaGVscGVycyAoU25hcHNob3QgTVZQKVxyXG4gKiBOb3RlOiBNb2NrIGltcGxlbWVudGF0aW9uIHVzaW5nIGluLW1lbW9yeSBkYXRhOyByZXBsYWNlIHdpdGggU3VwYWJhc2UvRWRnZSBxdWVyaWVzIGxhdGVyLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlcGxpZXNMYXN0N2QoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGNvbnN0IHNpbmNlID0gRGF0ZS5ub3coKSAtIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG4gIHJldHVybiBtb2NrQWN0aXZpdGllcy5maWx0ZXIoKGEpID0+IGEudHlwZSA9PT0gJ2VtYWlsX2luJyAmJiArbmV3IERhdGUoYS5jcmVhdGVkX2F0KSA+PSBzaW5jZSkubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhZ2VEaXN0cmlidXRpb24ocGlwZWxpbmVJZDogc3RyaW5nKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBkaXN0OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgZm9yIChjb25zdCBkIG9mIG1vY2tEZWFscykge1xyXG4gICAgaWYgKGQucGlwZWxpbmVfaWQgIT09IHBpcGVsaW5lSWQpIGNvbnRpbnVlO1xyXG4gICAgZGlzdFtkLnN0YWdlX2lkXSA9IChkaXN0W2Quc3RhZ2VfaWRdIHx8IDApICsgMTtcclxuICB9XHJcbiAgcmV0dXJuIGRpc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTaW1wbGVDb252ZXJzaW9uKHBpcGVsaW5lSWQ6IHN0cmluZyk6IFByb21pc2U8eyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IHJhdGU6IG51bWJlciB8IG51bGwgfT4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgLy8gQmFzaXQgYmlyIG9yYW46IE5ldyAtPiBRdWFsaWZpZWRcclxuICBjb25zdCBmcm9tID0gJ3NfbmV3JztcclxuICBjb25zdCB0byA9ICdzX3F1YWxpZmllZCc7XHJcbiAgY29uc3QgaW5Gcm9tID0gbW9ja0RlYWxzLmZpbHRlcigoZCkgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCAmJiBkLnN0YWdlX2lkID09PSBmcm9tKS5sZW5ndGg7XHJcbiAgY29uc3QgaW5UbyA9IG1vY2tEZWFscy5maWx0ZXIoKGQpID0+IGQucGlwZWxpbmVfaWQgPT09IHBpcGVsaW5lSWQgJiYgZC5zdGFnZV9pZCA9PT0gdG8pLmxlbmd0aDtcclxuICBjb25zdCByYXRlID0gaW5Gcm9tID4gMCA/IE51bWJlcigoKGluVG8gLyBpbkZyb20pICogMTAwKS50b0ZpeGVkKDApKSA6IG51bGw7XHJcbiAgcmV0dXJuIHsgZnJvbSwgdG8sIHJhdGUgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwcmludCAyIOKAlCBEZWFsRGV0YWlsIGlubGluZSBlZGl0IG1vY2sgaGVscGVyLlxyXG4gKiBHZXLDp2VrIGVudGVncmFzeW9uZGEgUE9TVCAvY3JtL2FjdGlvbnMvZGVhbHMgw6dhxJ9yxLFzxLFuYSBkw7Zuw7zFn2VjZWt0aXIuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBEZWFsVXBkYXRlSW5wdXQgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZT86IHN0cmluZztcclxuICBhbW91bnQ/OiBudW1iZXI7XHJcbiAgY3VycmVuY3k/OiBzdHJpbmc7XHJcbiAgY2xvc2VfZGF0ZT86IHN0cmluZzsgLy8gSVNPXHJcbiAgc3RhZ2VfaWQ/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVhbChcclxuICBpbnB1dDogRGVhbFVwZGF0ZUlucHV0LFxyXG4gIG9wdGlvbnM/OiB7IHNpbXVsYXRlRXJyb3I/OiBib29sZWFuIH1cclxuKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgZGVhbD86IERlYWwgfT4ge1xyXG4gIGNvbnN0IGJhc2UgPSBnZXRBcGlCYXNlKCk7XHJcbiAgaWYgKGJhc2UpIHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaVJlcXVlc3Q8eyBkZWFsOiBEZWFsIH0+KCdjcm0vYWN0aW9ucy9kZWFscycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IGlucHV0LFxyXG4gICAgICBpZGVtcG90ZW5jeUtleTogYGRlYWw6JHtpbnB1dC5pZH06JHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXMub2spIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IHJlcy5lcnJvciB8fCAnRGVhbCB1cGRhdGUgZmFpbGVkJyB9O1xyXG4gICAgcmV0dXJuIHsgb2s6IHRydWUsIGRlYWw6IChyZXMuZGF0YSBhcyBhbnkpPy5kZWFsIH07XHJcbiAgfVxyXG5cclxuICAvLyBNb2NrIGZhbGxiYWNrXHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBpZiAob3B0aW9ucz8uc2ltdWxhdGVFcnJvcikgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ1NpbXVsYXRlZCB1cGRhdGUgZXJyb3InIH07XHJcblxyXG4gIGNvbnN0IGlkeCA9IG1vY2tEZWFscy5maW5kSW5kZXgoKGQpID0+IGQuaWQgPT09IGlucHV0LmlkKTtcclxuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0RlYWwgbm90IGZvdW5kJyB9O1xyXG5cclxuICBjb25zdCBwcmV2ID0gbW9ja0RlYWxzW2lkeF07XHJcbiAgaWYgKHR5cGVvZiBpbnB1dC5hbW91bnQgIT09ICd1bmRlZmluZWQnICYmIE51bWJlci5pc05hTihOdW1iZXIoaW5wdXQuYW1vdW50KSkpIHtcclxuICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdBbW91bnQgbXVzdCBiZSBudW1lcmljJyB9O1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGlucHV0LmNsb3NlX2RhdGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zdCB0ID0gRGF0ZS5wYXJzZShpbnB1dC5jbG9zZV9kYXRlKTtcclxuICAgIGlmIChOdW1iZXIuaXNOYU4odCkpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdjbG9zZV9kYXRlIG11c3QgYmUgSVNPIHN0cmluZycgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5leHQ6IERlYWwgPSB7XHJcbiAgICAuLi5wcmV2LFxyXG4gICAgdGl0bGU6IGlucHV0LnRpdGxlID8/IHByZXYudGl0bGUsXHJcbiAgICBhbW91bnQ6IHR5cGVvZiBpbnB1dC5hbW91bnQgIT09ICd1bmRlZmluZWQnID8gTnVtYmVyKGlucHV0LmFtb3VudCkgOiBwcmV2LmFtb3VudCxcclxuICAgIGN1cnJlbmN5OiBpbnB1dC5jdXJyZW5jeSA/PyBwcmV2LmN1cnJlbmN5LFxyXG4gICAgY2xvc2VfZGF0ZTogaW5wdXQuY2xvc2VfZGF0ZSA/PyBwcmV2LmNsb3NlX2RhdGUsXHJcbiAgICBzdGFnZV9pZDogaW5wdXQuc3RhZ2VfaWQgPz8gcHJldi5zdGFnZV9pZCxcclxuICB9O1xyXG4gIG1vY2tEZWFsc1tpZHhdID0gbmV4dDtcclxuXHJcbiAgY29uc3QgY2hhbmdlZDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xyXG4gIGZvciAoY29uc3QgayBvZiBbJ3RpdGxlJywgJ2Ftb3VudCcsICdjdXJyZW5jeScsICdjbG9zZV9kYXRlJywgJ3N0YWdlX2lkJ10gYXMgY29uc3QpIHtcclxuICAgIGlmICgocHJldiBhcyBhbnkpW2tdICE9PSAobmV4dCBhcyBhbnkpW2tdKSBjaGFuZ2VkW2tdID0geyBmcm9tOiAocHJldiBhcyBhbnkpW2tdLCB0bzogKG5leHQgYXMgYW55KVtrXSB9O1xyXG4gIH1cclxuICBtb2NrQWN0aXZpdGllcy5wdXNoKHtcclxuICAgIGlkOiBgYV8ke0RhdGUubm93KCl9YCxcclxuICAgIHR5cGU6ICdzeXN0ZW0nLFxyXG4gICAgcmVsYXRlZF90eXBlOiAnZGVhbCcsXHJcbiAgICByZWxhdGVkX2lkOiBpbnB1dC5pZCxcclxuICAgIGNvbnRlbnQ6ICdEZWFsIHVwZGF0ZWQnLFxyXG4gICAgbWV0YV9qc29uOiB7IGNoYW5nZWQgfSxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIGRlYWw6IG5leHQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwcmludCAyIC0gxLBsayBHw7ZyZXY6IEthbmJhbiBEcmFnICYgRHJvcCDihpIgU3RhZ2UgQ2hhbmdlXHJcbiAqIE1vY2sgb3J0YW1kYSBvcHRpbWlzdGljIFVJIGFrxLHFn8SxbsSxIGRvxJ9ydWxhbWFrIGnDp2luIHN0YWdlIGfDvG5jZWxsZW1lIGhlbHBlcifEsS5cclxuICogR2Vyw6dlayBlbnRlZ3Jhc3lvbmRhIGJ1IGZvbmtzaXlvbiwgRWRnZSBGdW5jdGlvbidhIChQT1NUIC9jcm0vYWN0aW9ucy9kZWFscy86aWQvc3RhZ2UpIMOnYcSfcsSxIHlhcGFjYWsuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGVhbFN0YWdlKFxyXG4gIGRlYWxJZDogc3RyaW5nLFxyXG4gIG5leHRTdGFnZUlkOiBzdHJpbmcsXHJcbiAgb3B0aW9ucz86IHsgb2NjdXJyZWRBdElTTz86IHN0cmluZzsgaWRlbXBvdGVuY3lLZXk/OiBzdHJpbmc7IHNpbXVsYXRlRXJyb3I/OiBib29sZWFuIH1cclxuKTogUHJvbWlzZTx7IG9rOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgZGVhbD86IERlYWwgfT4ge1xyXG4gIGNvbnN0IGJhc2UgPSBnZXRBcGlCYXNlKCk7XHJcbiAgaWYgKGJhc2UpIHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaVJlcXVlc3Q8eyBkZWFsOiBEZWFsIH0+KGBjcm0vYWN0aW9ucy9kZWFscy8ke2VuY29kZVVSSUNvbXBvbmVudChkZWFsSWQpfS9zdGFnZWAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IHsgbmV4dF9zdGFnZV9pZDogbmV4dFN0YWdlSWQsIG9jY3VycmVkX2F0OiBvcHRpb25zPy5vY2N1cnJlZEF0SVNPIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9LFxyXG4gICAgICBpZGVtcG90ZW5jeUtleTogb3B0aW9ucz8uaWRlbXBvdGVuY3lLZXkgfHwgYGRlYWwtc3RhZ2U6JHtkZWFsSWR9OiR7bmV4dFN0YWdlSWR9OiR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzLm9rKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiByZXMuZXJyb3IgfHwgJ1N0YWdlIHVwZGF0ZSBmYWlsZWQnIH07XHJcbiAgICByZXR1cm4geyBvazogdHJ1ZSwgZGVhbDogKHJlcy5kYXRhIGFzIGFueSk/LmRlYWwgfTtcclxuICB9XHJcblxyXG4gIC8vIE1vY2sgZmFsbGJhY2tcclxuICBhd2FpdCBzbGVlcCgpO1xyXG4gIGlmIChvcHRpb25zPy5zaW11bGF0ZUVycm9yKSB7XHJcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnU2ltdWxhdGVkIG5ldHdvcmsvc2VydmVyIGVycm9yJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaWR4ID0gbW9ja0RlYWxzLmZpbmRJbmRleCgoZCkgPT4gZC5pZCA9PT0gZGVhbElkKTtcclxuICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0RlYWwgbm90IGZvdW5kJyB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldiA9IG1vY2tEZWFsc1tpZHhdO1xyXG4gIGNvbnN0IG5leHQ6IERlYWwgPSB7IC4uLnByZXYsIHN0YWdlX2lkOiBuZXh0U3RhZ2VJZCB9O1xyXG4gIG1vY2tEZWFsc1tpZHhdID0gbmV4dDtcclxuXHJcbiAgbW9ja0FjdGl2aXRpZXMucHVzaCh7XHJcbiAgICBpZDogYGFfJHtEYXRlLm5vdygpfWAsXHJcbiAgICB0eXBlOiAnc3lzdGVtJyxcclxuICAgIHJlbGF0ZWRfdHlwZTogJ2RlYWwnLFxyXG4gICAgcmVsYXRlZF9pZDogZGVhbElkLFxyXG4gICAgY29udGVudDogJ1N0YWdlIGNoYW5nZWQnLFxyXG4gICAgbWV0YV9qc29uOiB7IGZyb206IHByZXYuc3RhZ2VfaWQsIHRvOiBuZXh0U3RhZ2VJZCwgb2NjdXJyZWRfYXQ6IG9wdGlvbnM/Lm9jY3VycmVkQXRJU08gfSxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHsgb2s6IHRydWUsIGRlYWw6IG5leHQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydGluZyAoTVZQLCBtb2NrKVxyXG4gKiAtIG9wZW4gZGVhbHMgY291bnRcclxuICogLSBsYXN0IDcgZGF5cyByZXBseSBjb3VudCAoZW1haWxfaW4pXHJcbiAqIC0gc2ltcGxlIHBpcGVsaW5lIGNvbnZlcnNpb24gKHN0YWdlLXRvLXN0YWdlIHJhdGlvcyB3aXRoaW4gY3VycmVudCBtb2NrIHNuYXBzaG90KVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9wZW5EZWFsc0NvdW50KHBpcGVsaW5lSWQ/OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3QgbGlzdCA9IHBpcGVsaW5lSWQgPyBtb2NrRGVhbHMuZmlsdGVyKGQgPT4gZC5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZCkgOiBtb2NrRGVhbHM7XHJcbiAgLy8gT3BlbiA9IG5vdCBXb24gYW5kIG5vdCBMb3N0XHJcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGQgPT4gZC5zdGFnZV9pZCAhPT0gJ3Nfd29uJyAmJiBkLnN0YWdlX2lkICE9PSAnc19sb3N0JykubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGFzdDdEYXlzUmVwbHlDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGF3YWl0IHNsZWVwKCk7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCBzZXZlbkRheXMgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuICByZXR1cm4gbW9ja0FjdGl2aXRpZXMuZmlsdGVyKGEgPT5cclxuICAgIGEudHlwZSA9PT0gJ2VtYWlsX2luJyAmJiAobm93IC0gK25ldyBEYXRlKGEuY3JlYXRlZF9hdCkpIDw9IHNldmVuRGF5c1xyXG4gICkubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQaXBlbGluZUNvbnZlcnNpb24gPSB7XHJcbiAgc3RhZ2VfaWQ6IHN0cmluZztcclxuICBzdGFnZV9uYW1lOiBzdHJpbmc7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICBjb252ZXJzaW9uX3RvX25leHQ/OiBudW1iZXI7IC8vIHBlcmNlbnQgWzAuLjEwMF1cclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQaXBlbGluZUNvbnZlcnNpb24ocGlwZWxpbmVJZDogc3RyaW5nID0gJ3BfZGVmYXVsdCcpOiBQcm9taXNlPFBpcGVsaW5lQ29udmVyc2lvbltdPiB7XHJcbiAgYXdhaXQgc2xlZXAoKTtcclxuICBjb25zdCBzdGFnZXMgPSBtb2NrU3RhZ2VzXHJcbiAgICAuZmlsdGVyKHMgPT4gcy5waXBlbGluZV9pZCA9PT0gcGlwZWxpbmVJZClcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCk7XHJcblxyXG4gIGNvbnN0IGJ5U3RhZ2VDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gIGZvciAoY29uc3QgcyBvZiBzdGFnZXMpIGJ5U3RhZ2VDb3VudFtzLmlkXSA9IDA7XHJcbiAgZm9yIChjb25zdCBkIG9mIG1vY2tEZWFscykge1xyXG4gICAgaWYgKGQucGlwZWxpbmVfaWQgIT09IHBpcGVsaW5lSWQpIGNvbnRpbnVlO1xyXG4gICAgaWYgKGJ5U3RhZ2VDb3VudFtkLnN0YWdlX2lkXSAhPT0gdW5kZWZpbmVkKSBieVN0YWdlQ291bnRbZC5zdGFnZV9pZF0gKz0gMTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdDogUGlwZWxpbmVDb252ZXJzaW9uW10gPSBzdGFnZXMubWFwKChzLCBpZHgpID0+IHtcclxuICAgIGNvbnN0IGNvdW50ID0gYnlTdGFnZUNvdW50W3MuaWRdIHx8IDA7XHJcbiAgICBsZXQgY29udmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlkeCA8IHN0YWdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGNvbnN0IG5leHRTdGFnZSA9IHN0YWdlc1tpZHggKyAxXTtcclxuICAgICAgY29uc3QgbmV4dENvdW50ID0gYnlTdGFnZUNvdW50W25leHRTdGFnZS5pZF0gfHwgMDtcclxuICAgICAgLy8gbmFpdmUgcmF0aW8gdXNpbmcgc25hcHNob3QgY291bnRzIChub3QgY29ob3J0LWJhc2VkKVxyXG4gICAgICBjb252ZXJzaW9uID0gY291bnQgPiAwID8gTWF0aC5yb3VuZCgobmV4dENvdW50IC8gY291bnQpICogMTAwKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHN0YWdlX2lkOiBzLmlkLCBzdGFnZV9uYW1lOiBzLm5hbWUsIGNvdW50LCBjb252ZXJzaW9uX3RvX25leHQ6IGNvbnZlcnNpb24gfTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4iXSwibmFtZXMiOlsiTU9DS19ERUxBWSIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsImdldEFwaUJhc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ1JNX0FQSV9CQVNFIiwiZ2V0QXV0aFRva2VuIiwiYXBpUmVxdWVzdCIsInBhdGgiLCJvcHRzIiwiYmFzZSIsIm9rIiwic3RhdHVzIiwiZXJyb3IiLCJ1cmwiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsInRva2VuIiwiaGVhZGVycyIsImlkZW1wb3RlbmN5S2V5IiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsInBheWxvYWQiLCJqc29uIiwibXNnIiwiZGF0YSIsIm1vY2tTdGFnZXMiLCJpZCIsIm5hbWUiLCJvcmRlcl9pbmRleCIsInByb2JhYmlsaXR5IiwicGlwZWxpbmVfaWQiLCJtb2NrRGVhbHMiLCJ0aXRsZSIsInN0YWdlX2lkIiwiYW1vdW50IiwiY3VycmVuY3kiLCJzb3VyY2UiLCJtb2NrQ29udGFjdHMiLCJjMSIsImZ1bGxfbmFtZSIsImVtYWlsIiwibGlua2VkaW5fdXJsIiwid2Vic2l0ZSIsImMyIiwicmVwbHlfc3RhdHVzIiwicmVwbHlfc3VtbWFyeSIsIm1vY2tBY3Rpdml0aWVzIiwidHlwZSIsInJlbGF0ZWRfdHlwZSIsInJlbGF0ZWRfaWQiLCJjb250ZW50IiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsImRlYWxUb0NvbnRhY3QiLCJkMSIsImQyIiwiZDMiLCJnZXRQaXBlbGluZVN0YWdlcyIsInBpcGVsaW5lSWQiLCJmaWx0ZXIiLCJzIiwic29ydCIsImEiLCJiIiwiZ2V0RGVhbHNCeVBpcGVsaW5lIiwiZCIsImdldERlYWxEZXRhaWwiLCJkZWFsIiwiZmluZCIsIkVycm9yIiwiZ2V0QWN0aXZpdGllc0ZvciIsInJlbGF0ZWRUeXBlIiwicmVsYXRlZElkIiwiZ2V0Q29udGFjdCIsImMiLCJ1cGRhdGVDb250YWN0U3RhdHVzIiwiY29udGFjdElkIiwiY29udGFjdCIsInByZXYiLCJwdXNoIiwibWV0YV9qc29uIiwiZnJvbSIsInRvIiwiZ2V0Q2FsZW5kYXJMaW5rIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0U3RhZ2VOYW1lIiwic3RhZ2VJZCIsInN0YWdlcyIsImdldENvbnRhY3RGb3JEZWFsIiwiZGVhbElkIiwiZ2V0UmVwbGllc0xhc3Q3ZCIsInNpbmNlIiwibGVuZ3RoIiwiZ2V0U3RhZ2VEaXN0cmlidXRpb24iLCJkaXN0IiwiZ2V0U2ltcGxlQ29udmVyc2lvbiIsImluRnJvbSIsImluVG8iLCJyYXRlIiwiTnVtYmVyIiwidG9GaXhlZCIsInVwZGF0ZURlYWwiLCJpbnB1dCIsIm9wdGlvbnMiLCJzaW11bGF0ZUVycm9yIiwiaWR4IiwiZmluZEluZGV4IiwiaXNOYU4iLCJjbG9zZV9kYXRlIiwidCIsInBhcnNlIiwibmV4dCIsImNoYW5nZWQiLCJrIiwidXBkYXRlRGVhbFN0YWdlIiwibmV4dFN0YWdlSWQiLCJuZXh0X3N0YWdlX2lkIiwib2NjdXJyZWRfYXQiLCJvY2N1cnJlZEF0SVNPIiwiZ2V0T3BlbkRlYWxzQ291bnQiLCJsaXN0IiwiZ2V0TGFzdDdEYXlzUmVwbHlDb3VudCIsInNldmVuRGF5cyIsImdldFBpcGVsaW5lQ29udmVyc2lvbiIsImJ5U3RhZ2VDb3VudCIsInJlc3VsdCIsIm1hcCIsImNvdW50IiwiY29udmVyc2lvbiIsIm5leHRTdGFnZSIsIm5leHRDb3VudCIsIk1hdGgiLCJyb3VuZCIsInN0YWdlX25hbWUiLCJjb252ZXJzaW9uX3RvX25leHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/crmApi.ts\n"));

/***/ })

});